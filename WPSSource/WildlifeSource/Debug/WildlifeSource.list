
WildlifeSource.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .intvec       000000c0  10040000  10040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000036ec  100400c0  100400c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  100437ac  100437ac  000047ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  100437b0  100437b0  000047b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000000f8  100437b4  100437b4  000047b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM          00000008  100438ac  100438ac  000048ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         0000009c  200002bc  100438b4  000052bc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ram_preamble 0000002c  20000004  20000004  00006004  2**2
                  ALLOC
  8 .bss.blueRAM  00000000  200000c0  200000c0  00000000  2**0
                  ALLOC
  9 .bss          000001fc  200000c0  200000c0  00006004  2**2
                  ALLOC
 10 .noinit       00000000  20000358  10043950  00000000  2**0
                  ALLOC
 11 .ota_region_end 00000000  10043950  10043950  00005358  2**0
                  CONTENTS
 12 .heap         00000000  20000358  20000358  00005358  2**0
                  CONTENTS
 13 .stack        00000c00  20005400  20005400  00005400  2**0
                  ALLOC
 14 .rom_info     00000000  10000000  10000000  00005358  2**0
                  CONTENTS
 15 .ARM.attributes 00000028  00000000  00000000  00005358  2**0
                  CONTENTS, READONLY
 16 .debug_info   0000a224  00000000  00000000  00005380  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00001bc1  00000000  00000000  0000f5a4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000009b8  00000000  00000000  00011168  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00000761  00000000  00000000  00011b20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00018d68  00000000  00000000  00012281  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0000b34d  00000000  00000000  0002afe9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    000a2c82  00000000  00000000  00036336  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  000d8fb8  2**0
                  CONTENTS, READONLY
 24 .debug_frame  00002924  00000000  00000000  000d8ffc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 0000007c  00000000  00000000  000db920  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

100400c0 <__gnu_thumb1_case_shi>:
100400c0:	b403      	push	{r0, r1}
100400c2:	4671      	mov	r1, lr
100400c4:	0849      	lsrs	r1, r1, #1
100400c6:	0040      	lsls	r0, r0, #1
100400c8:	0049      	lsls	r1, r1, #1
100400ca:	5e09      	ldrsh	r1, [r1, r0]
100400cc:	0049      	lsls	r1, r1, #1
100400ce:	448e      	add	lr, r1
100400d0:	bc03      	pop	{r0, r1}
100400d2:	4770      	bx	lr

100400d4 <__udivsi3>:
100400d4:	2200      	movs	r2, #0
100400d6:	0843      	lsrs	r3, r0, #1
100400d8:	428b      	cmp	r3, r1
100400da:	d374      	bcc.n	100401c6 <__udivsi3+0xf2>
100400dc:	0903      	lsrs	r3, r0, #4
100400de:	428b      	cmp	r3, r1
100400e0:	d35f      	bcc.n	100401a2 <__udivsi3+0xce>
100400e2:	0a03      	lsrs	r3, r0, #8
100400e4:	428b      	cmp	r3, r1
100400e6:	d344      	bcc.n	10040172 <__udivsi3+0x9e>
100400e8:	0b03      	lsrs	r3, r0, #12
100400ea:	428b      	cmp	r3, r1
100400ec:	d328      	bcc.n	10040140 <__udivsi3+0x6c>
100400ee:	0c03      	lsrs	r3, r0, #16
100400f0:	428b      	cmp	r3, r1
100400f2:	d30d      	bcc.n	10040110 <__udivsi3+0x3c>
100400f4:	22ff      	movs	r2, #255	@ 0xff
100400f6:	0209      	lsls	r1, r1, #8
100400f8:	ba12      	rev	r2, r2
100400fa:	0c03      	lsrs	r3, r0, #16
100400fc:	428b      	cmp	r3, r1
100400fe:	d302      	bcc.n	10040106 <__udivsi3+0x32>
10040100:	1212      	asrs	r2, r2, #8
10040102:	0209      	lsls	r1, r1, #8
10040104:	d065      	beq.n	100401d2 <__udivsi3+0xfe>
10040106:	0b03      	lsrs	r3, r0, #12
10040108:	428b      	cmp	r3, r1
1004010a:	d319      	bcc.n	10040140 <__udivsi3+0x6c>
1004010c:	e000      	b.n	10040110 <__udivsi3+0x3c>
1004010e:	0a09      	lsrs	r1, r1, #8
10040110:	0bc3      	lsrs	r3, r0, #15
10040112:	428b      	cmp	r3, r1
10040114:	d301      	bcc.n	1004011a <__udivsi3+0x46>
10040116:	03cb      	lsls	r3, r1, #15
10040118:	1ac0      	subs	r0, r0, r3
1004011a:	4152      	adcs	r2, r2
1004011c:	0b83      	lsrs	r3, r0, #14
1004011e:	428b      	cmp	r3, r1
10040120:	d301      	bcc.n	10040126 <__udivsi3+0x52>
10040122:	038b      	lsls	r3, r1, #14
10040124:	1ac0      	subs	r0, r0, r3
10040126:	4152      	adcs	r2, r2
10040128:	0b43      	lsrs	r3, r0, #13
1004012a:	428b      	cmp	r3, r1
1004012c:	d301      	bcc.n	10040132 <__udivsi3+0x5e>
1004012e:	034b      	lsls	r3, r1, #13
10040130:	1ac0      	subs	r0, r0, r3
10040132:	4152      	adcs	r2, r2
10040134:	0b03      	lsrs	r3, r0, #12
10040136:	428b      	cmp	r3, r1
10040138:	d301      	bcc.n	1004013e <__udivsi3+0x6a>
1004013a:	030b      	lsls	r3, r1, #12
1004013c:	1ac0      	subs	r0, r0, r3
1004013e:	4152      	adcs	r2, r2
10040140:	0ac3      	lsrs	r3, r0, #11
10040142:	428b      	cmp	r3, r1
10040144:	d301      	bcc.n	1004014a <__udivsi3+0x76>
10040146:	02cb      	lsls	r3, r1, #11
10040148:	1ac0      	subs	r0, r0, r3
1004014a:	4152      	adcs	r2, r2
1004014c:	0a83      	lsrs	r3, r0, #10
1004014e:	428b      	cmp	r3, r1
10040150:	d301      	bcc.n	10040156 <__udivsi3+0x82>
10040152:	028b      	lsls	r3, r1, #10
10040154:	1ac0      	subs	r0, r0, r3
10040156:	4152      	adcs	r2, r2
10040158:	0a43      	lsrs	r3, r0, #9
1004015a:	428b      	cmp	r3, r1
1004015c:	d301      	bcc.n	10040162 <__udivsi3+0x8e>
1004015e:	024b      	lsls	r3, r1, #9
10040160:	1ac0      	subs	r0, r0, r3
10040162:	4152      	adcs	r2, r2
10040164:	0a03      	lsrs	r3, r0, #8
10040166:	428b      	cmp	r3, r1
10040168:	d301      	bcc.n	1004016e <__udivsi3+0x9a>
1004016a:	020b      	lsls	r3, r1, #8
1004016c:	1ac0      	subs	r0, r0, r3
1004016e:	4152      	adcs	r2, r2
10040170:	d2cd      	bcs.n	1004010e <__udivsi3+0x3a>
10040172:	09c3      	lsrs	r3, r0, #7
10040174:	428b      	cmp	r3, r1
10040176:	d301      	bcc.n	1004017c <__udivsi3+0xa8>
10040178:	01cb      	lsls	r3, r1, #7
1004017a:	1ac0      	subs	r0, r0, r3
1004017c:	4152      	adcs	r2, r2
1004017e:	0983      	lsrs	r3, r0, #6
10040180:	428b      	cmp	r3, r1
10040182:	d301      	bcc.n	10040188 <__udivsi3+0xb4>
10040184:	018b      	lsls	r3, r1, #6
10040186:	1ac0      	subs	r0, r0, r3
10040188:	4152      	adcs	r2, r2
1004018a:	0943      	lsrs	r3, r0, #5
1004018c:	428b      	cmp	r3, r1
1004018e:	d301      	bcc.n	10040194 <__udivsi3+0xc0>
10040190:	014b      	lsls	r3, r1, #5
10040192:	1ac0      	subs	r0, r0, r3
10040194:	4152      	adcs	r2, r2
10040196:	0903      	lsrs	r3, r0, #4
10040198:	428b      	cmp	r3, r1
1004019a:	d301      	bcc.n	100401a0 <__udivsi3+0xcc>
1004019c:	010b      	lsls	r3, r1, #4
1004019e:	1ac0      	subs	r0, r0, r3
100401a0:	4152      	adcs	r2, r2
100401a2:	08c3      	lsrs	r3, r0, #3
100401a4:	428b      	cmp	r3, r1
100401a6:	d301      	bcc.n	100401ac <__udivsi3+0xd8>
100401a8:	00cb      	lsls	r3, r1, #3
100401aa:	1ac0      	subs	r0, r0, r3
100401ac:	4152      	adcs	r2, r2
100401ae:	0883      	lsrs	r3, r0, #2
100401b0:	428b      	cmp	r3, r1
100401b2:	d301      	bcc.n	100401b8 <__udivsi3+0xe4>
100401b4:	008b      	lsls	r3, r1, #2
100401b6:	1ac0      	subs	r0, r0, r3
100401b8:	4152      	adcs	r2, r2
100401ba:	0843      	lsrs	r3, r0, #1
100401bc:	428b      	cmp	r3, r1
100401be:	d301      	bcc.n	100401c4 <__udivsi3+0xf0>
100401c0:	004b      	lsls	r3, r1, #1
100401c2:	1ac0      	subs	r0, r0, r3
100401c4:	4152      	adcs	r2, r2
100401c6:	1a41      	subs	r1, r0, r1
100401c8:	d200      	bcs.n	100401cc <__udivsi3+0xf8>
100401ca:	4601      	mov	r1, r0
100401cc:	4152      	adcs	r2, r2
100401ce:	4610      	mov	r0, r2
100401d0:	4770      	bx	lr
100401d2:	e7ff      	b.n	100401d4 <__udivsi3+0x100>
100401d4:	b501      	push	{r0, lr}
100401d6:	2000      	movs	r0, #0
100401d8:	f000 f806 	bl	100401e8 <__aeabi_idiv0>
100401dc:	bd02      	pop	{r1, pc}
100401de:	46c0      	nop			@ (mov r8, r8)

100401e0 <__aeabi_uidivmod>:
100401e0:	2900      	cmp	r1, #0
100401e2:	d0f7      	beq.n	100401d4 <__udivsi3+0x100>
100401e4:	e776      	b.n	100400d4 <__udivsi3>
100401e6:	4770      	bx	lr

100401e8 <__aeabi_idiv0>:
100401e8:	4770      	bx	lr
100401ea:	46c0      	nop			@ (mov r8, r8)

100401ec <__aeabi_uldivmod>:
100401ec:	2b00      	cmp	r3, #0
100401ee:	d111      	bne.n	10040214 <__aeabi_uldivmod+0x28>
100401f0:	2a00      	cmp	r2, #0
100401f2:	d10f      	bne.n	10040214 <__aeabi_uldivmod+0x28>
100401f4:	2900      	cmp	r1, #0
100401f6:	d100      	bne.n	100401fa <__aeabi_uldivmod+0xe>
100401f8:	2800      	cmp	r0, #0
100401fa:	d002      	beq.n	10040202 <__aeabi_uldivmod+0x16>
100401fc:	2100      	movs	r1, #0
100401fe:	43c9      	mvns	r1, r1
10040200:	0008      	movs	r0, r1
10040202:	b407      	push	{r0, r1, r2}
10040204:	4802      	ldr	r0, [pc, #8]	@ (10040210 <__aeabi_uldivmod+0x24>)
10040206:	a102      	add	r1, pc, #8	@ (adr r1, 10040210 <__aeabi_uldivmod+0x24>)
10040208:	1840      	adds	r0, r0, r1
1004020a:	9002      	str	r0, [sp, #8]
1004020c:	bd03      	pop	{r0, r1, pc}
1004020e:	46c0      	nop			@ (mov r8, r8)
10040210:	ffffffd9 	.word	0xffffffd9
10040214:	b403      	push	{r0, r1}
10040216:	4668      	mov	r0, sp
10040218:	b501      	push	{r0, lr}
1004021a:	9802      	ldr	r0, [sp, #8]
1004021c:	f000 f806 	bl	1004022c <__udivmoddi4>
10040220:	9b01      	ldr	r3, [sp, #4]
10040222:	469e      	mov	lr, r3
10040224:	b002      	add	sp, #8
10040226:	bc0c      	pop	{r2, r3}
10040228:	4770      	bx	lr
1004022a:	46c0      	nop			@ (mov r8, r8)

1004022c <__udivmoddi4>:
1004022c:	b5f0      	push	{r4, r5, r6, r7, lr}
1004022e:	4657      	mov	r7, sl
10040230:	464e      	mov	r6, r9
10040232:	4645      	mov	r5, r8
10040234:	46de      	mov	lr, fp
10040236:	b5e0      	push	{r5, r6, r7, lr}
10040238:	0004      	movs	r4, r0
1004023a:	000d      	movs	r5, r1
1004023c:	4692      	mov	sl, r2
1004023e:	4699      	mov	r9, r3
10040240:	b083      	sub	sp, #12
10040242:	428b      	cmp	r3, r1
10040244:	d830      	bhi.n	100402a8 <__udivmoddi4+0x7c>
10040246:	d02d      	beq.n	100402a4 <__udivmoddi4+0x78>
10040248:	4649      	mov	r1, r9
1004024a:	4650      	mov	r0, sl
1004024c:	f000 f8ba 	bl	100403c4 <__clzdi2>
10040250:	0029      	movs	r1, r5
10040252:	0006      	movs	r6, r0
10040254:	0020      	movs	r0, r4
10040256:	f000 f8b5 	bl	100403c4 <__clzdi2>
1004025a:	1a33      	subs	r3, r6, r0
1004025c:	4698      	mov	r8, r3
1004025e:	3b20      	subs	r3, #32
10040260:	d434      	bmi.n	100402cc <__udivmoddi4+0xa0>
10040262:	469b      	mov	fp, r3
10040264:	4653      	mov	r3, sl
10040266:	465a      	mov	r2, fp
10040268:	4093      	lsls	r3, r2
1004026a:	4642      	mov	r2, r8
1004026c:	001f      	movs	r7, r3
1004026e:	4653      	mov	r3, sl
10040270:	4093      	lsls	r3, r2
10040272:	001e      	movs	r6, r3
10040274:	42af      	cmp	r7, r5
10040276:	d83b      	bhi.n	100402f0 <__udivmoddi4+0xc4>
10040278:	42af      	cmp	r7, r5
1004027a:	d100      	bne.n	1004027e <__udivmoddi4+0x52>
1004027c:	e079      	b.n	10040372 <__udivmoddi4+0x146>
1004027e:	465b      	mov	r3, fp
10040280:	1ba4      	subs	r4, r4, r6
10040282:	41bd      	sbcs	r5, r7
10040284:	2b00      	cmp	r3, #0
10040286:	da00      	bge.n	1004028a <__udivmoddi4+0x5e>
10040288:	e076      	b.n	10040378 <__udivmoddi4+0x14c>
1004028a:	2200      	movs	r2, #0
1004028c:	2300      	movs	r3, #0
1004028e:	9200      	str	r2, [sp, #0]
10040290:	9301      	str	r3, [sp, #4]
10040292:	2301      	movs	r3, #1
10040294:	465a      	mov	r2, fp
10040296:	4093      	lsls	r3, r2
10040298:	9301      	str	r3, [sp, #4]
1004029a:	2301      	movs	r3, #1
1004029c:	4642      	mov	r2, r8
1004029e:	4093      	lsls	r3, r2
100402a0:	9300      	str	r3, [sp, #0]
100402a2:	e029      	b.n	100402f8 <__udivmoddi4+0xcc>
100402a4:	4282      	cmp	r2, r0
100402a6:	d9cf      	bls.n	10040248 <__udivmoddi4+0x1c>
100402a8:	2200      	movs	r2, #0
100402aa:	2300      	movs	r3, #0
100402ac:	9200      	str	r2, [sp, #0]
100402ae:	9301      	str	r3, [sp, #4]
100402b0:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
100402b2:	2b00      	cmp	r3, #0
100402b4:	d001      	beq.n	100402ba <__udivmoddi4+0x8e>
100402b6:	601c      	str	r4, [r3, #0]
100402b8:	605d      	str	r5, [r3, #4]
100402ba:	9800      	ldr	r0, [sp, #0]
100402bc:	9901      	ldr	r1, [sp, #4]
100402be:	b003      	add	sp, #12
100402c0:	bcf0      	pop	{r4, r5, r6, r7}
100402c2:	46bb      	mov	fp, r7
100402c4:	46b2      	mov	sl, r6
100402c6:	46a9      	mov	r9, r5
100402c8:	46a0      	mov	r8, r4
100402ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
100402cc:	4642      	mov	r2, r8
100402ce:	469b      	mov	fp, r3
100402d0:	2320      	movs	r3, #32
100402d2:	1a9b      	subs	r3, r3, r2
100402d4:	4652      	mov	r2, sl
100402d6:	40da      	lsrs	r2, r3
100402d8:	4641      	mov	r1, r8
100402da:	0013      	movs	r3, r2
100402dc:	464a      	mov	r2, r9
100402de:	408a      	lsls	r2, r1
100402e0:	0017      	movs	r7, r2
100402e2:	4642      	mov	r2, r8
100402e4:	431f      	orrs	r7, r3
100402e6:	4653      	mov	r3, sl
100402e8:	4093      	lsls	r3, r2
100402ea:	001e      	movs	r6, r3
100402ec:	42af      	cmp	r7, r5
100402ee:	d9c3      	bls.n	10040278 <__udivmoddi4+0x4c>
100402f0:	2200      	movs	r2, #0
100402f2:	2300      	movs	r3, #0
100402f4:	9200      	str	r2, [sp, #0]
100402f6:	9301      	str	r3, [sp, #4]
100402f8:	4643      	mov	r3, r8
100402fa:	2b00      	cmp	r3, #0
100402fc:	d0d8      	beq.n	100402b0 <__udivmoddi4+0x84>
100402fe:	07fb      	lsls	r3, r7, #31
10040300:	0872      	lsrs	r2, r6, #1
10040302:	431a      	orrs	r2, r3
10040304:	4646      	mov	r6, r8
10040306:	087b      	lsrs	r3, r7, #1
10040308:	e00e      	b.n	10040328 <__udivmoddi4+0xfc>
1004030a:	42ab      	cmp	r3, r5
1004030c:	d101      	bne.n	10040312 <__udivmoddi4+0xe6>
1004030e:	42a2      	cmp	r2, r4
10040310:	d80c      	bhi.n	1004032c <__udivmoddi4+0x100>
10040312:	1aa4      	subs	r4, r4, r2
10040314:	419d      	sbcs	r5, r3
10040316:	2001      	movs	r0, #1
10040318:	1924      	adds	r4, r4, r4
1004031a:	416d      	adcs	r5, r5
1004031c:	2100      	movs	r1, #0
1004031e:	3e01      	subs	r6, #1
10040320:	1824      	adds	r4, r4, r0
10040322:	414d      	adcs	r5, r1
10040324:	2e00      	cmp	r6, #0
10040326:	d006      	beq.n	10040336 <__udivmoddi4+0x10a>
10040328:	42ab      	cmp	r3, r5
1004032a:	d9ee      	bls.n	1004030a <__udivmoddi4+0xde>
1004032c:	3e01      	subs	r6, #1
1004032e:	1924      	adds	r4, r4, r4
10040330:	416d      	adcs	r5, r5
10040332:	2e00      	cmp	r6, #0
10040334:	d1f8      	bne.n	10040328 <__udivmoddi4+0xfc>
10040336:	9800      	ldr	r0, [sp, #0]
10040338:	9901      	ldr	r1, [sp, #4]
1004033a:	465b      	mov	r3, fp
1004033c:	1900      	adds	r0, r0, r4
1004033e:	4169      	adcs	r1, r5
10040340:	2b00      	cmp	r3, #0
10040342:	db24      	blt.n	1004038e <__udivmoddi4+0x162>
10040344:	002b      	movs	r3, r5
10040346:	465a      	mov	r2, fp
10040348:	4644      	mov	r4, r8
1004034a:	40d3      	lsrs	r3, r2
1004034c:	002a      	movs	r2, r5
1004034e:	40e2      	lsrs	r2, r4
10040350:	001c      	movs	r4, r3
10040352:	465b      	mov	r3, fp
10040354:	0015      	movs	r5, r2
10040356:	2b00      	cmp	r3, #0
10040358:	db2a      	blt.n	100403b0 <__udivmoddi4+0x184>
1004035a:	0026      	movs	r6, r4
1004035c:	409e      	lsls	r6, r3
1004035e:	0033      	movs	r3, r6
10040360:	0026      	movs	r6, r4
10040362:	4647      	mov	r7, r8
10040364:	40be      	lsls	r6, r7
10040366:	0032      	movs	r2, r6
10040368:	1a80      	subs	r0, r0, r2
1004036a:	4199      	sbcs	r1, r3
1004036c:	9000      	str	r0, [sp, #0]
1004036e:	9101      	str	r1, [sp, #4]
10040370:	e79e      	b.n	100402b0 <__udivmoddi4+0x84>
10040372:	42a3      	cmp	r3, r4
10040374:	d8bc      	bhi.n	100402f0 <__udivmoddi4+0xc4>
10040376:	e782      	b.n	1004027e <__udivmoddi4+0x52>
10040378:	4642      	mov	r2, r8
1004037a:	2320      	movs	r3, #32
1004037c:	2100      	movs	r1, #0
1004037e:	1a9b      	subs	r3, r3, r2
10040380:	2200      	movs	r2, #0
10040382:	9100      	str	r1, [sp, #0]
10040384:	9201      	str	r2, [sp, #4]
10040386:	2201      	movs	r2, #1
10040388:	40da      	lsrs	r2, r3
1004038a:	9201      	str	r2, [sp, #4]
1004038c:	e785      	b.n	1004029a <__udivmoddi4+0x6e>
1004038e:	4642      	mov	r2, r8
10040390:	2320      	movs	r3, #32
10040392:	1a9b      	subs	r3, r3, r2
10040394:	002a      	movs	r2, r5
10040396:	4646      	mov	r6, r8
10040398:	409a      	lsls	r2, r3
1004039a:	0023      	movs	r3, r4
1004039c:	40f3      	lsrs	r3, r6
1004039e:	4644      	mov	r4, r8
100403a0:	4313      	orrs	r3, r2
100403a2:	002a      	movs	r2, r5
100403a4:	40e2      	lsrs	r2, r4
100403a6:	001c      	movs	r4, r3
100403a8:	465b      	mov	r3, fp
100403aa:	0015      	movs	r5, r2
100403ac:	2b00      	cmp	r3, #0
100403ae:	dad4      	bge.n	1004035a <__udivmoddi4+0x12e>
100403b0:	4642      	mov	r2, r8
100403b2:	002f      	movs	r7, r5
100403b4:	2320      	movs	r3, #32
100403b6:	0026      	movs	r6, r4
100403b8:	4097      	lsls	r7, r2
100403ba:	1a9b      	subs	r3, r3, r2
100403bc:	40de      	lsrs	r6, r3
100403be:	003b      	movs	r3, r7
100403c0:	4333      	orrs	r3, r6
100403c2:	e7cd      	b.n	10040360 <__udivmoddi4+0x134>

100403c4 <__clzdi2>:
100403c4:	b510      	push	{r4, lr}
100403c6:	2900      	cmp	r1, #0
100403c8:	d103      	bne.n	100403d2 <__clzdi2+0xe>
100403ca:	f000 f807 	bl	100403dc <__clzsi2>
100403ce:	3020      	adds	r0, #32
100403d0:	e002      	b.n	100403d8 <__clzdi2+0x14>
100403d2:	0008      	movs	r0, r1
100403d4:	f000 f802 	bl	100403dc <__clzsi2>
100403d8:	bd10      	pop	{r4, pc}
100403da:	46c0      	nop			@ (mov r8, r8)

100403dc <__clzsi2>:
100403dc:	211c      	movs	r1, #28
100403de:	2301      	movs	r3, #1
100403e0:	041b      	lsls	r3, r3, #16
100403e2:	4298      	cmp	r0, r3
100403e4:	d301      	bcc.n	100403ea <__clzsi2+0xe>
100403e6:	0c00      	lsrs	r0, r0, #16
100403e8:	3910      	subs	r1, #16
100403ea:	0a1b      	lsrs	r3, r3, #8
100403ec:	4298      	cmp	r0, r3
100403ee:	d301      	bcc.n	100403f4 <__clzsi2+0x18>
100403f0:	0a00      	lsrs	r0, r0, #8
100403f2:	3908      	subs	r1, #8
100403f4:	091b      	lsrs	r3, r3, #4
100403f6:	4298      	cmp	r0, r3
100403f8:	d301      	bcc.n	100403fe <__clzsi2+0x22>
100403fa:	0900      	lsrs	r0, r0, #4
100403fc:	3904      	subs	r1, #4
100403fe:	a202      	add	r2, pc, #8	@ (adr r2, 10040408 <__clzsi2+0x2c>)
10040400:	5c10      	ldrb	r0, [r2, r0]
10040402:	1840      	adds	r0, r0, r1
10040404:	4770      	bx	lr
10040406:	46c0      	nop			@ (mov r8, r8)
10040408:	02020304 	.word	0x02020304
1004040c:	01010101 	.word	0x01010101
	...

10040418 <LL_PWR_SetNoPullA>:
  *         @arg @ref LL_PWR_GPIO_BIT_15(*)
  *         (*) available only on STM32WB06 and STM32WB07 devices
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetNoPullA(uint32_t GPIONumber)
{
10040418:	b580      	push	{r7, lr}
1004041a:	b082      	sub	sp, #8
1004041c:	af00      	add	r7, sp, #0
1004041e:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRA, GPIONumber);
10040420:	4b08      	ldr	r3, [pc, #32]	@ (10040444 <LL_PWR_SetNoPullA+0x2c>)
10040422:	6a1a      	ldr	r2, [r3, #32]
10040424:	687b      	ldr	r3, [r7, #4]
10040426:	43d9      	mvns	r1, r3
10040428:	4b06      	ldr	r3, [pc, #24]	@ (10040444 <LL_PWR_SetNoPullA+0x2c>)
1004042a:	400a      	ands	r2, r1
1004042c:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(PWR->PDCRA, GPIONumber);
1004042e:	4b05      	ldr	r3, [pc, #20]	@ (10040444 <LL_PWR_SetNoPullA+0x2c>)
10040430:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10040432:	687b      	ldr	r3, [r7, #4]
10040434:	43d9      	mvns	r1, r3
10040436:	4b03      	ldr	r3, [pc, #12]	@ (10040444 <LL_PWR_SetNoPullA+0x2c>)
10040438:	400a      	ands	r2, r1
1004043a:	625a      	str	r2, [r3, #36]	@ 0x24
}
1004043c:	46c0      	nop			@ (mov r8, r8)
1004043e:	46bd      	mov	sp, r7
10040440:	b002      	add	sp, #8
10040442:	bd80      	pop	{r7, pc}
10040444:	48500000 	.word	0x48500000

10040448 <LL_PWR_SetNoPullB>:
  *         @arg @ref LL_PWR_GPIO_BIT_15
  *         (*) available only oon STM32WB06 and STM32WB07 devices
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetNoPullB(uint32_t GPIONumber)
{
10040448:	b580      	push	{r7, lr}
1004044a:	b082      	sub	sp, #8
1004044c:	af00      	add	r7, sp, #0
1004044e:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRB, GPIONumber);
10040450:	4b08      	ldr	r3, [pc, #32]	@ (10040474 <LL_PWR_SetNoPullB+0x2c>)
10040452:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
10040454:	687b      	ldr	r3, [r7, #4]
10040456:	43d9      	mvns	r1, r3
10040458:	4b06      	ldr	r3, [pc, #24]	@ (10040474 <LL_PWR_SetNoPullB+0x2c>)
1004045a:	400a      	ands	r2, r1
1004045c:	629a      	str	r2, [r3, #40]	@ 0x28
  CLEAR_BIT(PWR->PDCRB, GPIONumber);
1004045e:	4b05      	ldr	r3, [pc, #20]	@ (10040474 <LL_PWR_SetNoPullB+0x2c>)
10040460:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10040462:	687b      	ldr	r3, [r7, #4]
10040464:	43d9      	mvns	r1, r3
10040466:	4b03      	ldr	r3, [pc, #12]	@ (10040474 <LL_PWR_SetNoPullB+0x2c>)
10040468:	400a      	ands	r2, r1
1004046a:	62da      	str	r2, [r3, #44]	@ 0x2c
}
1004046c:	46c0      	nop			@ (mov r8, r8)
1004046e:	46bd      	mov	sp, r7
10040470:	b002      	add	sp, #8
10040472:	bd80      	pop	{r7, pc}
10040474:	48500000 	.word	0x48500000

10040478 <LL_AHB1_GRP1_EnableClock>:
  * @arg LL_AHB1_GRP1_PERIPH_RNG
  * @retval None
  * @note   LL_AHB1_GRP1_PERIPH_PKA
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
10040478:	b580      	push	{r7, lr}
1004047a:	b084      	sub	sp, #16
1004047c:	af00      	add	r7, sp, #0
1004047e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
10040480:	4b07      	ldr	r3, [pc, #28]	@ (100404a0 <LL_AHB1_GRP1_EnableClock+0x28>)
10040482:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040484:	4b06      	ldr	r3, [pc, #24]	@ (100404a0 <LL_AHB1_GRP1_EnableClock+0x28>)
10040486:	687a      	ldr	r2, [r7, #4]
10040488:	430a      	orrs	r2, r1
1004048a:	651a      	str	r2, [r3, #80]	@ 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
1004048c:	4b04      	ldr	r3, [pc, #16]	@ (100404a0 <LL_AHB1_GRP1_EnableClock+0x28>)
1004048e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040490:	687a      	ldr	r2, [r7, #4]
10040492:	4013      	ands	r3, r2
10040494:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040496:	68fb      	ldr	r3, [r7, #12]
}
10040498:	46c0      	nop			@ (mov r8, r8)
1004049a:	46bd      	mov	sp, r7
1004049c:	b004      	add	sp, #16
1004049e:	bd80      	pop	{r7, pc}
100404a0:	48400000 	.word	0x48400000

100404a4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
100404a4:	b580      	push	{r7, lr}
100404a6:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
100404a8:	f000 fe86 	bl	100411b8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
100404ac:	f000 f866 	bl	1004057c <SystemClock_Config>

  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
100404b0:	f000 f881 	bl	100405b6 <PeriphCommonClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
100404b4:	f000 f89c 	bl	100405f0 <MX_GPIO_Init>
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Initialize leds */
  BSP_LED_Init(LED_BLUE);
100404b8:	2000      	movs	r0, #0
100404ba:	f000 fc4d 	bl	10040d58 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
100404be:	2001      	movs	r0, #1
100404c0:	f000 fc4a 	bl	10040d58 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
100404c4:	2002      	movs	r0, #2
100404c6:	f000 fc47 	bl	10040d58 <BSP_LED_Init>

  /* Initialize USER push-button, will be used to trigger an interrupt each time it's pressed.*/
  BSP_PB_Init(B1, BUTTON_MODE_EXTI);
100404ca:	2101      	movs	r1, #1
100404cc:	2000      	movs	r0, #0
100404ce:	f000 fcf3 	bl	10040eb8 <BSP_PB_Init>
  BSP_PB_Init(B2, BUTTON_MODE_EXTI);
100404d2:	2101      	movs	r1, #1
100404d4:	2001      	movs	r0, #1
100404d6:	f000 fcef 	bl	10040eb8 <BSP_PB_Init>
  BSP_PB_Init(B3, BUTTON_MODE_EXTI);
100404da:	2101      	movs	r1, #1
100404dc:	2002      	movs	r0, #2
100404de:	f000 fceb 	bl	10040eb8 <BSP_PB_Init>

  /* Initialize COM1 port (115200, 8 bits (7-bit data + 1 stop bit), no parity */
  BspCOMInit.BaudRate   = 115200;
100404e2:	4b22      	ldr	r3, [pc, #136]	@ (1004056c <main+0xc8>)
100404e4:	22e1      	movs	r2, #225	@ 0xe1
100404e6:	0252      	lsls	r2, r2, #9
100404e8:	601a      	str	r2, [r3, #0]
  BspCOMInit.WordLength = COM_WORDLENGTH_8B;
100404ea:	4b20      	ldr	r3, [pc, #128]	@ (1004056c <main+0xc8>)
100404ec:	2200      	movs	r2, #0
100404ee:	605a      	str	r2, [r3, #4]
  BspCOMInit.StopBits   = COM_STOPBITS_1;
100404f0:	4b1e      	ldr	r3, [pc, #120]	@ (1004056c <main+0xc8>)
100404f2:	2200      	movs	r2, #0
100404f4:	811a      	strh	r2, [r3, #8]
  BspCOMInit.Parity     = COM_PARITY_NONE;
100404f6:	4b1d      	ldr	r3, [pc, #116]	@ (1004056c <main+0xc8>)
100404f8:	2200      	movs	r2, #0
100404fa:	815a      	strh	r2, [r3, #10]
  BspCOMInit.HwFlowCtl  = COM_HWCONTROL_NONE;
100404fc:	4b1b      	ldr	r3, [pc, #108]	@ (1004056c <main+0xc8>)
100404fe:	2200      	movs	r2, #0
10040500:	819a      	strh	r2, [r3, #12]
  if (BSP_COM_Init(COM1, &BspCOMInit) != BSP_ERROR_NONE)
10040502:	4b1a      	ldr	r3, [pc, #104]	@ (1004056c <main+0xc8>)
10040504:	0019      	movs	r1, r3
10040506:	2000      	movs	r0, #0
10040508:	f000 fd84 	bl	10041014 <BSP_COM_Init>
1004050c:	1e03      	subs	r3, r0, #0
1004050e:	d001      	beq.n	10040514 <main+0x70>
  {
    Error_Handler();
10040510:	f000 f8fa 	bl	10040708 <Error_Handler>
  }

  /* USER CODE BEGIN BSP */

  /* -- Sample board code to send message over COM1 port ---- */
  printf("Welcome to STM32 world !\n\r");
10040514:	4b16      	ldr	r3, [pc, #88]	@ (10040570 <main+0xcc>)
10040516:	0018      	movs	r0, r3
10040518:	f002 fa6e 	bl	100429f8 <iprintf>

  /* -- Sample board code to switch on leds ---- */
  BSP_LED_On(LED_BLUE);
1004051c:	2000      	movs	r0, #0
1004051e:	f000 fc91 	bl	10040e44 <BSP_LED_On>
  BSP_LED_On(LED_GREEN);
10040522:	2001      	movs	r0, #1
10040524:	f000 fc8e 	bl	10040e44 <BSP_LED_On>
  BSP_LED_On(LED_RED);
10040528:	2002      	movs	r0, #2
1004052a:	f000 fc8b 	bl	10040e44 <BSP_LED_On>
  /* USER CODE BEGIN WHILE */
  while (1)
  {

    /* -- Sample board code for User push-button in interrupt mode ---- */
    BSP_LED_Toggle(LED_BLUE);
1004052e:	2000      	movs	r0, #0
10040530:	f000 fca6 	bl	10040e80 <BSP_LED_Toggle>
    HAL_Delay(delay);
10040534:	4b0f      	ldr	r3, [pc, #60]	@ (10040574 <main+0xd0>)
10040536:	681b      	ldr	r3, [r3, #0]
10040538:	0018      	movs	r0, r3
1004053a:	f000 fec3 	bl	100412c4 <HAL_Delay>

    BSP_LED_Toggle(LED_GREEN);
1004053e:	2001      	movs	r0, #1
10040540:	f000 fc9e 	bl	10040e80 <BSP_LED_Toggle>
    HAL_Delay(delay);
10040544:	4b0b      	ldr	r3, [pc, #44]	@ (10040574 <main+0xd0>)
10040546:	681b      	ldr	r3, [r3, #0]
10040548:	0018      	movs	r0, r3
1004054a:	f000 febb 	bl	100412c4 <HAL_Delay>

    BSP_LED_Toggle(LED_RED);
1004054e:	2002      	movs	r0, #2
10040550:	f000 fc96 	bl	10040e80 <BSP_LED_Toggle>
    HAL_Delay(delay);
10040554:	4b07      	ldr	r3, [pc, #28]	@ (10040574 <main+0xd0>)
10040556:	681b      	ldr	r3, [r3, #0]
10040558:	0018      	movs	r0, r3
1004055a:	f000 feb3 	bl	100412c4 <HAL_Delay>

    printf("testing\r\n");
1004055e:	4b06      	ldr	r3, [pc, #24]	@ (10040578 <main+0xd4>)
10040560:	0018      	movs	r0, r3
10040562:	f002 faaf 	bl	10042ac4 <puts>
    BSP_LED_Toggle(LED_BLUE);
10040566:	46c0      	nop			@ (mov r8, r8)
10040568:	e7e1      	b.n	1004052e <main+0x8a>
1004056a:	46c0      	nop			@ (mov r8, r8)
1004056c:	200000c0 	.word	0x200000c0
10040570:	100437b4 	.word	0x100437b4
10040574:	200002bc 	.word	0x200002bc
10040578:	100437d0 	.word	0x100437d0

1004057c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
1004057c:	b580      	push	{r7, lr}
1004057e:	b082      	sub	sp, #8
10040580:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
10040582:	003b      	movs	r3, r7
10040584:	0018      	movs	r0, r3
10040586:	2308      	movs	r3, #8
10040588:	001a      	movs	r2, r3
1004058a:	2100      	movs	r1, #0
1004058c:	f002 fb90 	bl	10042cb0 <memset>

  /** Configure the SYSCLKSource and SYSCLKDivider
  */
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
10040590:	003b      	movs	r3, r7
10040592:	2202      	movs	r2, #2
10040594:	601a      	str	r2, [r3, #0]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_RC64MPLL_DIV1;
10040596:	003b      	movs	r3, r7
10040598:	2200      	movs	r2, #0
1004059a:	605a      	str	r2, [r3, #4]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_WAIT_STATES_1) != HAL_OK)
1004059c:	003b      	movs	r3, r7
1004059e:	2110      	movs	r1, #16
100405a0:	0018      	movs	r0, r3
100405a2:	f001 fa59 	bl	10041a58 <HAL_RCC_ClockConfig>
100405a6:	1e03      	subs	r3, r0, #0
100405a8:	d001      	beq.n	100405ae <SystemClock_Config+0x32>
  {
    Error_Handler();
100405aa:	f000 f8ad 	bl	10040708 <Error_Handler>
  }
}
100405ae:	46c0      	nop			@ (mov r8, r8)
100405b0:	46bd      	mov	sp, r7
100405b2:	b002      	add	sp, #8
100405b4:	bd80      	pop	{r7, pc}

100405b6 <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
100405b6:	b580      	push	{r7, lr}
100405b8:	b086      	sub	sp, #24
100405ba:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
100405bc:	003b      	movs	r3, r7
100405be:	0018      	movs	r0, r3
100405c0:	2318      	movs	r3, #24
100405c2:	001a      	movs	r2, r3
100405c4:	2100      	movs	r1, #0
100405c6:	f002 fb73 	bl	10042cb0 <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS;
100405ca:	003b      	movs	r3, r7
100405cc:	2202      	movs	r2, #2
100405ce:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLK_DIV4;
100405d0:	003b      	movs	r3, r7
100405d2:	2280      	movs	r2, #128	@ 0x80
100405d4:	0152      	lsls	r2, r2, #5
100405d6:	615a      	str	r2, [r3, #20]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
100405d8:	003b      	movs	r3, r7
100405da:	0018      	movs	r0, r3
100405dc:	f001 fbd2 	bl	10041d84 <HAL_RCCEx_PeriphCLKConfig>
100405e0:	1e03      	subs	r3, r0, #0
100405e2:	d001      	beq.n	100405e8 <PeriphCommonClock_Config+0x32>
  {
    Error_Handler();
100405e4:	f000 f890 	bl	10040708 <Error_Handler>
  }
}
100405e8:	46c0      	nop			@ (mov r8, r8)
100405ea:	46bd      	mov	sp, r7
100405ec:	b006      	add	sp, #24
100405ee:	bd80      	pop	{r7, pc}

100405f0 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
100405f0:	b580      	push	{r7, lr}
100405f2:	b086      	sub	sp, #24
100405f4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
100405f6:	1d3b      	adds	r3, r7, #4
100405f8:	0018      	movs	r0, r3
100405fa:	2314      	movs	r3, #20
100405fc:	001a      	movs	r2, r3
100405fe:	2100      	movs	r1, #0
10040600:	f002 fb56 	bl	10042cb0 <memset>
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
10040604:	2008      	movs	r0, #8
10040606:	f7ff ff37 	bl	10040478 <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
1004060a:	2004      	movs	r0, #4
1004060c:	f7ff ff34 	bl	10040478 <LL_AHB1_GRP1_EnableClock>

  /*Configure GPIO pin : SPI3_SCK_Pin */
  GPIO_InitStruct.Pin = SPI3_SCK_Pin;
10040610:	1d3b      	adds	r3, r7, #4
10040612:	2208      	movs	r2, #8
10040614:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
10040616:	1d3b      	adds	r3, r7, #4
10040618:	2202      	movs	r2, #2
1004061a:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
1004061c:	1d3b      	adds	r3, r7, #4
1004061e:	2200      	movs	r2, #0
10040620:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
10040622:	1d3b      	adds	r3, r7, #4
10040624:	2203      	movs	r2, #3
10040626:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = GPIO_AF4_SPI3;
10040628:	1d3b      	adds	r3, r7, #4
1004062a:	2204      	movs	r2, #4
1004062c:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(SPI3_SCK_GPIO_Port, &GPIO_InitStruct);
1004062e:	1d3b      	adds	r3, r7, #4
10040630:	4a1e      	ldr	r2, [pc, #120]	@ (100406ac <MX_GPIO_Init+0xbc>)
10040632:	0019      	movs	r1, r3
10040634:	0010      	movs	r0, r2
10040636:	f000 ff47 	bl	100414c8 <HAL_GPIO_Init>

  /*Configure GPIO pins : SPI3_MISO_Pin SPI3_NSS_Pin SPI3_MOSI_Pin */
  GPIO_InitStruct.Pin = SPI3_MISO_Pin|SPI3_NSS_Pin|SPI3_MOSI_Pin;
1004063a:	1d3b      	adds	r3, r7, #4
1004063c:	22b0      	movs	r2, #176	@ 0xb0
1004063e:	0112      	lsls	r2, r2, #4
10040640:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
10040642:	1d3b      	adds	r3, r7, #4
10040644:	2202      	movs	r2, #2
10040646:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
10040648:	1d3b      	adds	r3, r7, #4
1004064a:	2200      	movs	r2, #0
1004064c:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
1004064e:	1d3b      	adds	r3, r7, #4
10040650:	2203      	movs	r2, #3
10040652:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = GPIO_AF3_SPI3;
10040654:	1d3b      	adds	r3, r7, #4
10040656:	2203      	movs	r2, #3
10040658:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
1004065a:	1d3a      	adds	r2, r7, #4
1004065c:	2390      	movs	r3, #144	@ 0x90
1004065e:	05db      	lsls	r3, r3, #23
10040660:	0011      	movs	r1, r2
10040662:	0018      	movs	r0, r3
10040664:	f000 ff30 	bl	100414c8 <HAL_GPIO_Init>

  /*Configure GPIO pins : I2C1_SDA_Pin I2C1_SCL_Pin */
  GPIO_InitStruct.Pin = I2C1_SDA_Pin|I2C1_SCL_Pin;
10040668:	1d3b      	adds	r3, r7, #4
1004066a:	22c0      	movs	r2, #192	@ 0xc0
1004066c:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
1004066e:	1d3b      	adds	r3, r7, #4
10040670:	2212      	movs	r2, #18
10040672:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
10040674:	1d3b      	adds	r3, r7, #4
10040676:	2200      	movs	r2, #0
10040678:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
1004067a:	1d3b      	adds	r3, r7, #4
1004067c:	2203      	movs	r2, #3
1004067e:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_I2C1;
10040680:	1d3b      	adds	r3, r7, #4
10040682:	2200      	movs	r2, #0
10040684:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
10040686:	1d3b      	adds	r3, r7, #4
10040688:	4a08      	ldr	r2, [pc, #32]	@ (100406ac <MX_GPIO_Init+0xbc>)
1004068a:	0019      	movs	r1, r3
1004068c:	0010      	movs	r0, r2
1004068e:	f000 ff1b 	bl	100414c8 <HAL_GPIO_Init>

  /**/
  LL_PWR_SetNoPullB(LL_PWR_GPIO_BIT_3|LL_PWR_GPIO_BIT_7|LL_PWR_GPIO_BIT_6);
10040692:	20c8      	movs	r0, #200	@ 0xc8
10040694:	f7ff fed8 	bl	10040448 <LL_PWR_SetNoPullB>

  /**/
  LL_PWR_SetNoPullA(LL_PWR_GPIO_BIT_8|LL_PWR_GPIO_BIT_9|LL_PWR_GPIO_BIT_11);
10040698:	23b0      	movs	r3, #176	@ 0xb0
1004069a:	011b      	lsls	r3, r3, #4
1004069c:	0018      	movs	r0, r3
1004069e:	f7ff febb 	bl	10040418 <LL_PWR_SetNoPullA>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
100406a2:	46c0      	nop			@ (mov r8, r8)
100406a4:	46bd      	mov	sp, r7
100406a6:	b006      	add	sp, #24
100406a8:	bd80      	pop	{r7, pc}
100406aa:	46c0      	nop			@ (mov r8, r8)
100406ac:	48100000 	.word	0x48100000

100406b0 <HAL_GPIO_EXTI_Callback>:
  * @brief EXTI line detection callback.
  * @param GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin)
{
100406b0:	b580      	push	{r7, lr}
100406b2:	b082      	sub	sp, #8
100406b4:	af00      	add	r7, sp, #0
100406b6:	6078      	str	r0, [r7, #4]
100406b8:	000a      	movs	r2, r1
100406ba:	1cbb      	adds	r3, r7, #2
100406bc:	801a      	strh	r2, [r3, #0]
  switch(GPIO_Pin)
100406be:	1cbb      	adds	r3, r7, #2
100406c0:	881b      	ldrh	r3, [r3, #0]
100406c2:	2280      	movs	r2, #128	@ 0x80
100406c4:	01d2      	lsls	r2, r2, #7
100406c6:	4293      	cmp	r3, r2
100406c8:	d011      	beq.n	100406ee <HAL_GPIO_EXTI_Callback+0x3e>
100406ca:	2280      	movs	r2, #128	@ 0x80
100406cc:	01d2      	lsls	r2, r2, #7
100406ce:	4293      	cmp	r3, r2
100406d0:	dc12      	bgt.n	100406f8 <HAL_GPIO_EXTI_Callback+0x48>
100406d2:	2b01      	cmp	r3, #1
100406d4:	d002      	beq.n	100406dc <HAL_GPIO_EXTI_Callback+0x2c>
100406d6:	2b20      	cmp	r3, #32
100406d8:	d004      	beq.n	100406e4 <HAL_GPIO_EXTI_Callback+0x34>
    case B3_PIN:
      /* Change the period to 1000 ms */
      delay = 1000;
      break;
    default:
      break;
100406da:	e00d      	b.n	100406f8 <HAL_GPIO_EXTI_Callback+0x48>
      delay = 100;
100406dc:	4b09      	ldr	r3, [pc, #36]	@ (10040704 <HAL_GPIO_EXTI_Callback+0x54>)
100406de:	2264      	movs	r2, #100	@ 0x64
100406e0:	601a      	str	r2, [r3, #0]
      break;
100406e2:	e00a      	b.n	100406fa <HAL_GPIO_EXTI_Callback+0x4a>
      delay = 500;
100406e4:	4b07      	ldr	r3, [pc, #28]	@ (10040704 <HAL_GPIO_EXTI_Callback+0x54>)
100406e6:	22fa      	movs	r2, #250	@ 0xfa
100406e8:	0052      	lsls	r2, r2, #1
100406ea:	601a      	str	r2, [r3, #0]
      break;
100406ec:	e005      	b.n	100406fa <HAL_GPIO_EXTI_Callback+0x4a>
      delay = 1000;
100406ee:	4b05      	ldr	r3, [pc, #20]	@ (10040704 <HAL_GPIO_EXTI_Callback+0x54>)
100406f0:	22fa      	movs	r2, #250	@ 0xfa
100406f2:	0092      	lsls	r2, r2, #2
100406f4:	601a      	str	r2, [r3, #0]
      break;
100406f6:	e000      	b.n	100406fa <HAL_GPIO_EXTI_Callback+0x4a>
      break;
100406f8:	46c0      	nop			@ (mov r8, r8)
  }
}
100406fa:	46c0      	nop			@ (mov r8, r8)
100406fc:	46bd      	mov	sp, r7
100406fe:	b002      	add	sp, #8
10040700:	bd80      	pop	{r7, pc}
10040702:	46c0      	nop			@ (mov r8, r8)
10040704:	200002bc 	.word	0x200002bc

10040708 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
10040708:	b580      	push	{r7, lr}
1004070a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
1004070c:	b672      	cpsid	i
}
1004070e:	46c0      	nop			@ (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
10040710:	46c0      	nop			@ (mov r8, r8)
10040712:	e7fd      	b.n	10040710 <Error_Handler+0x8>

10040714 <LL_APB0_GRP1_EnableClock>:
  * @retval None
  * @note   LL_APB0_GRP1_PERIPH_TIM1 is valid only for STM32WB06 and STM32WB07
  * @note   LL_APB0_GRP1_PERIPH_TIM2, LL_APB0_GRP1_PERIPH_TIM16 and LL_APB0_GRP1_PERIPH_TIM17 are valid for STM32WB05 and STM32WB09
  */
__STATIC_INLINE void LL_APB0_GRP1_EnableClock(uint32_t Periphs)
{
10040714:	b580      	push	{r7, lr}
10040716:	b084      	sub	sp, #16
10040718:	af00      	add	r7, sp, #0
1004071a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB0ENR, Periphs);
1004071c:	4b07      	ldr	r3, [pc, #28]	@ (1004073c <LL_APB0_GRP1_EnableClock+0x28>)
1004071e:	6d59      	ldr	r1, [r3, #84]	@ 0x54
10040720:	4b06      	ldr	r3, [pc, #24]	@ (1004073c <LL_APB0_GRP1_EnableClock+0x28>)
10040722:	687a      	ldr	r2, [r7, #4]
10040724:	430a      	orrs	r2, r1
10040726:	655a      	str	r2, [r3, #84]	@ 0x54
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040728:	4b04      	ldr	r3, [pc, #16]	@ (1004073c <LL_APB0_GRP1_EnableClock+0x28>)
1004072a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
1004072c:	687a      	ldr	r2, [r7, #4]
1004072e:	4013      	ands	r3, r2
10040730:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040732:	68fb      	ldr	r3, [r7, #12]
}
10040734:	46c0      	nop			@ (mov r8, r8)
10040736:	46bd      	mov	sp, r7
10040738:	b004      	add	sp, #16
1004073a:	bd80      	pop	{r7, pc}
1004073c:	48400000 	.word	0x48400000

10040740 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
10040740:	b580      	push	{r7, lr}
10040742:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
10040744:	2380      	movs	r3, #128	@ 0x80
10040746:	005b      	lsls	r3, r3, #1
10040748:	0018      	movs	r0, r3
1004074a:	f7ff ffe3 	bl	10040714 <LL_APB0_GRP1_EnableClock>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
1004074e:	46c0      	nop			@ (mov r8, r8)
10040750:	46bd      	mov	sp, r7
10040752:	bd80      	pop	{r7, pc}

10040754 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
10040754:	b580      	push	{r7, lr}
10040756:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
10040758:	46c0      	nop			@ (mov r8, r8)
1004075a:	e7fd      	b.n	10040758 <NMI_Handler+0x4>

1004075c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
1004075c:	b580      	push	{r7, lr}
1004075e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
10040760:	46c0      	nop			@ (mov r8, r8)
10040762:	e7fd      	b.n	10040760 <HardFault_Handler+0x4>

10040764 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
10040764:	b580      	push	{r7, lr}
10040766:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
10040768:	46c0      	nop			@ (mov r8, r8)
1004076a:	46bd      	mov	sp, r7
1004076c:	bd80      	pop	{r7, pc}

1004076e <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
1004076e:	b580      	push	{r7, lr}
10040770:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
10040772:	46c0      	nop			@ (mov r8, r8)
10040774:	46bd      	mov	sp, r7
10040776:	bd80      	pop	{r7, pc}

10040778 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
10040778:	b580      	push	{r7, lr}
1004077a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
1004077c:	f000 fd7c 	bl	10041278 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
10040780:	46c0      	nop			@ (mov r8, r8)
10040782:	46bd      	mov	sp, r7
10040784:	bd80      	pop	{r7, pc}

10040786 <GPIOA_IRQHandler>:

/**
  * @brief This function handles GPIOA interrupt.
  */
void GPIOA_IRQHandler(void)
{
10040786:	b580      	push	{r7, lr}
10040788:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPIOA_IRQn 0 */

  /* USER CODE END GPIOA_IRQn 0 */
  BSP_PB_IRQHandler(GPIOA,B1_PIN);
1004078a:	2390      	movs	r3, #144	@ 0x90
1004078c:	05db      	lsls	r3, r3, #23
1004078e:	2101      	movs	r1, #1
10040790:	0018      	movs	r0, r3
10040792:	f000 fc2d 	bl	10040ff0 <BSP_PB_IRQHandler>
  /* USER CODE BEGIN GPIOA_IRQn 1 */

  /* USER CODE END GPIOA_IRQn 1 */
}
10040796:	46c0      	nop			@ (mov r8, r8)
10040798:	46bd      	mov	sp, r7
1004079a:	bd80      	pop	{r7, pc}

1004079c <GPIOB_IRQHandler>:

/**
  * @brief This function handles GPIOB interrupt.
  */
void GPIOB_IRQHandler(void)
{
1004079c:	b580      	push	{r7, lr}
1004079e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GPIOB_IRQn 0 */

  /* USER CODE END GPIOB_IRQn 0 */
  BSP_PB_IRQHandler(GPIOB,B3_PIN);
100407a0:	2380      	movs	r3, #128	@ 0x80
100407a2:	01db      	lsls	r3, r3, #7
100407a4:	4a06      	ldr	r2, [pc, #24]	@ (100407c0 <GPIOB_IRQHandler+0x24>)
100407a6:	0019      	movs	r1, r3
100407a8:	0010      	movs	r0, r2
100407aa:	f000 fc21 	bl	10040ff0 <BSP_PB_IRQHandler>
  BSP_PB_IRQHandler(GPIOB,B2_PIN);
100407ae:	4b04      	ldr	r3, [pc, #16]	@ (100407c0 <GPIOB_IRQHandler+0x24>)
100407b0:	2120      	movs	r1, #32
100407b2:	0018      	movs	r0, r3
100407b4:	f000 fc1c 	bl	10040ff0 <BSP_PB_IRQHandler>
  /* USER CODE BEGIN GPIOB_IRQn 1 */

  /* USER CODE END GPIOB_IRQn 1 */
}
100407b8:	46c0      	nop			@ (mov r8, r8)
100407ba:	46bd      	mov	sp, r7
100407bc:	bd80      	pop	{r7, pc}
100407be:	46c0      	nop			@ (mov r8, r8)
100407c0:	48100000 	.word	0x48100000

100407c4 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
100407c4:	b580      	push	{r7, lr}
100407c6:	b086      	sub	sp, #24
100407c8:	af00      	add	r7, sp, #0
100407ca:	60f8      	str	r0, [r7, #12]
100407cc:	60b9      	str	r1, [r7, #8]
100407ce:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
100407d0:	2300      	movs	r3, #0
100407d2:	617b      	str	r3, [r7, #20]
100407d4:	e00a      	b.n	100407ec <_read+0x28>
  {
    *ptr++ = __io_getchar();
100407d6:	e000      	b.n	100407da <_read+0x16>
100407d8:	bf00      	nop
100407da:	0001      	movs	r1, r0
100407dc:	68bb      	ldr	r3, [r7, #8]
100407de:	1c5a      	adds	r2, r3, #1
100407e0:	60ba      	str	r2, [r7, #8]
100407e2:	b2ca      	uxtb	r2, r1
100407e4:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
100407e6:	697b      	ldr	r3, [r7, #20]
100407e8:	3301      	adds	r3, #1
100407ea:	617b      	str	r3, [r7, #20]
100407ec:	697a      	ldr	r2, [r7, #20]
100407ee:	687b      	ldr	r3, [r7, #4]
100407f0:	429a      	cmp	r2, r3
100407f2:	dbf0      	blt.n	100407d6 <_read+0x12>
  }

  return len;
100407f4:	687b      	ldr	r3, [r7, #4]
}
100407f6:	0018      	movs	r0, r3
100407f8:	46bd      	mov	sp, r7
100407fa:	b006      	add	sp, #24
100407fc:	bd80      	pop	{r7, pc}

100407fe <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
100407fe:	b580      	push	{r7, lr}
10040800:	b086      	sub	sp, #24
10040802:	af00      	add	r7, sp, #0
10040804:	60f8      	str	r0, [r7, #12]
10040806:	60b9      	str	r1, [r7, #8]
10040808:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
1004080a:	2300      	movs	r3, #0
1004080c:	617b      	str	r3, [r7, #20]
1004080e:	e009      	b.n	10040824 <_write+0x26>
  {
    __io_putchar(*ptr++);
10040810:	68bb      	ldr	r3, [r7, #8]
10040812:	1c5a      	adds	r2, r3, #1
10040814:	60ba      	str	r2, [r7, #8]
10040816:	781b      	ldrb	r3, [r3, #0]
10040818:	0018      	movs	r0, r3
1004081a:	f000 fc3b 	bl	10041094 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
1004081e:	697b      	ldr	r3, [r7, #20]
10040820:	3301      	adds	r3, #1
10040822:	617b      	str	r3, [r7, #20]
10040824:	697a      	ldr	r2, [r7, #20]
10040826:	687b      	ldr	r3, [r7, #4]
10040828:	429a      	cmp	r2, r3
1004082a:	dbf1      	blt.n	10040810 <_write+0x12>
  }
  return len;
1004082c:	687b      	ldr	r3, [r7, #4]
}
1004082e:	0018      	movs	r0, r3
10040830:	46bd      	mov	sp, r7
10040832:	b006      	add	sp, #24
10040834:	bd80      	pop	{r7, pc}

10040836 <_close>:

int _close(int file)
{
10040836:	b580      	push	{r7, lr}
10040838:	b082      	sub	sp, #8
1004083a:	af00      	add	r7, sp, #0
1004083c:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
1004083e:	2301      	movs	r3, #1
10040840:	425b      	negs	r3, r3
}
10040842:	0018      	movs	r0, r3
10040844:	46bd      	mov	sp, r7
10040846:	b002      	add	sp, #8
10040848:	bd80      	pop	{r7, pc}

1004084a <_fstat>:


int _fstat(int file, struct stat *st)
{
1004084a:	b580      	push	{r7, lr}
1004084c:	b082      	sub	sp, #8
1004084e:	af00      	add	r7, sp, #0
10040850:	6078      	str	r0, [r7, #4]
10040852:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
10040854:	683b      	ldr	r3, [r7, #0]
10040856:	2280      	movs	r2, #128	@ 0x80
10040858:	0192      	lsls	r2, r2, #6
1004085a:	605a      	str	r2, [r3, #4]
  return 0;
1004085c:	2300      	movs	r3, #0
}
1004085e:	0018      	movs	r0, r3
10040860:	46bd      	mov	sp, r7
10040862:	b002      	add	sp, #8
10040864:	bd80      	pop	{r7, pc}

10040866 <_isatty>:

int _isatty(int file)
{
10040866:	b580      	push	{r7, lr}
10040868:	b082      	sub	sp, #8
1004086a:	af00      	add	r7, sp, #0
1004086c:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
1004086e:	2301      	movs	r3, #1
}
10040870:	0018      	movs	r0, r3
10040872:	46bd      	mov	sp, r7
10040874:	b002      	add	sp, #8
10040876:	bd80      	pop	{r7, pc}

10040878 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
10040878:	b580      	push	{r7, lr}
1004087a:	b084      	sub	sp, #16
1004087c:	af00      	add	r7, sp, #0
1004087e:	60f8      	str	r0, [r7, #12]
10040880:	60b9      	str	r1, [r7, #8]
10040882:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
10040884:	2300      	movs	r3, #0
}
10040886:	0018      	movs	r0, r3
10040888:	46bd      	mov	sp, r7
1004088a:	b004      	add	sp, #16
1004088c:	bd80      	pop	{r7, pc}
	...

10040890 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
10040890:	b580      	push	{r7, lr}
10040892:	b086      	sub	sp, #24
10040894:	af00      	add	r7, sp, #0
10040896:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
10040898:	4a14      	ldr	r2, [pc, #80]	@ (100408ec <_sbrk+0x5c>)
1004089a:	4b15      	ldr	r3, [pc, #84]	@ (100408f0 <_sbrk+0x60>)
1004089c:	1ad3      	subs	r3, r2, r3
1004089e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
100408a0:	697b      	ldr	r3, [r7, #20]
100408a2:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
100408a4:	4b13      	ldr	r3, [pc, #76]	@ (100408f4 <_sbrk+0x64>)
100408a6:	681b      	ldr	r3, [r3, #0]
100408a8:	2b00      	cmp	r3, #0
100408aa:	d102      	bne.n	100408b2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
100408ac:	4b11      	ldr	r3, [pc, #68]	@ (100408f4 <_sbrk+0x64>)
100408ae:	4a12      	ldr	r2, [pc, #72]	@ (100408f8 <_sbrk+0x68>)
100408b0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
100408b2:	4b10      	ldr	r3, [pc, #64]	@ (100408f4 <_sbrk+0x64>)
100408b4:	681a      	ldr	r2, [r3, #0]
100408b6:	687b      	ldr	r3, [r7, #4]
100408b8:	18d3      	adds	r3, r2, r3
100408ba:	693a      	ldr	r2, [r7, #16]
100408bc:	429a      	cmp	r2, r3
100408be:	d207      	bcs.n	100408d0 <_sbrk+0x40>
  {
    errno = ENOMEM;
100408c0:	f002 fa4c 	bl	10042d5c <__errno>
100408c4:	0003      	movs	r3, r0
100408c6:	220c      	movs	r2, #12
100408c8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
100408ca:	2301      	movs	r3, #1
100408cc:	425b      	negs	r3, r3
100408ce:	e009      	b.n	100408e4 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
100408d0:	4b08      	ldr	r3, [pc, #32]	@ (100408f4 <_sbrk+0x64>)
100408d2:	681b      	ldr	r3, [r3, #0]
100408d4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
100408d6:	4b07      	ldr	r3, [pc, #28]	@ (100408f4 <_sbrk+0x64>)
100408d8:	681a      	ldr	r2, [r3, #0]
100408da:	687b      	ldr	r3, [r7, #4]
100408dc:	18d2      	adds	r2, r2, r3
100408de:	4b05      	ldr	r3, [pc, #20]	@ (100408f4 <_sbrk+0x64>)
100408e0:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
100408e2:	68fb      	ldr	r3, [r7, #12]
}
100408e4:	0018      	movs	r0, r3
100408e6:	46bd      	mov	sp, r7
100408e8:	b006      	add	sp, #24
100408ea:	bd80      	pop	{r7, pc}
100408ec:	20006000 	.word	0x20006000
100408f0:	00000c00 	.word	0x00000c00
100408f4:	200000d0 	.word	0x200000d0
100408f8:	20000358 	.word	0x20000358

100408fc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
100408fc:	b590      	push	{r4, r7, lr}
100408fe:	b083      	sub	sp, #12
10040900:	af00      	add	r7, sp, #0
10040902:	0002      	movs	r2, r0
10040904:	6039      	str	r1, [r7, #0]
10040906:	1dfb      	adds	r3, r7, #7
10040908:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
1004090a:	1dfb      	adds	r3, r7, #7
1004090c:	781b      	ldrb	r3, [r3, #0]
1004090e:	2b7f      	cmp	r3, #127	@ 0x7f
10040910:	d828      	bhi.n	10040964 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040912:	4a2f      	ldr	r2, [pc, #188]	@ (100409d0 <__NVIC_SetPriority+0xd4>)
10040914:	1dfb      	adds	r3, r7, #7
10040916:	781b      	ldrb	r3, [r3, #0]
10040918:	b25b      	sxtb	r3, r3
1004091a:	089b      	lsrs	r3, r3, #2
1004091c:	33c0      	adds	r3, #192	@ 0xc0
1004091e:	009b      	lsls	r3, r3, #2
10040920:	589b      	ldr	r3, [r3, r2]
10040922:	1dfa      	adds	r2, r7, #7
10040924:	7812      	ldrb	r2, [r2, #0]
10040926:	0011      	movs	r1, r2
10040928:	2203      	movs	r2, #3
1004092a:	400a      	ands	r2, r1
1004092c:	00d2      	lsls	r2, r2, #3
1004092e:	21ff      	movs	r1, #255	@ 0xff
10040930:	4091      	lsls	r1, r2
10040932:	000a      	movs	r2, r1
10040934:	43d2      	mvns	r2, r2
10040936:	401a      	ands	r2, r3
10040938:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1004093a:	683b      	ldr	r3, [r7, #0]
1004093c:	019b      	lsls	r3, r3, #6
1004093e:	22ff      	movs	r2, #255	@ 0xff
10040940:	401a      	ands	r2, r3
10040942:	1dfb      	adds	r3, r7, #7
10040944:	781b      	ldrb	r3, [r3, #0]
10040946:	0018      	movs	r0, r3
10040948:	2303      	movs	r3, #3
1004094a:	4003      	ands	r3, r0
1004094c:	00db      	lsls	r3, r3, #3
1004094e:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040950:	481f      	ldr	r0, [pc, #124]	@ (100409d0 <__NVIC_SetPriority+0xd4>)
10040952:	1dfb      	adds	r3, r7, #7
10040954:	781b      	ldrb	r3, [r3, #0]
10040956:	b25b      	sxtb	r3, r3
10040958:	089b      	lsrs	r3, r3, #2
1004095a:	430a      	orrs	r2, r1
1004095c:	33c0      	adds	r3, #192	@ 0xc0
1004095e:	009b      	lsls	r3, r3, #2
10040960:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10040962:	e031      	b.n	100409c8 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040964:	4a1b      	ldr	r2, [pc, #108]	@ (100409d4 <__NVIC_SetPriority+0xd8>)
10040966:	1dfb      	adds	r3, r7, #7
10040968:	781b      	ldrb	r3, [r3, #0]
1004096a:	0019      	movs	r1, r3
1004096c:	230f      	movs	r3, #15
1004096e:	400b      	ands	r3, r1
10040970:	3b08      	subs	r3, #8
10040972:	089b      	lsrs	r3, r3, #2
10040974:	3306      	adds	r3, #6
10040976:	009b      	lsls	r3, r3, #2
10040978:	18d3      	adds	r3, r2, r3
1004097a:	3304      	adds	r3, #4
1004097c:	681b      	ldr	r3, [r3, #0]
1004097e:	1dfa      	adds	r2, r7, #7
10040980:	7812      	ldrb	r2, [r2, #0]
10040982:	0011      	movs	r1, r2
10040984:	2203      	movs	r2, #3
10040986:	400a      	ands	r2, r1
10040988:	00d2      	lsls	r2, r2, #3
1004098a:	21ff      	movs	r1, #255	@ 0xff
1004098c:	4091      	lsls	r1, r2
1004098e:	000a      	movs	r2, r1
10040990:	43d2      	mvns	r2, r2
10040992:	401a      	ands	r2, r3
10040994:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10040996:	683b      	ldr	r3, [r7, #0]
10040998:	019b      	lsls	r3, r3, #6
1004099a:	22ff      	movs	r2, #255	@ 0xff
1004099c:	401a      	ands	r2, r3
1004099e:	1dfb      	adds	r3, r7, #7
100409a0:	781b      	ldrb	r3, [r3, #0]
100409a2:	0018      	movs	r0, r3
100409a4:	2303      	movs	r3, #3
100409a6:	4003      	ands	r3, r0
100409a8:	00db      	lsls	r3, r3, #3
100409aa:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100409ac:	4809      	ldr	r0, [pc, #36]	@ (100409d4 <__NVIC_SetPriority+0xd8>)
100409ae:	1dfb      	adds	r3, r7, #7
100409b0:	781b      	ldrb	r3, [r3, #0]
100409b2:	001c      	movs	r4, r3
100409b4:	230f      	movs	r3, #15
100409b6:	4023      	ands	r3, r4
100409b8:	3b08      	subs	r3, #8
100409ba:	089b      	lsrs	r3, r3, #2
100409bc:	430a      	orrs	r2, r1
100409be:	3306      	adds	r3, #6
100409c0:	009b      	lsls	r3, r3, #2
100409c2:	18c3      	adds	r3, r0, r3
100409c4:	3304      	adds	r3, #4
100409c6:	601a      	str	r2, [r3, #0]
}
100409c8:	46c0      	nop			@ (mov r8, r8)
100409ca:	46bd      	mov	sp, r7
100409cc:	b003      	add	sp, #12
100409ce:	bd90      	pop	{r4, r7, pc}
100409d0:	e000e100 	.word	0xe000e100
100409d4:	e000ed00 	.word	0xe000ed00

100409d8 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
100409d8:	b580      	push	{r7, lr}
100409da:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
100409dc:	f3bf 8f4f 	dsb	sy
}
100409e0:	46c0      	nop			@ (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
100409e2:	4b04      	ldr	r3, [pc, #16]	@ (100409f4 <__NVIC_SystemReset+0x1c>)
100409e4:	4a04      	ldr	r2, [pc, #16]	@ (100409f8 <__NVIC_SystemReset+0x20>)
100409e6:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
100409e8:	f3bf 8f4f 	dsb	sy
}
100409ec:	46c0      	nop			@ (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
100409ee:	46c0      	nop			@ (mov r8, r8)
100409f0:	e7fd      	b.n	100409ee <__NVIC_SystemReset+0x16>
100409f2:	46c0      	nop			@ (mov r8, r8)
100409f4:	e000ed00 	.word	0xe000ed00
100409f8:	05fa0004 	.word	0x05fa0004

100409fc <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
100409fc:	b590      	push	{r4, r7, lr}
100409fe:	b087      	sub	sp, #28
10040a00:	af00      	add	r7, sp, #0
  uint32_t lsiBw;
#endif
  uint8_t i;
  
  /* If the reset reason is a wakeup from power save restore the context */
  if ((RCC->CSR == 0) && ((PWR->SR1 != 0)||(PWR->SR3 != 0))) {
10040a02:	4a5e      	ldr	r2, [pc, #376]	@ (10040b7c <SystemInit+0x180>)
10040a04:	2394      	movs	r3, #148	@ 0x94
10040a06:	58d3      	ldr	r3, [r2, r3]
10040a08:	2b00      	cmp	r3, #0
10040a0a:	d10e      	bne.n	10040a2a <SystemInit+0x2e>
10040a0c:	4b5c      	ldr	r3, [pc, #368]	@ (10040b80 <SystemInit+0x184>)
10040a0e:	691b      	ldr	r3, [r3, #16]
10040a10:	2b00      	cmp	r3, #0
10040a12:	d103      	bne.n	10040a1c <SystemInit+0x20>
10040a14:	4b5a      	ldr	r3, [pc, #360]	@ (10040b80 <SystemInit+0x184>)
10040a16:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
10040a18:	2b00      	cmp	r3, #0
10040a1a:	d006      	beq.n	10040a2a <SystemInit+0x2e>
    RAM_VR.WakeupFromSleepFlag = 1; /* A wakeup from power save occurred */
10040a1c:	4b59      	ldr	r3, [pc, #356]	@ (10040b84 <SystemInit+0x188>)
10040a1e:	2201      	movs	r2, #1
10040a20:	609a      	str	r2, [r3, #8]
    CPUcontextRestore();            /* Restore the context */
10040a22:	f000 f8f5 	bl	10040c10 <CPUcontextRestore>
    /* if the context restore worked properly, we should never return here */
    while(1) { 
      NVIC_SystemReset(); 
10040a26:	f7ff ffd7 	bl	100409d8 <__NVIC_SystemReset>

  /* Configure the Vector Table location */
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation */
#else
  SCB->VTOR = (uint32_t) (__vector_table);
10040a2a:	4b57      	ldr	r3, [pc, #348]	@ (10040b88 <SystemInit+0x18c>)
10040a2c:	4a57      	ldr	r2, [pc, #348]	@ (10040b8c <SystemInit+0x190>)
10040a2e:	609a      	str	r2, [r3, #8]
#endif /* USER_VECT_TAB_ADDRESS */

  /* Store in RAM the AppBase information */
  RAM_VR.AppBase = (uint32_t) SCB->VTOR;
10040a30:	4b55      	ldr	r3, [pc, #340]	@ (10040b88 <SystemInit+0x18c>)
10040a32:	689a      	ldr	r2, [r3, #8]
10040a34:	4b53      	ldr	r3, [pc, #332]	@ (10040b84 <SystemInit+0x188>)
10040a36:	611a      	str	r2, [r3, #16]

  /* Enable all the RAM banks in retention during power save */
#if defined(PWR_CR2_RAMRET1)
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET1);
10040a38:	4b51      	ldr	r3, [pc, #324]	@ (10040b80 <SystemInit+0x184>)
10040a3a:	685a      	ldr	r2, [r3, #4]
10040a3c:	4b50      	ldr	r3, [pc, #320]	@ (10040b80 <SystemInit+0x184>)
10040a3e:	2120      	movs	r1, #32
10040a40:	430a      	orrs	r2, r1
10040a42:	605a      	str	r2, [r3, #4]
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET3);
#endif /* PWR_CR2_RAMRET3 */

  /* Disable the GPIO retention in power save configuration */
#if defined(PWR_CR2_GPIORET)
  CLEAR_BIT(PWR->CR2, PWR_CR2_GPIORET);
10040a44:	4b4e      	ldr	r3, [pc, #312]	@ (10040b80 <SystemInit+0x184>)
10040a46:	685a      	ldr	r2, [r3, #4]
10040a48:	4b4d      	ldr	r3, [pc, #308]	@ (10040b80 <SystemInit+0x184>)
10040a4a:	4951      	ldr	r1, [pc, #324]	@ (10040b90 <SystemInit+0x194>)
10040a4c:	400a      	ands	r2, r1
10040a4e:	605a      	str	r2, [r3, #4]
#endif /* PWR_CR2_GPIORET */
   
  /* SMPS setup */
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_BYPAPSS))
  {
    while(READ_BIT(PWR->SR2, PWR_SR2_SMPSRDY) != PWR_SR2_SMPSRDY); // Wait until SMPS is ready
10040a50:	46c0      	nop			@ (mov r8, r8)
10040a52:	4b4b      	ldr	r3, [pc, #300]	@ (10040b80 <SystemInit+0x184>)
10040a54:	695b      	ldr	r3, [r3, #20]
10040a56:	2204      	movs	r2, #4
10040a58:	4013      	ands	r3, r2
10040a5a:	2b04      	cmp	r3, #4
10040a5c:	d1f9      	bne.n	10040a52 <SystemInit+0x56>
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSBOMSEL, (CFG_HW_SMPS_BOM<<PWR_CR5_SMPSBOMSEL_Pos)); // Configure the SMPS BOM
10040a5e:	4b48      	ldr	r3, [pc, #288]	@ (10040b80 <SystemInit+0x184>)
10040a60:	69db      	ldr	r3, [r3, #28]
10040a62:	2230      	movs	r2, #48	@ 0x30
10040a64:	4393      	bics	r3, r2
10040a66:	001a      	movs	r2, r3
10040a68:	4b45      	ldr	r3, [pc, #276]	@ (10040b80 <SystemInit+0x184>)
10040a6a:	2120      	movs	r1, #32
10040a6c:	430a      	orrs	r2, r1
10040a6e:	61da      	str	r2, [r3, #28]
  }
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_OFF))
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_NOSMPS, (CFG_HW_SMPS<<PWR_CR5_NOSMPS_Pos)); // SMPS ON/OFF Configuration
10040a70:	4b43      	ldr	r3, [pc, #268]	@ (10040b80 <SystemInit+0x184>)
10040a72:	69da      	ldr	r2, [r3, #28]
10040a74:	4b42      	ldr	r3, [pc, #264]	@ (10040b80 <SystemInit+0x184>)
10040a76:	4947      	ldr	r1, [pc, #284]	@ (10040b94 <SystemInit+0x198>)
10040a78:	400a      	ands	r2, r1
10040a7a:	61da      	str	r2, [r3, #28]
  }
  else
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSFBYP, (1<<PWR_CR5_SMPSFBYP_Pos)); // SMPS BYPASS Configuration
  }
  MODIFY_REG(PWR->CR5, PWR_CR5_SMPSLPOPEN, (CFG_HW_SMPS_LOW_POWER<<PWR_CR5_SMPSLPOPEN_Pos)); // SMPS configuration during power save
10040a7c:	4b40      	ldr	r3, [pc, #256]	@ (10040b80 <SystemInit+0x184>)
10040a7e:	69da      	ldr	r2, [r3, #28]
10040a80:	4b3f      	ldr	r3, [pc, #252]	@ (10040b80 <SystemInit+0x184>)
10040a82:	2180      	movs	r1, #128	@ 0x80
10040a84:	0049      	lsls	r1, r1, #1
10040a86:	430a      	orrs	r2, r1
10040a88:	61da      	str	r2, [r3, #28]
  
  /* If Trimming values from engineering in flash locations are not present load default values */
  if (*(volatile uint32_t*)VALIDITY_LOCATION != VALIDITY_TAG)
10040a8a:	4b43      	ldr	r3, [pc, #268]	@ (10040b98 <SystemInit+0x19c>)
10040a8c:	681b      	ldr	r3, [r3, #0]
10040a8e:	4a43      	ldr	r2, [pc, #268]	@ (10040b9c <SystemInit+0x1a0>)
10040a90:	4293      	cmp	r3, r2
10040a92:	d055      	beq.n	10040b40 <SystemInit+0x144>

    /* Set Low Speed Internal oscillator LPMU trimming value. */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_LSI_LPMU, ((lsiLpmu << PWR_ENGTRIM_TRIM_LSI_LPMU_Pos) & PWR_ENGTRIM_TRIM_LSI_LPMU));
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMLSILPMUEN);
#else
    hsiCalib       = 0x1F;
10040a94:	231f      	movs	r3, #31
10040a96:	613b      	str	r3, [r7, #16]
    lsiBw          = 8;
10040a98:	2308      	movs	r3, #8
10040a9a:	60fb      	str	r3, [r7, #12]
    mainRegulator  = 0x0A;
10040a9c:	230a      	movs	r3, #10
10040a9e:	60bb      	str	r3, [r7, #8]
    smpsOutVoltage = 0x03;
10040aa0:	2303      	movs	r3, #3
10040aa2:	607b      	str	r3, [r7, #4]

    /* Low speed internal RC trimming value set by software */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSISWBW, lsiBw << RCC_CSSWCR_LSISWBW_Pos);
10040aa4:	4b35      	ldr	r3, [pc, #212]	@ (10040b7c <SystemInit+0x180>)
10040aa6:	68db      	ldr	r3, [r3, #12]
10040aa8:	221e      	movs	r2, #30
10040aaa:	4393      	bics	r3, r2
10040aac:	0019      	movs	r1, r3
10040aae:	68fb      	ldr	r3, [r7, #12]
10040ab0:	005a      	lsls	r2, r3, #1
10040ab2:	4b32      	ldr	r3, [pc, #200]	@ (10040b7c <SystemInit+0x180>)
10040ab4:	430a      	orrs	r2, r1
10040ab6:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_LSISWTRIMEN);
10040ab8:	4b30      	ldr	r3, [pc, #192]	@ (10040b7c <SystemInit+0x180>)
10040aba:	68da      	ldr	r2, [r3, #12]
10040abc:	4b2f      	ldr	r3, [pc, #188]	@ (10040b7c <SystemInit+0x180>)
10040abe:	2101      	movs	r1, #1
10040ac0:	430a      	orrs	r2, r1
10040ac2:	60da      	str	r2, [r3, #12]
#endif
    
    /* Set HSI Calibration Trimming value */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_HSITRIMSW, hsiCalib << RCC_CSSWCR_HSITRIMSW_Pos);
10040ac4:	4b2d      	ldr	r3, [pc, #180]	@ (10040b7c <SystemInit+0x180>)
10040ac6:	68db      	ldr	r3, [r3, #12]
10040ac8:	4a35      	ldr	r2, [pc, #212]	@ (10040ba0 <SystemInit+0x1a4>)
10040aca:	4013      	ands	r3, r2
10040acc:	0019      	movs	r1, r3
10040ace:	693b      	ldr	r3, [r7, #16]
10040ad0:	061a      	lsls	r2, r3, #24
10040ad2:	4b2a      	ldr	r3, [pc, #168]	@ (10040b7c <SystemInit+0x180>)
10040ad4:	430a      	orrs	r2, r1
10040ad6:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_HSISWTRIMEN);
10040ad8:	4b28      	ldr	r3, [pc, #160]	@ (10040b7c <SystemInit+0x180>)
10040ada:	68da      	ldr	r2, [r3, #12]
10040adc:	4b27      	ldr	r3, [pc, #156]	@ (10040b7c <SystemInit+0x180>)
10040ade:	2180      	movs	r1, #128	@ 0x80
10040ae0:	0409      	lsls	r1, r1, #16
10040ae2:	430a      	orrs	r2, r1
10040ae4:	60da      	str	r2, [r3, #12]
              
    /* Set Main Regulator voltage Trimming value */ 
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_MR, ((mainRegulator << PWR_ENGTRIM_TRIM_MR_Pos) & PWR_ENGTRIM_TRIM_MR));
10040ae6:	4a26      	ldr	r2, [pc, #152]	@ (10040b80 <SystemInit+0x184>)
10040ae8:	2394      	movs	r3, #148	@ 0x94
10040aea:	58d3      	ldr	r3, [r2, r3]
10040aec:	4a2d      	ldr	r2, [pc, #180]	@ (10040ba4 <SystemInit+0x1a8>)
10040aee:	401a      	ands	r2, r3
10040af0:	68bb      	ldr	r3, [r7, #8]
10040af2:	0199      	lsls	r1, r3, #6
10040af4:	23f0      	movs	r3, #240	@ 0xf0
10040af6:	009b      	lsls	r3, r3, #2
10040af8:	400b      	ands	r3, r1
10040afa:	4921      	ldr	r1, [pc, #132]	@ (10040b80 <SystemInit+0x184>)
10040afc:	4313      	orrs	r3, r2
10040afe:	2294      	movs	r2, #148	@ 0x94
10040b00:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMMREN);
10040b02:	4a1f      	ldr	r2, [pc, #124]	@ (10040b80 <SystemInit+0x184>)
10040b04:	2394      	movs	r3, #148	@ 0x94
10040b06:	58d3      	ldr	r3, [r2, r3]
10040b08:	491d      	ldr	r1, [pc, #116]	@ (10040b80 <SystemInit+0x184>)
10040b0a:	2220      	movs	r2, #32
10040b0c:	4313      	orrs	r3, r2
10040b0e:	2294      	movs	r2, #148	@ 0x94
10040b10:	508b      	str	r3, [r1, r2]

    /* Set SMPS output voltage Trimming value */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_SMPS_TRIM, ((smpsOutVoltage << PWR_ENGTRIM_SMPS_TRIM_Pos) & PWR_ENGTRIM_SMPS_TRIM));
10040b12:	4a1b      	ldr	r2, [pc, #108]	@ (10040b80 <SystemInit+0x184>)
10040b14:	2394      	movs	r3, #148	@ 0x94
10040b16:	58d3      	ldr	r3, [r2, r3]
10040b18:	4a23      	ldr	r2, [pc, #140]	@ (10040ba8 <SystemInit+0x1ac>)
10040b1a:	401a      	ands	r2, r3
10040b1c:	687b      	ldr	r3, [r7, #4]
10040b1e:	02d9      	lsls	r1, r3, #11
10040b20:	23e0      	movs	r3, #224	@ 0xe0
10040b22:	019b      	lsls	r3, r3, #6
10040b24:	400b      	ands	r3, r1
10040b26:	4916      	ldr	r1, [pc, #88]	@ (10040b80 <SystemInit+0x184>)
10040b28:	4313      	orrs	r3, r2
10040b2a:	2294      	movs	r2, #148	@ 0x94
10040b2c:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_SMPSTRIMEN);    
10040b2e:	4a14      	ldr	r2, [pc, #80]	@ (10040b80 <SystemInit+0x184>)
10040b30:	2394      	movs	r3, #148	@ 0x94
10040b32:	58d3      	ldr	r3, [r2, r3]
10040b34:	4912      	ldr	r1, [pc, #72]	@ (10040b80 <SystemInit+0x184>)
10040b36:	2280      	movs	r2, #128	@ 0x80
10040b38:	00d2      	lsls	r2, r2, #3
10040b3a:	4313      	orrs	r3, r2
10040b3c:	2294      	movs	r2, #148	@ 0x94
10040b3e:	508b      	str	r3, [r1, r2]
  }

  /* Set all the interrupt with low priprity */
  for (i=0; i<32; i++)
10040b40:	2317      	movs	r3, #23
10040b42:	18fb      	adds	r3, r7, r3
10040b44:	2200      	movs	r2, #0
10040b46:	701a      	strb	r2, [r3, #0]
10040b48:	e00d      	b.n	10040b66 <SystemInit+0x16a>
  {
    NVIC_SetPriority((IRQn_Type)i, IRQ_LOW_PRIORITY);
10040b4a:	2417      	movs	r4, #23
10040b4c:	193b      	adds	r3, r7, r4
10040b4e:	781b      	ldrb	r3, [r3, #0]
10040b50:	b25b      	sxtb	r3, r3
10040b52:	2103      	movs	r1, #3
10040b54:	0018      	movs	r0, r3
10040b56:	f7ff fed1 	bl	100408fc <__NVIC_SetPriority>
  for (i=0; i<32; i++)
10040b5a:	0021      	movs	r1, r4
10040b5c:	187b      	adds	r3, r7, r1
10040b5e:	781a      	ldrb	r2, [r3, #0]
10040b60:	187b      	adds	r3, r7, r1
10040b62:	3201      	adds	r2, #1
10040b64:	701a      	strb	r2, [r3, #0]
10040b66:	2317      	movs	r3, #23
10040b68:	18fb      	adds	r3, r7, r3
10040b6a:	781b      	ldrb	r3, [r3, #0]
10040b6c:	2b1f      	cmp	r3, #31
10040b6e:	d9ec      	bls.n	10040b4a <SystemInit+0x14e>
  __ASM volatile ("cpsie i" : : : "memory");
10040b70:	b662      	cpsie	i
}
10040b72:	46c0      	nop			@ (mov r8, r8)
  }
  
  /* Enable all the irqs */
  __enable_irq();
}
10040b74:	46c0      	nop			@ (mov r8, r8)
10040b76:	46bd      	mov	sp, r7
10040b78:	b007      	add	sp, #28
10040b7a:	bd90      	pop	{r4, r7, pc}
10040b7c:	48400000 	.word	0x48400000
10040b80:	48500000 	.word	0x48500000
10040b84:	20000004 	.word	0x20000004
10040b88:	e000ed00 	.word	0xe000ed00
10040b8c:	10040000 	.word	0x10040000
10040b90:	fffffeff 	.word	0xfffffeff
10040b94:	fffffbff 	.word	0xfffffbff
10040b98:	10001ef8 	.word	0x10001ef8
10040b9c:	fcbceccc 	.word	0xfcbceccc
10040ba0:	c0ffffff 	.word	0xc0ffffff
10040ba4:	fffffc3f 	.word	0xfffffc3f
10040ba8:	ffffc7ff 	.word	0xffffc7ff

10040bac <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10040bac:	b580      	push	{r7, lr}
10040bae:	b082      	sub	sp, #8
10040bb0:	af00      	add	r7, sp, #0
  uint8_t directHSE_enabled;
  uint8_t divPrescaler;

  /* Get SYSCLK source HSE or HSI+PLL64MHz */
  directHSE_enabled = (RCC->CFGR & RCC_CFGR_HSESEL) >> RCC_CFGR_HSESEL_Pos;
10040bb2:	4b13      	ldr	r3, [pc, #76]	@ (10040c00 <SystemCoreClockUpdate+0x54>)
10040bb4:	689b      	ldr	r3, [r3, #8]
10040bb6:	085b      	lsrs	r3, r3, #1
10040bb8:	b2da      	uxtb	r2, r3
10040bba:	1dfb      	adds	r3, r7, #7
10040bbc:	2101      	movs	r1, #1
10040bbe:	400a      	ands	r2, r1
10040bc0:	701a      	strb	r2, [r3, #0]
#if defined(STM32WB06) || defined(STM32WB07)
  /* Get the clock divider */
    divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV) >> RCC_CFGR_CLKSYSDIV_Pos;
#else
  /* Get the clock divider */
  divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV_STATUS) >> RCC_CFGR_CLKSYSDIV_STATUS_Pos;
10040bc2:	4b0f      	ldr	r3, [pc, #60]	@ (10040c00 <SystemCoreClockUpdate+0x54>)
10040bc4:	689b      	ldr	r3, [r3, #8]
10040bc6:	0a1b      	lsrs	r3, r3, #8
10040bc8:	b2da      	uxtb	r2, r3
10040bca:	1dbb      	adds	r3, r7, #6
10040bcc:	2107      	movs	r1, #7
10040bce:	400a      	ands	r2, r1
10040bd0:	701a      	strb	r2, [r3, #0]
#endif

  if (directHSE_enabled)
10040bd2:	1dfb      	adds	r3, r7, #7
10040bd4:	781b      	ldrb	r3, [r3, #0]
10040bd6:	2b00      	cmp	r3, #0
10040bd8:	d007      	beq.n	10040bea <SystemCoreClockUpdate+0x3e>
  {
    SystemCoreClock = HSE_VALUE >> (divPrescaler - 1U);
10040bda:	1dbb      	adds	r3, r7, #6
10040bdc:	781b      	ldrb	r3, [r3, #0]
10040bde:	3b01      	subs	r3, #1
10040be0:	4a08      	ldr	r2, [pc, #32]	@ (10040c04 <SystemCoreClockUpdate+0x58>)
10040be2:	40da      	lsrs	r2, r3
10040be4:	4b08      	ldr	r3, [pc, #32]	@ (10040c08 <SystemCoreClockUpdate+0x5c>)
10040be6:	601a      	str	r2, [r3, #0]
  }
  else
  {
    SystemCoreClock = HSI_VALUE >> divPrescaler;
  }  
}
10040be8:	e005      	b.n	10040bf6 <SystemCoreClockUpdate+0x4a>
    SystemCoreClock = HSI_VALUE >> divPrescaler;
10040bea:	1dbb      	adds	r3, r7, #6
10040bec:	781b      	ldrb	r3, [r3, #0]
10040bee:	4a07      	ldr	r2, [pc, #28]	@ (10040c0c <SystemCoreClockUpdate+0x60>)
10040bf0:	40da      	lsrs	r2, r3
10040bf2:	4b05      	ldr	r3, [pc, #20]	@ (10040c08 <SystemCoreClockUpdate+0x5c>)
10040bf4:	601a      	str	r2, [r3, #0]
}
10040bf6:	46c0      	nop			@ (mov r8, r8)
10040bf8:	46bd      	mov	sp, r7
10040bfa:	b002      	add	sp, #8
10040bfc:	bd80      	pop	{r7, pc}
10040bfe:	46c0      	nop			@ (mov r8, r8)
10040c00:	48400000 	.word	0x48400000
10040c04:	01e84800 	.word	0x01e84800
10040c08:	200002c0 	.word	0x200002c0
10040c0c:	03d09000 	.word	0x03d09000

10040c10 <CPUcontextRestore>:
  *         by popping it from the stack 
  * @param  None
  * @retval None
  */
__WEAK void CPUcontextRestore(void)
{
10040c10:	b580      	push	{r7, lr}
10040c12:	af00      	add	r7, sp, #0
}
10040c14:	46c0      	nop			@ (mov r8, r8)
10040c16:	46bd      	mov	sp, r7
10040c18:	bd80      	pop	{r7, pc}
	...

10040c1c <Reset_Handler>:

	.section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
10040c1c:	4810      	ldr	r0, [pc, #64]	@ (10040c60 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
10040c1e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
10040c20:	f7ff feec 	bl	100409fc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
10040c24:	2100      	movs	r1, #0
  b  LoopCopyDataInit
10040c26:	e003      	b.n	10040c30 <LoopCopyDataInit>

10040c28 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
10040c28:	4b0e      	ldr	r3, [pc, #56]	@ (10040c64 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
10040c2a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
10040c2c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
10040c2e:	3104      	adds	r1, #4

10040c30 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
10040c30:	480d      	ldr	r0, [pc, #52]	@ (10040c68 <LoopForever+0xa>)
  ldr  r3, =_edata
10040c32:	4b0e      	ldr	r3, [pc, #56]	@ (10040c6c <LoopForever+0xe>)
  adds  r2, r0, r1
10040c34:	1842      	adds	r2, r0, r1
  cmp  r2, r3
10040c36:	429a      	cmp	r2, r3
  bcc  CopyDataInit
10040c38:	d3f6      	bcc.n	10040c28 <CopyDataInit>
  ldr  r2, =_sbss
10040c3a:	4a0d      	ldr	r2, [pc, #52]	@ (10040c70 <LoopForever+0x12>)
  b  LoopFillZerobss
10040c3c:	e002      	b.n	10040c44 <LoopFillZerobss>

10040c3e <FillZerobss>:

/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
10040c3e:	2300      	movs	r3, #0
  str  r3, [r2]
10040c40:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
10040c42:	3204      	adds	r2, #4

10040c44 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
10040c44:	4b0b      	ldr	r3, [pc, #44]	@ (10040c74 <LoopForever+0x16>)
  cmp  r2, r3
10040c46:	429a      	cmp	r2, r3
  bcc  FillZerobss
10040c48:	d3f9      	bcc.n	10040c3e <FillZerobss>
  ldr  r2, =_sbssblue
10040c4a:	4a0b      	ldr	r2, [pc, #44]	@ (10040c78 <LoopForever+0x1a>)
  b  LoopFillZeroBlueRam
10040c4c:	e002      	b.n	10040c54 <LoopFillZeroBlueRam>

10040c4e <FillZerobssram>:


FillZerobssram:
  movs  r3, #0
10040c4e:	2300      	movs	r3, #0
  str  r3, [r2]
10040c50:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
10040c52:	3204      	adds	r2, #4

10040c54 <LoopFillZeroBlueRam>:

LoopFillZeroBlueRam:
  ldr  r3, = _ebssblue
10040c54:	4b09      	ldr	r3, [pc, #36]	@ (10040c7c <LoopForever+0x1e>)
  cmp  r2, r3
10040c56:	429a      	cmp	r2, r3
  bcc  FillZerobssram
10040c58:	d3f9      	bcc.n	10040c4e <FillZerobssram>

/* Call the application's entry point.*/
  bl  main
10040c5a:	f7ff fc23 	bl	100404a4 <main>

10040c5e <LoopForever>:

LoopForever:
    b LoopForever
10040c5e:	e7fe      	b.n	10040c5e <LoopForever>
   ldr   r0, =_estack
10040c60:	20006000 	.word	0x20006000
  ldr  r3, =_sidata
10040c64:	100438b4 	.word	0x100438b4
  ldr  r0, =_sdata
10040c68:	200002bc 	.word	0x200002bc
  ldr  r3, =_edata
10040c6c:	20000358 	.word	0x20000358
  ldr  r2, =_sbss
10040c70:	200000c0 	.word	0x200000c0
  ldr  r3, = _ebss
10040c74:	200002bc 	.word	0x200002bc
  ldr  r2, =_sbssblue
10040c78:	200000c0 	.word	0x200000c0
  ldr  r3, = _ebssblue
10040c7c:	200000c0 	.word	0x200000c0

10040c80 <ADC_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
10040c80:	e7fe      	b.n	10040c80 <ADC_IRQHandler>
	...

10040c84 <LL_PWR_IsEnabledPUPDCfg>:
{
10040c84:	b580      	push	{r7, lr}
10040c86:	af00      	add	r7, sp, #0
  return ((READ_BIT(PWR->CR1, PWR_CR1_APC) == (PWR_CR1_APC)) ? 1UL : 0UL);
10040c88:	4b05      	ldr	r3, [pc, #20]	@ (10040ca0 <LL_PWR_IsEnabledPUPDCfg+0x1c>)
10040c8a:	681b      	ldr	r3, [r3, #0]
10040c8c:	2210      	movs	r2, #16
10040c8e:	4013      	ands	r3, r2
10040c90:	2b10      	cmp	r3, #16
10040c92:	d101      	bne.n	10040c98 <LL_PWR_IsEnabledPUPDCfg+0x14>
10040c94:	2301      	movs	r3, #1
10040c96:	e000      	b.n	10040c9a <LL_PWR_IsEnabledPUPDCfg+0x16>
10040c98:	2300      	movs	r3, #0
}
10040c9a:	0018      	movs	r0, r3
10040c9c:	46bd      	mov	sp, r7
10040c9e:	bd80      	pop	{r7, pc}
10040ca0:	48500000 	.word	0x48500000

10040ca4 <LL_PWR_EnableGPIOPullUp>:
{
10040ca4:	b580      	push	{r7, lr}
10040ca6:	b082      	sub	sp, #8
10040ca8:	af00      	add	r7, sp, #0
10040caa:	6078      	str	r0, [r7, #4]
10040cac:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(*((__IO uint32_t *)(GPIO + 4UL)), GPIONumber);
10040cae:	687b      	ldr	r3, [r7, #4]
10040cb0:	3304      	adds	r3, #4
10040cb2:	681a      	ldr	r2, [r3, #0]
10040cb4:	683b      	ldr	r3, [r7, #0]
10040cb6:	43d9      	mvns	r1, r3
10040cb8:	687b      	ldr	r3, [r7, #4]
10040cba:	3304      	adds	r3, #4
10040cbc:	400a      	ands	r2, r1
10040cbe:	601a      	str	r2, [r3, #0]
  SET_BIT(*((__IO uint32_t *)GPIO), GPIONumber);
10040cc0:	687b      	ldr	r3, [r7, #4]
10040cc2:	6819      	ldr	r1, [r3, #0]
10040cc4:	687b      	ldr	r3, [r7, #4]
10040cc6:	683a      	ldr	r2, [r7, #0]
10040cc8:	430a      	orrs	r2, r1
10040cca:	601a      	str	r2, [r3, #0]
}
10040ccc:	46c0      	nop			@ (mov r8, r8)
10040cce:	46bd      	mov	sp, r7
10040cd0:	b002      	add	sp, #8
10040cd2:	bd80      	pop	{r7, pc}

10040cd4 <LL_AHB1_GRP1_EnableClock>:
{
10040cd4:	b580      	push	{r7, lr}
10040cd6:	b084      	sub	sp, #16
10040cd8:	af00      	add	r7, sp, #0
10040cda:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHBENR, Periphs);
10040cdc:	4b07      	ldr	r3, [pc, #28]	@ (10040cfc <LL_AHB1_GRP1_EnableClock+0x28>)
10040cde:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040ce0:	4b06      	ldr	r3, [pc, #24]	@ (10040cfc <LL_AHB1_GRP1_EnableClock+0x28>)
10040ce2:	687a      	ldr	r2, [r7, #4]
10040ce4:	430a      	orrs	r2, r1
10040ce6:	651a      	str	r2, [r3, #80]	@ 0x50
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040ce8:	4b04      	ldr	r3, [pc, #16]	@ (10040cfc <LL_AHB1_GRP1_EnableClock+0x28>)
10040cea:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040cec:	687a      	ldr	r2, [r7, #4]
10040cee:	4013      	ands	r3, r2
10040cf0:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040cf2:	68fb      	ldr	r3, [r7, #12]
}
10040cf4:	46c0      	nop			@ (mov r8, r8)
10040cf6:	46bd      	mov	sp, r7
10040cf8:	b004      	add	sp, #16
10040cfa:	bd80      	pop	{r7, pc}
10040cfc:	48400000 	.word	0x48400000

10040d00 <LL_APB0_GRP1_EnableClock>:
{
10040d00:	b580      	push	{r7, lr}
10040d02:	b084      	sub	sp, #16
10040d04:	af00      	add	r7, sp, #0
10040d06:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB0ENR, Periphs);
10040d08:	4b07      	ldr	r3, [pc, #28]	@ (10040d28 <LL_APB0_GRP1_EnableClock+0x28>)
10040d0a:	6d59      	ldr	r1, [r3, #84]	@ 0x54
10040d0c:	4b06      	ldr	r3, [pc, #24]	@ (10040d28 <LL_APB0_GRP1_EnableClock+0x28>)
10040d0e:	687a      	ldr	r2, [r7, #4]
10040d10:	430a      	orrs	r2, r1
10040d12:	655a      	str	r2, [r3, #84]	@ 0x54
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040d14:	4b04      	ldr	r3, [pc, #16]	@ (10040d28 <LL_APB0_GRP1_EnableClock+0x28>)
10040d16:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
10040d18:	687a      	ldr	r2, [r7, #4]
10040d1a:	4013      	ands	r3, r2
10040d1c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040d1e:	68fb      	ldr	r3, [r7, #12]
}
10040d20:	46c0      	nop			@ (mov r8, r8)
10040d22:	46bd      	mov	sp, r7
10040d24:	b004      	add	sp, #16
10040d26:	bd80      	pop	{r7, pc}
10040d28:	48400000 	.word	0x48400000

10040d2c <LL_APB1_GRP1_EnableClock>:
  * @arg LL_APB1_GRP1_PERIPH_I2C2
  * @retval None
  * @note   LL_APB1_GRP1_PERIPH_SPI1, LL_APB1_GRP1_PERIPH_SPI2 and LL_APB1_GRP1_PERIPH_I2C2 are valid for STM32WB06 and STM32WB07
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
10040d2c:	b580      	push	{r7, lr}
10040d2e:	b084      	sub	sp, #16
10040d30:	af00      	add	r7, sp, #0
10040d32:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
10040d34:	4b07      	ldr	r3, [pc, #28]	@ (10040d54 <LL_APB1_GRP1_EnableClock+0x28>)
10040d36:	6d99      	ldr	r1, [r3, #88]	@ 0x58
10040d38:	4b06      	ldr	r3, [pc, #24]	@ (10040d54 <LL_APB1_GRP1_EnableClock+0x28>)
10040d3a:	687a      	ldr	r2, [r7, #4]
10040d3c:	430a      	orrs	r2, r1
10040d3e:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
10040d40:	4b04      	ldr	r3, [pc, #16]	@ (10040d54 <LL_APB1_GRP1_EnableClock+0x28>)
10040d42:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
10040d44:	687a      	ldr	r2, [r7, #4]
10040d46:	4013      	ands	r3, r2
10040d48:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040d4a:	68fb      	ldr	r3, [r7, #12]
}
10040d4c:	46c0      	nop			@ (mov r8, r8)
10040d4e:	46bd      	mov	sp, r7
10040d50:	b004      	add	sp, #16
10040d52:	bd80      	pop	{r7, pc}
10040d54:	48400000 	.word	0x48400000

10040d58 <BSP_LED_Init>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code.
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
10040d58:	b590      	push	{r4, r7, lr}
10040d5a:	b089      	sub	sp, #36	@ 0x24
10040d5c:	af00      	add	r7, sp, #0
10040d5e:	0002      	movs	r2, r0
10040d60:	1dfb      	adds	r3, r7, #7
10040d62:	701a      	strb	r2, [r3, #0]
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  if (Led == LD1)
10040d64:	1dfb      	adds	r3, r7, #7
10040d66:	781b      	ldrb	r3, [r3, #0]
10040d68:	2b00      	cmp	r3, #0
10040d6a:	d103      	bne.n	10040d74 <BSP_LED_Init+0x1c>
  {
    LD1_GPIO_CLK_ENABLE();
10040d6c:	2008      	movs	r0, #8
10040d6e:	f7ff ffb1 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
10040d72:	e00a      	b.n	10040d8a <BSP_LED_Init+0x32>
  }
  else if (Led == LD2)
10040d74:	1dfb      	adds	r3, r7, #7
10040d76:	781b      	ldrb	r3, [r3, #0]
10040d78:	2b01      	cmp	r3, #1
10040d7a:	d103      	bne.n	10040d84 <BSP_LED_Init+0x2c>
  {
    LD2_GPIO_CLK_ENABLE();
10040d7c:	2008      	movs	r0, #8
10040d7e:	f7ff ffa9 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
10040d82:	e002      	b.n	10040d8a <BSP_LED_Init+0x32>
  }
  else /* Led = LD3 */
  {
    LD3_GPIO_CLK_ENABLE();
10040d84:	2008      	movs	r0, #8
10040d86:	f7ff ffa5 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
10040d8a:	1dfb      	adds	r3, r7, #7
10040d8c:	781a      	ldrb	r2, [r3, #0]
10040d8e:	4b28      	ldr	r3, [pc, #160]	@ (10040e30 <BSP_LED_Init+0xd8>)
10040d90:	0052      	lsls	r2, r2, #1
10040d92:	5ad3      	ldrh	r3, [r2, r3]
10040d94:	001a      	movs	r2, r3
10040d96:	240c      	movs	r4, #12
10040d98:	193b      	adds	r3, r7, r4
10040d9a:	601a      	str	r2, [r3, #0]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
10040d9c:	193b      	adds	r3, r7, r4
10040d9e:	2201      	movs	r2, #1
10040da0:	605a      	str	r2, [r3, #4]
  GPIO_Init.Pull  = GPIO_PULLUP;
10040da2:	193b      	adds	r3, r7, r4
10040da4:	2201      	movs	r2, #1
10040da6:	609a      	str	r2, [r3, #8]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
10040da8:	193b      	adds	r3, r7, r4
10040daa:	2202      	movs	r2, #2
10040dac:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
10040dae:	1dfb      	adds	r3, r7, #7
10040db0:	781a      	ldrb	r2, [r3, #0]
10040db2:	4b20      	ldr	r3, [pc, #128]	@ (10040e34 <BSP_LED_Init+0xdc>)
10040db4:	0092      	lsls	r2, r2, #2
10040db6:	58d3      	ldr	r3, [r2, r3]
10040db8:	193a      	adds	r2, r7, r4
10040dba:	0011      	movs	r1, r2
10040dbc:	0018      	movs	r0, r3
10040dbe:	f000 fb83 	bl	100414c8 <HAL_GPIO_Init>

  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10040dc2:	f7ff ff5f 	bl	10040c84 <LL_PWR_IsEnabledPUPDCfg>
10040dc6:	1e03      	subs	r3, r0, #0
10040dc8:	d01f      	beq.n	10040e0a <BSP_LED_Init+0xb2>
  {
    if (LED_PORT[Led] == GPIOA)
10040dca:	1dfb      	adds	r3, r7, #7
10040dcc:	781a      	ldrb	r2, [r3, #0]
10040dce:	4b19      	ldr	r3, [pc, #100]	@ (10040e34 <BSP_LED_Init+0xdc>)
10040dd0:	0092      	lsls	r2, r2, #2
10040dd2:	58d2      	ldr	r2, [r2, r3]
10040dd4:	2390      	movs	r3, #144	@ 0x90
10040dd6:	05db      	lsls	r3, r3, #23
10040dd8:	429a      	cmp	r2, r3
10040dda:	d106      	bne.n	10040dea <BSP_LED_Init+0x92>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
10040ddc:	193b      	adds	r3, r7, r4
10040dde:	681b      	ldr	r3, [r3, #0]
10040de0:	4a15      	ldr	r2, [pc, #84]	@ (10040e38 <BSP_LED_Init+0xe0>)
10040de2:	0019      	movs	r1, r3
10040de4:	0010      	movs	r0, r2
10040de6:	f7ff ff5d 	bl	10040ca4 <LL_PWR_EnableGPIOPullUp>
    }
     if (LED_PORT[Led] == GPIOB)
10040dea:	1dfb      	adds	r3, r7, #7
10040dec:	781a      	ldrb	r2, [r3, #0]
10040dee:	4b11      	ldr	r3, [pc, #68]	@ (10040e34 <BSP_LED_Init+0xdc>)
10040df0:	0092      	lsls	r2, r2, #2
10040df2:	58d3      	ldr	r3, [r2, r3]
10040df4:	4a11      	ldr	r2, [pc, #68]	@ (10040e3c <BSP_LED_Init+0xe4>)
10040df6:	4293      	cmp	r3, r2
10040df8:	d107      	bne.n	10040e0a <BSP_LED_Init+0xb2>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_B, GPIO_Init.Pin);
10040dfa:	230c      	movs	r3, #12
10040dfc:	18fb      	adds	r3, r7, r3
10040dfe:	681b      	ldr	r3, [r3, #0]
10040e00:	4a0f      	ldr	r2, [pc, #60]	@ (10040e40 <BSP_LED_Init+0xe8>)
10040e02:	0019      	movs	r1, r3
10040e04:	0010      	movs	r0, r2
10040e06:	f7ff ff4d 	bl	10040ca4 <LL_PWR_EnableGPIOPullUp>
    }
  }

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
10040e0a:	1dfb      	adds	r3, r7, #7
10040e0c:	781a      	ldrb	r2, [r3, #0]
10040e0e:	4b09      	ldr	r3, [pc, #36]	@ (10040e34 <BSP_LED_Init+0xdc>)
10040e10:	0092      	lsls	r2, r2, #2
10040e12:	58d0      	ldr	r0, [r2, r3]
10040e14:	1dfb      	adds	r3, r7, #7
10040e16:	781a      	ldrb	r2, [r3, #0]
10040e18:	4b05      	ldr	r3, [pc, #20]	@ (10040e30 <BSP_LED_Init+0xd8>)
10040e1a:	0052      	lsls	r2, r2, #1
10040e1c:	5ad3      	ldrh	r3, [r2, r3]
10040e1e:	2201      	movs	r2, #1
10040e20:	0019      	movs	r1, r3
10040e22:	f000 fcfa 	bl	1004181a <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
10040e26:	2300      	movs	r3, #0
}
10040e28:	0018      	movs	r0, r3
10040e2a:	46bd      	mov	sp, r7
10040e2c:	b009      	add	sp, #36	@ 0x24
10040e2e:	bd90      	pop	{r4, r7, pc}
10040e30:	200002c4 	.word	0x200002c4
10040e34:	200002cc 	.word	0x200002cc
10040e38:	48500020 	.word	0x48500020
10040e3c:	48100000 	.word	0x48100000
10040e40:	48500028 	.word	0x48500028

10040e44 <BSP_LED_On>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code.
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
10040e44:	b580      	push	{r7, lr}
10040e46:	b082      	sub	sp, #8
10040e48:	af00      	add	r7, sp, #0
10040e4a:	0002      	movs	r2, r0
10040e4c:	1dfb      	adds	r3, r7, #7
10040e4e:	701a      	strb	r2, [r3, #0]
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
10040e50:	1dfb      	adds	r3, r7, #7
10040e52:	781a      	ldrb	r2, [r3, #0]
10040e54:	4b08      	ldr	r3, [pc, #32]	@ (10040e78 <BSP_LED_On+0x34>)
10040e56:	0092      	lsls	r2, r2, #2
10040e58:	58d0      	ldr	r0, [r2, r3]
10040e5a:	1dfb      	adds	r3, r7, #7
10040e5c:	781a      	ldrb	r2, [r3, #0]
10040e5e:	4b07      	ldr	r3, [pc, #28]	@ (10040e7c <BSP_LED_On+0x38>)
10040e60:	0052      	lsls	r2, r2, #1
10040e62:	5ad3      	ldrh	r3, [r2, r3]
10040e64:	2200      	movs	r2, #0
10040e66:	0019      	movs	r1, r3
10040e68:	f000 fcd7 	bl	1004181a <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
10040e6c:	2300      	movs	r3, #0
}
10040e6e:	0018      	movs	r0, r3
10040e70:	46bd      	mov	sp, r7
10040e72:	b002      	add	sp, #8
10040e74:	bd80      	pop	{r7, pc}
10040e76:	46c0      	nop			@ (mov r8, r8)
10040e78:	200002cc 	.word	0x200002cc
10040e7c:	200002c4 	.word	0x200002c4

10040e80 <BSP_LED_Toggle>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code.
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
10040e80:	b580      	push	{r7, lr}
10040e82:	b082      	sub	sp, #8
10040e84:	af00      	add	r7, sp, #0
10040e86:	0002      	movs	r2, r0
10040e88:	1dfb      	adds	r3, r7, #7
10040e8a:	701a      	strb	r2, [r3, #0]
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
10040e8c:	1dfb      	adds	r3, r7, #7
10040e8e:	781a      	ldrb	r2, [r3, #0]
10040e90:	4b07      	ldr	r3, [pc, #28]	@ (10040eb0 <BSP_LED_Toggle+0x30>)
10040e92:	0092      	lsls	r2, r2, #2
10040e94:	58d0      	ldr	r0, [r2, r3]
10040e96:	1dfb      	adds	r3, r7, #7
10040e98:	781a      	ldrb	r2, [r3, #0]
10040e9a:	4b06      	ldr	r3, [pc, #24]	@ (10040eb4 <BSP_LED_Toggle+0x34>)
10040e9c:	0052      	lsls	r2, r2, #1
10040e9e:	5ad3      	ldrh	r3, [r2, r3]
10040ea0:	0019      	movs	r1, r3
10040ea2:	f000 fcd7 	bl	10041854 <HAL_GPIO_TogglePin>
  return BSP_ERROR_NONE;
10040ea6:	2300      	movs	r3, #0
}
10040ea8:	0018      	movs	r0, r3
10040eaa:	46bd      	mov	sp, r7
10040eac:	b002      	add	sp, #8
10040eae:	bd80      	pop	{r7, pc}
10040eb0:	200002cc 	.word	0x200002cc
10040eb4:	200002c4 	.word	0x200002c4

10040eb8 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability
  * @retval BSP error code.
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
10040eb8:	b580      	push	{r7, lr}
10040eba:	b088      	sub	sp, #32
10040ebc:	af00      	add	r7, sp, #0
10040ebe:	0002      	movs	r2, r0
10040ec0:	1dfb      	adds	r3, r7, #7
10040ec2:	701a      	strb	r2, [r3, #0]
10040ec4:	1dbb      	adds	r3, r7, #6
10040ec6:	1c0a      	adds	r2, r1, #0
10040ec8:	701a      	strb	r2, [r3, #0]
  int32_t               status = BSP_ERROR_NONE;
10040eca:	2300      	movs	r3, #0
10040ecc:	61fb      	str	r3, [r7, #28]
  GPIO_InitTypeDef      GPIO_Init;

  /* Enable the BUTTON clock */
  if (Button == B1)
10040ece:	1dfb      	adds	r3, r7, #7
10040ed0:	781b      	ldrb	r3, [r3, #0]
10040ed2:	2b00      	cmp	r3, #0
10040ed4:	d103      	bne.n	10040ede <BSP_PB_Init+0x26>
  {
    B1_GPIO_CLK_ENABLE();
10040ed6:	2004      	movs	r0, #4
10040ed8:	f7ff fefc 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
10040edc:	e00a      	b.n	10040ef4 <BSP_PB_Init+0x3c>
  }
  else if (Button == B2)
10040ede:	1dfb      	adds	r3, r7, #7
10040ee0:	781b      	ldrb	r3, [r3, #0]
10040ee2:	2b01      	cmp	r3, #1
10040ee4:	d103      	bne.n	10040eee <BSP_PB_Init+0x36>
  {
    B2_GPIO_CLK_ENABLE();
10040ee6:	2008      	movs	r0, #8
10040ee8:	f7ff fef4 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
10040eec:	e002      	b.n	10040ef4 <BSP_PB_Init+0x3c>
  }
  else /* B3 */
  {
    B3_GPIO_CLK_ENABLE();
10040eee:	2008      	movs	r0, #8
10040ef0:	f7ff fef0 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
  }

  GPIO_Init.Pin   = BUTTON_PIN[Button];
10040ef4:	1dfb      	adds	r3, r7, #7
10040ef6:	781a      	ldrb	r2, [r3, #0]
10040ef8:	4b37      	ldr	r3, [pc, #220]	@ (10040fd8 <BSP_PB_Init+0x120>)
10040efa:	0052      	lsls	r2, r2, #1
10040efc:	5ad3      	ldrh	r3, [r2, r3]
10040efe:	001a      	movs	r2, r3
10040f00:	2108      	movs	r1, #8
10040f02:	187b      	adds	r3, r7, r1
10040f04:	601a      	str	r2, [r3, #0]
  GPIO_Init.Pull  = GPIO_PULLUP;
10040f06:	187b      	adds	r3, r7, r1
10040f08:	2201      	movs	r2, #1
10040f0a:	609a      	str	r2, [r3, #8]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
10040f0c:	187b      	adds	r3, r7, r1
10040f0e:	2202      	movs	r2, #2
10040f10:	60da      	str	r2, [r3, #12]

  if (ButtonMode == BUTTON_MODE_GPIO)
10040f12:	1dbb      	adds	r3, r7, #6
10040f14:	781b      	ldrb	r3, [r3, #0]
10040f16:	2b00      	cmp	r3, #0
10040f18:	d10c      	bne.n	10040f34 <BSP_PB_Init+0x7c>
  {
    /* Configure Button pin as input */
    GPIO_Init.Mode = GPIO_MODE_INPUT;
10040f1a:	187b      	adds	r3, r7, r1
10040f1c:	2200      	movs	r2, #0
10040f1e:	605a      	str	r2, [r3, #4]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
10040f20:	1dfb      	adds	r3, r7, #7
10040f22:	781a      	ldrb	r2, [r3, #0]
10040f24:	4b2d      	ldr	r3, [pc, #180]	@ (10040fdc <BSP_PB_Init+0x124>)
10040f26:	0092      	lsls	r2, r2, #2
10040f28:	58d3      	ldr	r3, [r2, r3]
10040f2a:	187a      	adds	r2, r7, r1
10040f2c:	0011      	movs	r1, r2
10040f2e:	0018      	movs	r0, r3
10040f30:	f000 faca 	bl	100414c8 <HAL_GPIO_Init>
  }

  if (ButtonMode == BUTTON_MODE_EXTI)
10040f34:	1dbb      	adds	r3, r7, #6
10040f36:	781b      	ldrb	r3, [r3, #0]
10040f38:	2b01      	cmp	r3, #1
10040f3a:	d123      	bne.n	10040f84 <BSP_PB_Init+0xcc>
  {
    __HAL_RCC_SYSCFG_CLK_ENABLE();
10040f3c:	2380      	movs	r3, #128	@ 0x80
10040f3e:	005b      	lsls	r3, r3, #1
10040f40:	0018      	movs	r0, r3
10040f42:	f7ff fedd 	bl	10040d00 <LL_APB0_GRP1_EnableClock>

    /* Configure Button pin as input with External interrupt */
    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
10040f46:	2108      	movs	r1, #8
10040f48:	187b      	adds	r3, r7, r1
10040f4a:	2280      	movs	r2, #128	@ 0x80
10040f4c:	0252      	lsls	r2, r2, #9
10040f4e:	605a      	str	r2, [r3, #4]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
10040f50:	1dfb      	adds	r3, r7, #7
10040f52:	781a      	ldrb	r2, [r3, #0]
10040f54:	4b21      	ldr	r3, [pc, #132]	@ (10040fdc <BSP_PB_Init+0x124>)
10040f56:	0092      	lsls	r2, r2, #2
10040f58:	58d3      	ldr	r3, [r2, r3]
10040f5a:	187a      	adds	r2, r7, r1
10040f5c:	0011      	movs	r1, r2
10040f5e:	0018      	movs	r0, r3
10040f60:	f000 fab2 	bl	100414c8 <HAL_GPIO_Init>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority(BUTTON_IRQn[Button], NVIC_LOW_PRIORITY, 0);
10040f64:	1dfb      	adds	r3, r7, #7
10040f66:	781b      	ldrb	r3, [r3, #0]
10040f68:	4a1d      	ldr	r2, [pc, #116]	@ (10040fe0 <BSP_PB_Init+0x128>)
10040f6a:	56d3      	ldrsb	r3, [r2, r3]
10040f6c:	2200      	movs	r2, #0
10040f6e:	2103      	movs	r1, #3
10040f70:	0018      	movs	r0, r3
10040f72:	f000 fa77 	bl	10041464 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(BUTTON_IRQn[Button]);
10040f76:	1dfb      	adds	r3, r7, #7
10040f78:	781b      	ldrb	r3, [r3, #0]
10040f7a:	4a19      	ldr	r2, [pc, #100]	@ (10040fe0 <BSP_PB_Init+0x128>)
10040f7c:	56d3      	ldrsb	r3, [r2, r3]
10040f7e:	0018      	movs	r0, r3
10040f80:	f000 fa85 	bl	1004148e <HAL_NVIC_EnableIRQ>

  }
  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10040f84:	f7ff fe7e 	bl	10040c84 <LL_PWR_IsEnabledPUPDCfg>
10040f88:	1e03      	subs	r3, r0, #0
10040f8a:	d020      	beq.n	10040fce <BSP_PB_Init+0x116>
  {
    if (BUTTON_PORT[Button] == GPIOA)
10040f8c:	1dfb      	adds	r3, r7, #7
10040f8e:	781a      	ldrb	r2, [r3, #0]
10040f90:	4b12      	ldr	r3, [pc, #72]	@ (10040fdc <BSP_PB_Init+0x124>)
10040f92:	0092      	lsls	r2, r2, #2
10040f94:	58d2      	ldr	r2, [r2, r3]
10040f96:	2390      	movs	r3, #144	@ 0x90
10040f98:	05db      	lsls	r3, r3, #23
10040f9a:	429a      	cmp	r2, r3
10040f9c:	d107      	bne.n	10040fae <BSP_PB_Init+0xf6>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
10040f9e:	2308      	movs	r3, #8
10040fa0:	18fb      	adds	r3, r7, r3
10040fa2:	681b      	ldr	r3, [r3, #0]
10040fa4:	4a0f      	ldr	r2, [pc, #60]	@ (10040fe4 <BSP_PB_Init+0x12c>)
10040fa6:	0019      	movs	r1, r3
10040fa8:	0010      	movs	r0, r2
10040faa:	f7ff fe7b 	bl	10040ca4 <LL_PWR_EnableGPIOPullUp>
    }
     if (BUTTON_PORT[Button] == GPIOB)
10040fae:	1dfb      	adds	r3, r7, #7
10040fb0:	781a      	ldrb	r2, [r3, #0]
10040fb2:	4b0a      	ldr	r3, [pc, #40]	@ (10040fdc <BSP_PB_Init+0x124>)
10040fb4:	0092      	lsls	r2, r2, #2
10040fb6:	58d3      	ldr	r3, [r2, r3]
10040fb8:	4a0b      	ldr	r2, [pc, #44]	@ (10040fe8 <BSP_PB_Init+0x130>)
10040fba:	4293      	cmp	r3, r2
10040fbc:	d107      	bne.n	10040fce <BSP_PB_Init+0x116>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_B, GPIO_Init.Pin);
10040fbe:	2308      	movs	r3, #8
10040fc0:	18fb      	adds	r3, r7, r3
10040fc2:	681b      	ldr	r3, [r3, #0]
10040fc4:	4a09      	ldr	r2, [pc, #36]	@ (10040fec <BSP_PB_Init+0x134>)
10040fc6:	0019      	movs	r1, r3
10040fc8:	0010      	movs	r0, r2
10040fca:	f7ff fe6b 	bl	10040ca4 <LL_PWR_EnableGPIOPullUp>
    }
  }
  return status;
10040fce:	69fb      	ldr	r3, [r7, #28]
}
10040fd0:	0018      	movs	r0, r3
10040fd2:	46bd      	mov	sp, r7
10040fd4:	b008      	add	sp, #32
10040fd6:	bd80      	pop	{r7, pc}
10040fd8:	200002d8 	.word	0x200002d8
10040fdc:	200002e0 	.word	0x200002e0
10040fe0:	200002ec 	.word	0x200002ec
10040fe4:	48500020 	.word	0x48500020
10040fe8:	48100000 	.word	0x48100000
10040fec:	48500028 	.word	0x48500028

10040ff0 <BSP_PB_IRQHandler>:
  * @param  GPIO_Pin Contains the pin state of GPIO when the interrupt occurred
  * @retval None.
  */

void BSP_PB_IRQHandler(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
10040ff0:	b580      	push	{r7, lr}
10040ff2:	b082      	sub	sp, #8
10040ff4:	af00      	add	r7, sp, #0
10040ff6:	6078      	str	r0, [r7, #4]
10040ff8:	000a      	movs	r2, r1
10040ffa:	1cbb      	adds	r3, r7, #2
10040ffc:	801a      	strh	r2, [r3, #0]
  HAL_GPIO_EXTI_IRQHandler( GPIOx, GPIO_Pin);
10040ffe:	1cbb      	adds	r3, r7, #2
10041000:	881a      	ldrh	r2, [r3, #0]
10041002:	687b      	ldr	r3, [r7, #4]
10041004:	0011      	movs	r1, r2
10041006:	0018      	movs	r0, r3
10041008:	f000 fc3f 	bl	1004188a <HAL_GPIO_EXTI_IRQHandler>
}
1004100c:	46c0      	nop			@ (mov r8, r8)
1004100e:	46bd      	mov	sp, r7
10041010:	b002      	add	sp, #8
10041012:	bd80      	pop	{r7, pc}

10041014 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a COM_InitTypeDef structure that contains the
  *                  configuration information for the specified COM peripheral.
  * @retval BSP error code.
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
10041014:	b580      	push	{r7, lr}
10041016:	b084      	sub	sp, #16
10041018:	af00      	add	r7, sp, #0
1004101a:	0002      	movs	r2, r0
1004101c:	6039      	str	r1, [r7, #0]
1004101e:	1dfb      	adds	r3, r7, #7
10041020:	701a      	strb	r2, [r3, #0]
  int32_t status = BSP_ERROR_NONE;
10041022:	2300      	movs	r3, #0
10041024:	60fb      	str	r3, [r7, #12]

  if (COM_Init == NULL)
10041026:	683b      	ldr	r3, [r7, #0]
10041028:	2b00      	cmp	r3, #0
1004102a:	d103      	bne.n	10041034 <BSP_COM_Init+0x20>
  {
    status = BSP_ERROR_WRONG_PARAM;
1004102c:	2302      	movs	r3, #2
1004102e:	425b      	negs	r3, r3
10041030:	60fb      	str	r3, [r7, #12]
10041032:	e026      	b.n	10041082 <BSP_COM_Init+0x6e>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
10041034:	1dfb      	adds	r3, r7, #7
10041036:	7819      	ldrb	r1, [r3, #0]
10041038:	1dfb      	adds	r3, r7, #7
1004103a:	781a      	ldrb	r2, [r3, #0]
1004103c:	4b13      	ldr	r3, [pc, #76]	@ (1004108c <BSP_COM_Init+0x78>)
1004103e:	0089      	lsls	r1, r1, #2
10041040:	58c9      	ldr	r1, [r1, r3]
10041042:	4b13      	ldr	r3, [pc, #76]	@ (10041090 <BSP_COM_Init+0x7c>)
10041044:	2094      	movs	r0, #148	@ 0x94
10041046:	4342      	muls	r2, r0
10041048:	50d1      	str	r1, [r2, r3]

#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
1004104a:	1dfb      	adds	r3, r7, #7
1004104c:	781b      	ldrb	r3, [r3, #0]
1004104e:	2294      	movs	r2, #148	@ 0x94
10041050:	435a      	muls	r2, r3
10041052:	4b0f      	ldr	r3, [pc, #60]	@ (10041090 <BSP_COM_Init+0x7c>)
10041054:	18d3      	adds	r3, r2, r3
10041056:	0018      	movs	r0, r3
10041058:	f000 f868 	bl	1004112c <UART_MspInit>
        status = BSP_ERROR_MSP_FAILURE;
      }
    }
#endif

    if (status == BSP_ERROR_NONE)
1004105c:	68fb      	ldr	r3, [r7, #12]
1004105e:	2b00      	cmp	r3, #0
10041060:	d10f      	bne.n	10041082 <BSP_COM_Init+0x6e>
    {
      if (MX_USART1_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
10041062:	1dfb      	adds	r3, r7, #7
10041064:	781b      	ldrb	r3, [r3, #0]
10041066:	2294      	movs	r2, #148	@ 0x94
10041068:	435a      	muls	r2, r3
1004106a:	4b09      	ldr	r3, [pc, #36]	@ (10041090 <BSP_COM_Init+0x7c>)
1004106c:	18d3      	adds	r3, r2, r3
1004106e:	683a      	ldr	r2, [r7, #0]
10041070:	0011      	movs	r1, r2
10041072:	0018      	movs	r0, r3
10041074:	f000 f828 	bl	100410c8 <MX_USART1_Init>
10041078:	1e03      	subs	r3, r0, #0
1004107a:	d002      	beq.n	10041082 <BSP_COM_Init+0x6e>
      {
        status = BSP_ERROR_PERIPH_FAILURE;
1004107c:	2304      	movs	r3, #4
1004107e:	425b      	negs	r3, r3
10041080:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  return status;
10041082:	68fb      	ldr	r3, [r7, #12]
}
10041084:	0018      	movs	r0, r3
10041086:	46bd      	mov	sp, r7
10041088:	b004      	add	sp, #16
1004108a:	bd80      	pop	{r7, pc}
1004108c:	200002f0 	.word	0x200002f0
10041090:	200000d4 	.word	0x200000d4

10041094 <__io_putchar>:
  return 1;
}

#elif defined(__GNUC__)
int __io_putchar(int ch)
{
10041094:	b580      	push	{r7, lr}
10041096:	b082      	sub	sp, #8
10041098:	af00      	add	r7, sp, #0
1004109a:	6078      	str	r0, [r7, #4]
  (void) HAL_UART_Transmit(&hcom_uart[COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
1004109c:	4b08      	ldr	r3, [pc, #32]	@ (100410c0 <__io_putchar+0x2c>)
1004109e:	781b      	ldrb	r3, [r3, #0]
100410a0:	001a      	movs	r2, r3
100410a2:	2394      	movs	r3, #148	@ 0x94
100410a4:	435a      	muls	r2, r3
100410a6:	4b07      	ldr	r3, [pc, #28]	@ (100410c4 <__io_putchar+0x30>)
100410a8:	18d0      	adds	r0, r2, r3
100410aa:	23fa      	movs	r3, #250	@ 0xfa
100410ac:	009b      	lsls	r3, r3, #2
100410ae:	1d39      	adds	r1, r7, #4
100410b0:	2201      	movs	r2, #1
100410b2:	f000 ff9d 	bl	10041ff0 <HAL_UART_Transmit>
  return ch;
100410b6:	687b      	ldr	r3, [r7, #4]
}
100410b8:	0018      	movs	r0, r3
100410ba:	46bd      	mov	sp, r7
100410bc:	b002      	add	sp, #8
100410be:	bd80      	pop	{r7, pc}
100410c0:	20000168 	.word	0x20000168
100410c4:	200000d4 	.word	0x200000d4

100410c8 <MX_USART1_Init>:
  * @param  huart UART handle.
  * @param  MXInit UART initialization structure.
  * @retval HAL status.
  */
__weak HAL_StatusTypeDef MX_USART1_Init(UART_HandleTypeDef* huart, MX_UART_InitTypeDef *MXInit)
{
100410c8:	b580      	push	{r7, lr}
100410ca:	b082      	sub	sp, #8
100410cc:	af00      	add	r7, sp, #0
100410ce:	6078      	str	r0, [r7, #4]
100410d0:	6039      	str	r1, [r7, #0]
  /* UART configuration */
  huart->Init.BaudRate       = MXInit->BaudRate;
100410d2:	683b      	ldr	r3, [r7, #0]
100410d4:	681a      	ldr	r2, [r3, #0]
100410d6:	687b      	ldr	r3, [r7, #4]
100410d8:	605a      	str	r2, [r3, #4]
  huart->Init.WordLength     = (uint32_t) MXInit->WordLength;
100410da:	683b      	ldr	r3, [r7, #0]
100410dc:	685a      	ldr	r2, [r3, #4]
100410de:	687b      	ldr	r3, [r7, #4]
100410e0:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits       = (uint32_t) MXInit->StopBits;
100410e2:	683b      	ldr	r3, [r7, #0]
100410e4:	891b      	ldrh	r3, [r3, #8]
100410e6:	001a      	movs	r2, r3
100410e8:	687b      	ldr	r3, [r7, #4]
100410ea:	60da      	str	r2, [r3, #12]
  huart->Init.Parity         = (uint32_t) MXInit->Parity;
100410ec:	683b      	ldr	r3, [r7, #0]
100410ee:	895b      	ldrh	r3, [r3, #10]
100410f0:	001a      	movs	r2, r3
100410f2:	687b      	ldr	r3, [r7, #4]
100410f4:	611a      	str	r2, [r3, #16]
  huart->Init.Mode           = UART_MODE_TX_RX;
100410f6:	687b      	ldr	r3, [r7, #4]
100410f8:	220c      	movs	r2, #12
100410fa:	615a      	str	r2, [r3, #20]
  huart->Init.HwFlowCtl      = (uint32_t) MXInit->HwFlowCtl;
100410fc:	683b      	ldr	r3, [r7, #0]
100410fe:	899b      	ldrh	r3, [r3, #12]
10041100:	001a      	movs	r2, r3
10041102:	687b      	ldr	r3, [r7, #4]
10041104:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling   = UART_OVERSAMPLING_8;
10041106:	687b      	ldr	r3, [r7, #4]
10041108:	2280      	movs	r2, #128	@ 0x80
1004110a:	0212      	lsls	r2, r2, #8
1004110c:	61da      	str	r2, [r3, #28]
  huart->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
1004110e:	687b      	ldr	r3, [r7, #4]
10041110:	2200      	movs	r2, #0
10041112:	621a      	str	r2, [r3, #32]
  huart->Init.ClockPrescaler = UART_PRESCALER_DIV1;
10041114:	687b      	ldr	r3, [r7, #4]
10041116:	2200      	movs	r2, #0
10041118:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_UART_Init(huart);
1004111a:	687b      	ldr	r3, [r7, #4]
1004111c:	0018      	movs	r0, r3
1004111e:	f000 ff09 	bl	10041f34 <HAL_UART_Init>
10041122:	0003      	movs	r3, r0
}
10041124:	0018      	movs	r0, r3
10041126:	46bd      	mov	sp, r7
10041128:	b002      	add	sp, #8
1004112a:	bd80      	pop	{r7, pc}

1004112c <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(UART_HandleTypeDef *huart)
{
1004112c:	b590      	push	{r4, r7, lr}
1004112e:	b089      	sub	sp, #36	@ 0x24
10041130:	af00      	add	r7, sp, #0
10041132:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);

  /* Enable COM and GPIO clocks */
  COM1_TX_GPIO_CLK_ENABLE();
10041134:	2004      	movs	r0, #4
10041136:	f7ff fdcd 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
  COM1_RX_GPIO_CLK_ENABLE();
1004113a:	2008      	movs	r0, #8
1004113c:	f7ff fdca 	bl	10040cd4 <LL_AHB1_GRP1_EnableClock>
  COM1_CLK_ENABLE();
10041140:	2380      	movs	r3, #128	@ 0x80
10041142:	00db      	lsls	r3, r3, #3
10041144:	0018      	movs	r0, r3
10041146:	f7ff fdf1 	bl	10040d2c <LL_APB1_GRP1_EnableClock>

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM1_TX_PIN;
1004114a:	240c      	movs	r4, #12
1004114c:	193b      	adds	r3, r7, r4
1004114e:	2202      	movs	r2, #2
10041150:	601a      	str	r2, [r3, #0]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
10041152:	193b      	adds	r3, r7, r4
10041154:	2202      	movs	r2, #2
10041156:	605a      	str	r2, [r3, #4]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
10041158:	193b      	adds	r3, r7, r4
1004115a:	2202      	movs	r2, #2
1004115c:	60da      	str	r2, [r3, #12]
  GPIO_Init.Pull      = GPIO_PULLUP;
1004115e:	193b      	adds	r3, r7, r4
10041160:	2201      	movs	r2, #1
10041162:	609a      	str	r2, [r3, #8]
  GPIO_Init.Alternate = COM1_TX_AF;
10041164:	193b      	adds	r3, r7, r4
10041166:	2202      	movs	r2, #2
10041168:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(COM1_TX_GPIO_PORT, &GPIO_Init);
1004116a:	193a      	adds	r2, r7, r4
1004116c:	2390      	movs	r3, #144	@ 0x90
1004116e:	05db      	lsls	r3, r3, #23
10041170:	0011      	movs	r1, r2
10041172:	0018      	movs	r0, r3
10041174:	f000 f9a8 	bl	100414c8 <HAL_GPIO_Init>
  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10041178:	f7ff fd84 	bl	10040c84 <LL_PWR_IsEnabledPUPDCfg>
1004117c:	1e03      	subs	r3, r0, #0
1004117e:	d006      	beq.n	1004118e <UART_MspInit+0x62>
  {
    LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
10041180:	193b      	adds	r3, r7, r4
10041182:	681b      	ldr	r3, [r3, #0]
10041184:	4a0a      	ldr	r2, [pc, #40]	@ (100411b0 <UART_MspInit+0x84>)
10041186:	0019      	movs	r1, r3
10041188:	0010      	movs	r0, r2
1004118a:	f7ff fd8b 	bl	10040ca4 <LL_PWR_EnableGPIOPullUp>
  }
  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM1_RX_PIN;
1004118e:	210c      	movs	r1, #12
10041190:	187b      	adds	r3, r7, r1
10041192:	2201      	movs	r2, #1
10041194:	601a      	str	r2, [r3, #0]
  GPIO_Init.Alternate = COM1_RX_AF;
10041196:	187b      	adds	r3, r7, r1
10041198:	2200      	movs	r2, #0
1004119a:	611a      	str	r2, [r3, #16]
  HAL_GPIO_Init(COM1_RX_GPIO_PORT, &GPIO_Init);
1004119c:	187b      	adds	r3, r7, r1
1004119e:	4a05      	ldr	r2, [pc, #20]	@ (100411b4 <UART_MspInit+0x88>)
100411a0:	0019      	movs	r1, r3
100411a2:	0010      	movs	r0, r2
100411a4:	f000 f990 	bl	100414c8 <HAL_GPIO_Init>
}
100411a8:	46c0      	nop			@ (mov r8, r8)
100411aa:	46bd      	mov	sp, r7
100411ac:	b009      	add	sp, #36	@ 0x24
100411ae:	bd90      	pop	{r4, r7, pc}
100411b0:	48500020 	.word	0x48500020
100411b4:	48100000 	.word	0x48100000

100411b8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
100411b8:	b580      	push	{r7, lr}
100411ba:	b082      	sub	sp, #8
100411bc:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
100411be:	1dfb      	adds	r3, r7, #7
100411c0:	2200      	movs	r2, #0
100411c2:	701a      	strb	r2, [r3, #0]

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
100411c4:	2003      	movs	r0, #3
100411c6:	f000 f80f 	bl	100411e8 <HAL_InitTick>
100411ca:	1e03      	subs	r3, r0, #0
100411cc:	d003      	beq.n	100411d6 <HAL_Init+0x1e>
  {
    status = HAL_ERROR;
100411ce:	1dfb      	adds	r3, r7, #7
100411d0:	2201      	movs	r2, #1
100411d2:	701a      	strb	r2, [r3, #0]
100411d4:	e001      	b.n	100411da <HAL_Init+0x22>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
100411d6:	f7ff fab3 	bl	10040740 <HAL_MspInit>
  }

  /* Return function status */
  return status;
100411da:	1dfb      	adds	r3, r7, #7
100411dc:	781b      	ldrb	r3, [r3, #0]
}
100411de:	0018      	movs	r0, r3
100411e0:	46bd      	mov	sp, r7
100411e2:	b002      	add	sp, #8
100411e4:	bd80      	pop	{r7, pc}
	...

100411e8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
100411e8:	b590      	push	{r4, r7, lr}
100411ea:	b085      	sub	sp, #20
100411ec:	af00      	add	r7, sp, #0
100411ee:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
100411f0:	230f      	movs	r3, #15
100411f2:	18fb      	adds	r3, r7, r3
100411f4:	2200      	movs	r2, #0
100411f6:	701a      	strb	r2, [r3, #0]

  if (uwTickFreq != 0U)
100411f8:	4b1d      	ldr	r3, [pc, #116]	@ (10041270 <HAL_InitTick+0x88>)
100411fa:	781b      	ldrb	r3, [r3, #0]
100411fc:	2b00      	cmp	r3, #0
100411fe:	d02c      	beq.n	1004125a <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetSysClockFreq() / (1000U / uwTickFreq)) == 0U)
10041200:	f000 fcd6 	bl	10041bb0 <HAL_RCC_GetSysClockFreq>
10041204:	0004      	movs	r4, r0
10041206:	4b1a      	ldr	r3, [pc, #104]	@ (10041270 <HAL_InitTick+0x88>)
10041208:	781b      	ldrb	r3, [r3, #0]
1004120a:	0019      	movs	r1, r3
1004120c:	23fa      	movs	r3, #250	@ 0xfa
1004120e:	0098      	lsls	r0, r3, #2
10041210:	f7fe ff60 	bl	100400d4 <__udivsi3>
10041214:	0003      	movs	r3, r0
10041216:	0019      	movs	r1, r3
10041218:	0020      	movs	r0, r4
1004121a:	f7fe ff5b 	bl	100400d4 <__udivsi3>
1004121e:	0003      	movs	r3, r0
10041220:	0018      	movs	r0, r3
10041222:	f000 f944 	bl	100414ae <HAL_SYSTICK_Config>
10041226:	1e03      	subs	r3, r0, #0
10041228:	d112      	bne.n	10041250 <HAL_InitTick+0x68>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
1004122a:	687b      	ldr	r3, [r7, #4]
1004122c:	2b03      	cmp	r3, #3
1004122e:	d80a      	bhi.n	10041246 <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
10041230:	6879      	ldr	r1, [r7, #4]
10041232:	2301      	movs	r3, #1
10041234:	425b      	negs	r3, r3
10041236:	2200      	movs	r2, #0
10041238:	0018      	movs	r0, r3
1004123a:	f000 f913 	bl	10041464 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
1004123e:	4b0d      	ldr	r3, [pc, #52]	@ (10041274 <HAL_InitTick+0x8c>)
10041240:	687a      	ldr	r2, [r7, #4]
10041242:	601a      	str	r2, [r3, #0]
10041244:	e00d      	b.n	10041262 <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
10041246:	230f      	movs	r3, #15
10041248:	18fb      	adds	r3, r7, r3
1004124a:	2201      	movs	r2, #1
1004124c:	701a      	strb	r2, [r3, #0]
1004124e:	e008      	b.n	10041262 <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
10041250:	230f      	movs	r3, #15
10041252:	18fb      	adds	r3, r7, r3
10041254:	2201      	movs	r2, #1
10041256:	701a      	strb	r2, [r3, #0]
10041258:	e003      	b.n	10041262 <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
1004125a:	230f      	movs	r3, #15
1004125c:	18fb      	adds	r3, r7, r3
1004125e:	2201      	movs	r2, #1
10041260:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
10041262:	230f      	movs	r3, #15
10041264:	18fb      	adds	r3, r7, r3
10041266:	781b      	ldrb	r3, [r3, #0]
}
10041268:	0018      	movs	r0, r3
1004126a:	46bd      	mov	sp, r7
1004126c:	b005      	add	sp, #20
1004126e:	bd90      	pop	{r4, r7, pc}
10041270:	200002f8 	.word	0x200002f8
10041274:	200002f4 	.word	0x200002f4

10041278 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
10041278:	b580      	push	{r7, lr}
1004127a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
1004127c:	4b05      	ldr	r3, [pc, #20]	@ (10041294 <HAL_IncTick+0x1c>)
1004127e:	781b      	ldrb	r3, [r3, #0]
10041280:	001a      	movs	r2, r3
10041282:	4b05      	ldr	r3, [pc, #20]	@ (10041298 <HAL_IncTick+0x20>)
10041284:	681b      	ldr	r3, [r3, #0]
10041286:	18d2      	adds	r2, r2, r3
10041288:	4b03      	ldr	r3, [pc, #12]	@ (10041298 <HAL_IncTick+0x20>)
1004128a:	601a      	str	r2, [r3, #0]
}
1004128c:	46c0      	nop			@ (mov r8, r8)
1004128e:	46bd      	mov	sp, r7
10041290:	bd80      	pop	{r7, pc}
10041292:	46c0      	nop			@ (mov r8, r8)
10041294:	200002f8 	.word	0x200002f8
10041298:	2000016c 	.word	0x2000016c

1004129c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
1004129c:	b580      	push	{r7, lr}
1004129e:	af00      	add	r7, sp, #0
  return uwTick;
100412a0:	4b02      	ldr	r3, [pc, #8]	@ (100412ac <HAL_GetTick+0x10>)
100412a2:	681b      	ldr	r3, [r3, #0]
}
100412a4:	0018      	movs	r0, r3
100412a6:	46bd      	mov	sp, r7
100412a8:	bd80      	pop	{r7, pc}
100412aa:	46c0      	nop			@ (mov r8, r8)
100412ac:	2000016c 	.word	0x2000016c

100412b0 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
100412b0:	b580      	push	{r7, lr}
100412b2:	af00      	add	r7, sp, #0
  return uwTickPrio;
100412b4:	4b02      	ldr	r3, [pc, #8]	@ (100412c0 <HAL_GetTickPrio+0x10>)
100412b6:	681b      	ldr	r3, [r3, #0]
}
100412b8:	0018      	movs	r0, r3
100412ba:	46bd      	mov	sp, r7
100412bc:	bd80      	pop	{r7, pc}
100412be:	46c0      	nop			@ (mov r8, r8)
100412c0:	200002f4 	.word	0x200002f4

100412c4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
100412c4:	b580      	push	{r7, lr}
100412c6:	b084      	sub	sp, #16
100412c8:	af00      	add	r7, sp, #0
100412ca:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
100412cc:	f7ff ffe6 	bl	1004129c <HAL_GetTick>
100412d0:	0003      	movs	r3, r0
100412d2:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
100412d4:	687b      	ldr	r3, [r7, #4]
100412d6:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
100412d8:	68fb      	ldr	r3, [r7, #12]
100412da:	3301      	adds	r3, #1
100412dc:	d005      	beq.n	100412ea <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
100412de:	4b0a      	ldr	r3, [pc, #40]	@ (10041308 <HAL_Delay+0x44>)
100412e0:	781b      	ldrb	r3, [r3, #0]
100412e2:	001a      	movs	r2, r3
100412e4:	68fb      	ldr	r3, [r7, #12]
100412e6:	189b      	adds	r3, r3, r2
100412e8:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
100412ea:	46c0      	nop			@ (mov r8, r8)
100412ec:	f7ff ffd6 	bl	1004129c <HAL_GetTick>
100412f0:	0002      	movs	r2, r0
100412f2:	68bb      	ldr	r3, [r7, #8]
100412f4:	1ad3      	subs	r3, r2, r3
100412f6:	68fa      	ldr	r2, [r7, #12]
100412f8:	429a      	cmp	r2, r3
100412fa:	d8f7      	bhi.n	100412ec <HAL_Delay+0x28>
  {
  }
}
100412fc:	46c0      	nop			@ (mov r8, r8)
100412fe:	46c0      	nop			@ (mov r8, r8)
10041300:	46bd      	mov	sp, r7
10041302:	b004      	add	sp, #16
10041304:	bd80      	pop	{r7, pc}
10041306:	46c0      	nop			@ (mov r8, r8)
10041308:	200002f8 	.word	0x200002f8

1004130c <__NVIC_EnableIRQ>:
{
1004130c:	b580      	push	{r7, lr}
1004130e:	b082      	sub	sp, #8
10041310:	af00      	add	r7, sp, #0
10041312:	0002      	movs	r2, r0
10041314:	1dfb      	adds	r3, r7, #7
10041316:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041318:	1dfb      	adds	r3, r7, #7
1004131a:	781b      	ldrb	r3, [r3, #0]
1004131c:	2b7f      	cmp	r3, #127	@ 0x7f
1004131e:	d809      	bhi.n	10041334 <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10041320:	1dfb      	adds	r3, r7, #7
10041322:	781b      	ldrb	r3, [r3, #0]
10041324:	001a      	movs	r2, r3
10041326:	231f      	movs	r3, #31
10041328:	401a      	ands	r2, r3
1004132a:	4b04      	ldr	r3, [pc, #16]	@ (1004133c <__NVIC_EnableIRQ+0x30>)
1004132c:	2101      	movs	r1, #1
1004132e:	4091      	lsls	r1, r2
10041330:	000a      	movs	r2, r1
10041332:	601a      	str	r2, [r3, #0]
}
10041334:	46c0      	nop			@ (mov r8, r8)
10041336:	46bd      	mov	sp, r7
10041338:	b002      	add	sp, #8
1004133a:	bd80      	pop	{r7, pc}
1004133c:	e000e100 	.word	0xe000e100

10041340 <__NVIC_SetPriority>:
{
10041340:	b590      	push	{r4, r7, lr}
10041342:	b083      	sub	sp, #12
10041344:	af00      	add	r7, sp, #0
10041346:	0002      	movs	r2, r0
10041348:	6039      	str	r1, [r7, #0]
1004134a:	1dfb      	adds	r3, r7, #7
1004134c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
1004134e:	1dfb      	adds	r3, r7, #7
10041350:	781b      	ldrb	r3, [r3, #0]
10041352:	2b7f      	cmp	r3, #127	@ 0x7f
10041354:	d828      	bhi.n	100413a8 <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041356:	4a2f      	ldr	r2, [pc, #188]	@ (10041414 <__NVIC_SetPriority+0xd4>)
10041358:	1dfb      	adds	r3, r7, #7
1004135a:	781b      	ldrb	r3, [r3, #0]
1004135c:	b25b      	sxtb	r3, r3
1004135e:	089b      	lsrs	r3, r3, #2
10041360:	33c0      	adds	r3, #192	@ 0xc0
10041362:	009b      	lsls	r3, r3, #2
10041364:	589b      	ldr	r3, [r3, r2]
10041366:	1dfa      	adds	r2, r7, #7
10041368:	7812      	ldrb	r2, [r2, #0]
1004136a:	0011      	movs	r1, r2
1004136c:	2203      	movs	r2, #3
1004136e:	400a      	ands	r2, r1
10041370:	00d2      	lsls	r2, r2, #3
10041372:	21ff      	movs	r1, #255	@ 0xff
10041374:	4091      	lsls	r1, r2
10041376:	000a      	movs	r2, r1
10041378:	43d2      	mvns	r2, r2
1004137a:	401a      	ands	r2, r3
1004137c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1004137e:	683b      	ldr	r3, [r7, #0]
10041380:	019b      	lsls	r3, r3, #6
10041382:	22ff      	movs	r2, #255	@ 0xff
10041384:	401a      	ands	r2, r3
10041386:	1dfb      	adds	r3, r7, #7
10041388:	781b      	ldrb	r3, [r3, #0]
1004138a:	0018      	movs	r0, r3
1004138c:	2303      	movs	r3, #3
1004138e:	4003      	ands	r3, r0
10041390:	00db      	lsls	r3, r3, #3
10041392:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041394:	481f      	ldr	r0, [pc, #124]	@ (10041414 <__NVIC_SetPriority+0xd4>)
10041396:	1dfb      	adds	r3, r7, #7
10041398:	781b      	ldrb	r3, [r3, #0]
1004139a:	b25b      	sxtb	r3, r3
1004139c:	089b      	lsrs	r3, r3, #2
1004139e:	430a      	orrs	r2, r1
100413a0:	33c0      	adds	r3, #192	@ 0xc0
100413a2:	009b      	lsls	r3, r3, #2
100413a4:	501a      	str	r2, [r3, r0]
}
100413a6:	e031      	b.n	1004140c <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100413a8:	4a1b      	ldr	r2, [pc, #108]	@ (10041418 <__NVIC_SetPriority+0xd8>)
100413aa:	1dfb      	adds	r3, r7, #7
100413ac:	781b      	ldrb	r3, [r3, #0]
100413ae:	0019      	movs	r1, r3
100413b0:	230f      	movs	r3, #15
100413b2:	400b      	ands	r3, r1
100413b4:	3b08      	subs	r3, #8
100413b6:	089b      	lsrs	r3, r3, #2
100413b8:	3306      	adds	r3, #6
100413ba:	009b      	lsls	r3, r3, #2
100413bc:	18d3      	adds	r3, r2, r3
100413be:	3304      	adds	r3, #4
100413c0:	681b      	ldr	r3, [r3, #0]
100413c2:	1dfa      	adds	r2, r7, #7
100413c4:	7812      	ldrb	r2, [r2, #0]
100413c6:	0011      	movs	r1, r2
100413c8:	2203      	movs	r2, #3
100413ca:	400a      	ands	r2, r1
100413cc:	00d2      	lsls	r2, r2, #3
100413ce:	21ff      	movs	r1, #255	@ 0xff
100413d0:	4091      	lsls	r1, r2
100413d2:	000a      	movs	r2, r1
100413d4:	43d2      	mvns	r2, r2
100413d6:	401a      	ands	r2, r3
100413d8:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100413da:	683b      	ldr	r3, [r7, #0]
100413dc:	019b      	lsls	r3, r3, #6
100413de:	22ff      	movs	r2, #255	@ 0xff
100413e0:	401a      	ands	r2, r3
100413e2:	1dfb      	adds	r3, r7, #7
100413e4:	781b      	ldrb	r3, [r3, #0]
100413e6:	0018      	movs	r0, r3
100413e8:	2303      	movs	r3, #3
100413ea:	4003      	ands	r3, r0
100413ec:	00db      	lsls	r3, r3, #3
100413ee:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100413f0:	4809      	ldr	r0, [pc, #36]	@ (10041418 <__NVIC_SetPriority+0xd8>)
100413f2:	1dfb      	adds	r3, r7, #7
100413f4:	781b      	ldrb	r3, [r3, #0]
100413f6:	001c      	movs	r4, r3
100413f8:	230f      	movs	r3, #15
100413fa:	4023      	ands	r3, r4
100413fc:	3b08      	subs	r3, #8
100413fe:	089b      	lsrs	r3, r3, #2
10041400:	430a      	orrs	r2, r1
10041402:	3306      	adds	r3, #6
10041404:	009b      	lsls	r3, r3, #2
10041406:	18c3      	adds	r3, r0, r3
10041408:	3304      	adds	r3, #4
1004140a:	601a      	str	r2, [r3, #0]
}
1004140c:	46c0      	nop			@ (mov r8, r8)
1004140e:	46bd      	mov	sp, r7
10041410:	b003      	add	sp, #12
10041412:	bd90      	pop	{r4, r7, pc}
10041414:	e000e100 	.word	0xe000e100
10041418:	e000ed00 	.word	0xe000ed00

1004141c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
1004141c:	b580      	push	{r7, lr}
1004141e:	b082      	sub	sp, #8
10041420:	af00      	add	r7, sp, #0
10041422:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
10041424:	687b      	ldr	r3, [r7, #4]
10041426:	1e5a      	subs	r2, r3, #1
10041428:	2380      	movs	r3, #128	@ 0x80
1004142a:	045b      	lsls	r3, r3, #17
1004142c:	429a      	cmp	r2, r3
1004142e:	d301      	bcc.n	10041434 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
10041430:	2301      	movs	r3, #1
10041432:	e010      	b.n	10041456 <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
10041434:	4b0a      	ldr	r3, [pc, #40]	@ (10041460 <SysTick_Config+0x44>)
10041436:	687a      	ldr	r2, [r7, #4]
10041438:	3a01      	subs	r2, #1
1004143a:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
1004143c:	2301      	movs	r3, #1
1004143e:	425b      	negs	r3, r3
10041440:	2103      	movs	r1, #3
10041442:	0018      	movs	r0, r3
10041444:	f7ff ff7c 	bl	10041340 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
10041448:	4b05      	ldr	r3, [pc, #20]	@ (10041460 <SysTick_Config+0x44>)
1004144a:	2200      	movs	r2, #0
1004144c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
1004144e:	4b04      	ldr	r3, [pc, #16]	@ (10041460 <SysTick_Config+0x44>)
10041450:	2207      	movs	r2, #7
10041452:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
10041454:	2300      	movs	r3, #0
}
10041456:	0018      	movs	r0, r3
10041458:	46bd      	mov	sp, r7
1004145a:	b002      	add	sp, #8
1004145c:	bd80      	pop	{r7, pc}
1004145e:	46c0      	nop			@ (mov r8, r8)
10041460:	e000e010 	.word	0xe000e010

10041464 <HAL_NVIC_SetPriority>:
  *         with stm32wb0x devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
10041464:	b580      	push	{r7, lr}
10041466:	b084      	sub	sp, #16
10041468:	af00      	add	r7, sp, #0
1004146a:	60b9      	str	r1, [r7, #8]
1004146c:	607a      	str	r2, [r7, #4]
1004146e:	210f      	movs	r1, #15
10041470:	187b      	adds	r3, r7, r1
10041472:	1c02      	adds	r2, r0, #0
10041474:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
10041476:	68ba      	ldr	r2, [r7, #8]
10041478:	187b      	adds	r3, r7, r1
1004147a:	781b      	ldrb	r3, [r3, #0]
1004147c:	b25b      	sxtb	r3, r3
1004147e:	0011      	movs	r1, r2
10041480:	0018      	movs	r0, r3
10041482:	f7ff ff5d 	bl	10041340 <__NVIC_SetPriority>
}
10041486:	46c0      	nop			@ (mov r8, r8)
10041488:	46bd      	mov	sp, r7
1004148a:	b004      	add	sp, #16
1004148c:	bd80      	pop	{r7, pc}

1004148e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file)
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
1004148e:	b580      	push	{r7, lr}
10041490:	b082      	sub	sp, #8
10041492:	af00      	add	r7, sp, #0
10041494:	0002      	movs	r2, r0
10041496:	1dfb      	adds	r3, r7, #7
10041498:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
1004149a:	1dfb      	adds	r3, r7, #7
1004149c:	781b      	ldrb	r3, [r3, #0]
1004149e:	b25b      	sxtb	r3, r3
100414a0:	0018      	movs	r0, r3
100414a2:	f7ff ff33 	bl	1004130c <__NVIC_EnableIRQ>
}
100414a6:	46c0      	nop			@ (mov r8, r8)
100414a8:	46bd      	mov	sp, r7
100414aa:	b002      	add	sp, #8
100414ac:	bd80      	pop	{r7, pc}

100414ae <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
100414ae:	b580      	push	{r7, lr}
100414b0:	b082      	sub	sp, #8
100414b2:	af00      	add	r7, sp, #0
100414b4:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
100414b6:	687b      	ldr	r3, [r7, #4]
100414b8:	0018      	movs	r0, r3
100414ba:	f7ff ffaf 	bl	1004141c <SysTick_Config>
100414be:	0003      	movs	r3, r0
}
100414c0:	0018      	movs	r0, r3
100414c2:	46bd      	mov	sp, r7
100414c4:	b002      	add	sp, #8
100414c6:	bd80      	pop	{r7, pc}

100414c8 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
100414c8:	b580      	push	{r7, lr}
100414ca:	b086      	sub	sp, #24
100414cc:	af00      	add	r7, sp, #0
100414ce:	6078      	str	r0, [r7, #4]
100414d0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
100414d2:	2300      	movs	r3, #0
100414d4:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
100414d6:	e194      	b.n	10041802 <HAL_GPIO_Init+0x33a>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
100414d8:	683b      	ldr	r3, [r7, #0]
100414da:	681b      	ldr	r3, [r3, #0]
100414dc:	2101      	movs	r1, #1
100414de:	697a      	ldr	r2, [r7, #20]
100414e0:	4091      	lsls	r1, r2
100414e2:	000a      	movs	r2, r1
100414e4:	4013      	ands	r3, r2
100414e6:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
100414e8:	68fb      	ldr	r3, [r7, #12]
100414ea:	2b00      	cmp	r3, #0
100414ec:	d100      	bne.n	100414f0 <HAL_GPIO_Init+0x28>
100414ee:	e185      	b.n	100417fc <HAL_GPIO_Init+0x334>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
100414f0:	683b      	ldr	r3, [r7, #0]
100414f2:	685b      	ldr	r3, [r3, #4]
100414f4:	2203      	movs	r2, #3
100414f6:	4013      	ands	r3, r2
100414f8:	2b01      	cmp	r3, #1
100414fa:	d005      	beq.n	10041508 <HAL_GPIO_Init+0x40>
100414fc:	683b      	ldr	r3, [r7, #0]
100414fe:	685b      	ldr	r3, [r3, #4]
10041500:	2203      	movs	r2, #3
10041502:	4013      	ands	r3, r2
10041504:	2b02      	cmp	r3, #2
10041506:	d130      	bne.n	1004156a <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
10041508:	687b      	ldr	r3, [r7, #4]
1004150a:	689b      	ldr	r3, [r3, #8]
1004150c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
1004150e:	697b      	ldr	r3, [r7, #20]
10041510:	005b      	lsls	r3, r3, #1
10041512:	2203      	movs	r2, #3
10041514:	409a      	lsls	r2, r3
10041516:	0013      	movs	r3, r2
10041518:	43da      	mvns	r2, r3
1004151a:	693b      	ldr	r3, [r7, #16]
1004151c:	4013      	ands	r3, r2
1004151e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
10041520:	683b      	ldr	r3, [r7, #0]
10041522:	68da      	ldr	r2, [r3, #12]
10041524:	697b      	ldr	r3, [r7, #20]
10041526:	005b      	lsls	r3, r3, #1
10041528:	409a      	lsls	r2, r3
1004152a:	0013      	movs	r3, r2
1004152c:	693a      	ldr	r2, [r7, #16]
1004152e:	4313      	orrs	r3, r2
10041530:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
10041532:	687b      	ldr	r3, [r7, #4]
10041534:	693a      	ldr	r2, [r7, #16]
10041536:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
10041538:	687b      	ldr	r3, [r7, #4]
1004153a:	685b      	ldr	r3, [r3, #4]
1004153c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
1004153e:	2201      	movs	r2, #1
10041540:	697b      	ldr	r3, [r7, #20]
10041542:	409a      	lsls	r2, r3
10041544:	0013      	movs	r3, r2
10041546:	43da      	mvns	r2, r3
10041548:	693b      	ldr	r3, [r7, #16]
1004154a:	4013      	ands	r3, r2
1004154c:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
1004154e:	683b      	ldr	r3, [r7, #0]
10041550:	685b      	ldr	r3, [r3, #4]
10041552:	091b      	lsrs	r3, r3, #4
10041554:	2201      	movs	r2, #1
10041556:	401a      	ands	r2, r3
10041558:	697b      	ldr	r3, [r7, #20]
1004155a:	409a      	lsls	r2, r3
1004155c:	0013      	movs	r3, r2
1004155e:	693a      	ldr	r2, [r7, #16]
10041560:	4313      	orrs	r3, r2
10041562:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
10041564:	687b      	ldr	r3, [r7, #4]
10041566:	693a      	ldr	r2, [r7, #16]
10041568:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
1004156a:	683b      	ldr	r3, [r7, #0]
1004156c:	685b      	ldr	r3, [r3, #4]
1004156e:	2203      	movs	r2, #3
10041570:	4013      	ands	r3, r2
10041572:	2b03      	cmp	r3, #3
10041574:	d017      	beq.n	100415a6 <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
10041576:	687b      	ldr	r3, [r7, #4]
10041578:	68db      	ldr	r3, [r3, #12]
1004157a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
1004157c:	697b      	ldr	r3, [r7, #20]
1004157e:	005b      	lsls	r3, r3, #1
10041580:	2203      	movs	r2, #3
10041582:	409a      	lsls	r2, r3
10041584:	0013      	movs	r3, r2
10041586:	43da      	mvns	r2, r3
10041588:	693b      	ldr	r3, [r7, #16]
1004158a:	4013      	ands	r3, r2
1004158c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
1004158e:	683b      	ldr	r3, [r7, #0]
10041590:	689a      	ldr	r2, [r3, #8]
10041592:	697b      	ldr	r3, [r7, #20]
10041594:	005b      	lsls	r3, r3, #1
10041596:	409a      	lsls	r2, r3
10041598:	0013      	movs	r3, r2
1004159a:	693a      	ldr	r2, [r7, #16]
1004159c:	4313      	orrs	r3, r2
1004159e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
100415a0:	687b      	ldr	r3, [r7, #4]
100415a2:	693a      	ldr	r2, [r7, #16]
100415a4:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
100415a6:	683b      	ldr	r3, [r7, #0]
100415a8:	685b      	ldr	r3, [r3, #4]
100415aa:	2203      	movs	r2, #3
100415ac:	4013      	ands	r3, r2
100415ae:	2b02      	cmp	r3, #2
100415b0:	d123      	bne.n	100415fa <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
100415b2:	697b      	ldr	r3, [r7, #20]
100415b4:	08da      	lsrs	r2, r3, #3
100415b6:	687b      	ldr	r3, [r7, #4]
100415b8:	3208      	adds	r2, #8
100415ba:	0092      	lsls	r2, r2, #2
100415bc:	58d3      	ldr	r3, [r2, r3]
100415be:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
100415c0:	697b      	ldr	r3, [r7, #20]
100415c2:	2207      	movs	r2, #7
100415c4:	4013      	ands	r3, r2
100415c6:	009b      	lsls	r3, r3, #2
100415c8:	220f      	movs	r2, #15
100415ca:	409a      	lsls	r2, r3
100415cc:	0013      	movs	r3, r2
100415ce:	43da      	mvns	r2, r3
100415d0:	693b      	ldr	r3, [r7, #16]
100415d2:	4013      	ands	r3, r2
100415d4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
100415d6:	683b      	ldr	r3, [r7, #0]
100415d8:	691a      	ldr	r2, [r3, #16]
100415da:	697b      	ldr	r3, [r7, #20]
100415dc:	2107      	movs	r1, #7
100415de:	400b      	ands	r3, r1
100415e0:	009b      	lsls	r3, r3, #2
100415e2:	409a      	lsls	r2, r3
100415e4:	0013      	movs	r3, r2
100415e6:	693a      	ldr	r2, [r7, #16]
100415e8:	4313      	orrs	r3, r2
100415ea:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
100415ec:	697b      	ldr	r3, [r7, #20]
100415ee:	08da      	lsrs	r2, r3, #3
100415f0:	687b      	ldr	r3, [r7, #4]
100415f2:	3208      	adds	r2, #8
100415f4:	0092      	lsls	r2, r2, #2
100415f6:	6939      	ldr	r1, [r7, #16]
100415f8:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
100415fa:	687b      	ldr	r3, [r7, #4]
100415fc:	681b      	ldr	r3, [r3, #0]
100415fe:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
10041600:	697b      	ldr	r3, [r7, #20]
10041602:	005b      	lsls	r3, r3, #1
10041604:	2203      	movs	r2, #3
10041606:	409a      	lsls	r2, r3
10041608:	0013      	movs	r3, r2
1004160a:	43da      	mvns	r2, r3
1004160c:	693b      	ldr	r3, [r7, #16]
1004160e:	4013      	ands	r3, r2
10041610:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
10041612:	683b      	ldr	r3, [r7, #0]
10041614:	685b      	ldr	r3, [r3, #4]
10041616:	2203      	movs	r2, #3
10041618:	401a      	ands	r2, r3
1004161a:	697b      	ldr	r3, [r7, #20]
1004161c:	005b      	lsls	r3, r3, #1
1004161e:	409a      	lsls	r2, r3
10041620:	0013      	movs	r3, r2
10041622:	693a      	ldr	r2, [r7, #16]
10041624:	4313      	orrs	r3, r2
10041626:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
10041628:	687b      	ldr	r3, [r7, #4]
1004162a:	693a      	ldr	r2, [r7, #16]
1004162c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
1004162e:	683b      	ldr	r3, [r7, #0]
10041630:	685a      	ldr	r2, [r3, #4]
10041632:	23c0      	movs	r3, #192	@ 0xc0
10041634:	029b      	lsls	r3, r3, #10
10041636:	4013      	ands	r3, r2
10041638:	d100      	bne.n	1004163c <HAL_GPIO_Init+0x174>
1004163a:	e0df      	b.n	100417fc <HAL_GPIO_Init+0x334>
      {

        /* Edge/Level line configuration */
        if ((GPIO_Init->Mode & DETECTION_TYPE) != 0x00u)
1004163c:	683b      	ldr	r3, [r7, #0]
1004163e:	685a      	ldr	r2, [r3, #4]
10041640:	2380      	movs	r3, #128	@ 0x80
10041642:	02db      	lsls	r3, r3, #11
10041644:	4013      	ands	r3, r2
10041646:	d031      	beq.n	100416ac <HAL_GPIO_Init+0x1e4>
        {
          temp = SYSCFG->IO_DTR;
10041648:	2380      	movs	r3, #128	@ 0x80
1004164a:	05db      	lsls	r3, r3, #23
1004164c:	68db      	ldr	r3, [r3, #12]
1004164e:	613b      	str	r3, [r7, #16]
          if (GPIOx == GPIOA)
10041650:	687a      	ldr	r2, [r7, #4]
10041652:	2390      	movs	r3, #144	@ 0x90
10041654:	05db      	lsls	r3, r3, #23
10041656:	429a      	cmp	r2, r3
10041658:	d111      	bne.n	1004167e <HAL_GPIO_Init+0x1b6>
          {
            temp &= ~(1 << position);
1004165a:	2201      	movs	r2, #1
1004165c:	697b      	ldr	r3, [r7, #20]
1004165e:	409a      	lsls	r2, r3
10041660:	0013      	movs	r3, r2
10041662:	43db      	mvns	r3, r3
10041664:	001a      	movs	r2, r3
10041666:	693b      	ldr	r3, [r7, #16]
10041668:	4013      	ands	r3, r2
1004166a:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
1004166c:	2201      	movs	r2, #1
1004166e:	697b      	ldr	r3, [r7, #20]
10041670:	409a      	lsls	r2, r3
10041672:	0013      	movs	r3, r2
10041674:	001a      	movs	r2, r3
10041676:	693b      	ldr	r3, [r7, #16]
10041678:	4313      	orrs	r3, r2
1004167a:	613b      	str	r3, [r7, #16]
1004167c:	e012      	b.n	100416a4 <HAL_GPIO_Init+0x1dc>
          }
          else
          {
            temp &= ~((1 << position) << 16);
1004167e:	2201      	movs	r2, #1
10041680:	697b      	ldr	r3, [r7, #20]
10041682:	409a      	lsls	r2, r3
10041684:	0013      	movs	r3, r2
10041686:	041b      	lsls	r3, r3, #16
10041688:	43db      	mvns	r3, r3
1004168a:	001a      	movs	r2, r3
1004168c:	693b      	ldr	r3, [r7, #16]
1004168e:	4013      	ands	r3, r2
10041690:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041692:	2201      	movs	r2, #1
10041694:	697b      	ldr	r3, [r7, #20]
10041696:	409a      	lsls	r2, r3
10041698:	0013      	movs	r3, r2
1004169a:	041b      	lsls	r3, r3, #16
1004169c:	001a      	movs	r2, r3
1004169e:	693b      	ldr	r3, [r7, #16]
100416a0:	4313      	orrs	r3, r2
100416a2:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_DTR = temp;
100416a4:	2380      	movs	r3, #128	@ 0x80
100416a6:	05db      	lsls	r3, r3, #23
100416a8:	693a      	ldr	r2, [r7, #16]
100416aa:	60da      	str	r2, [r3, #12]
        }

		/* Edge selection configuration */
		if ((GPIO_Init->Mode & EDGE_SELECTION) != 0x00u)
100416ac:	683b      	ldr	r3, [r7, #0]
100416ae:	685a      	ldr	r2, [r3, #4]
100416b0:	2380      	movs	r3, #128	@ 0x80
100416b2:	035b      	lsls	r3, r3, #13
100416b4:	4013      	ands	r3, r2
100416b6:	d031      	beq.n	1004171c <HAL_GPIO_Init+0x254>
        {
          temp = SYSCFG->IO_IBER;
100416b8:	2380      	movs	r3, #128	@ 0x80
100416ba:	05db      	lsls	r3, r3, #23
100416bc:	691b      	ldr	r3, [r3, #16]
100416be:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
100416c0:	687a      	ldr	r2, [r7, #4]
100416c2:	2390      	movs	r3, #144	@ 0x90
100416c4:	05db      	lsls	r3, r3, #23
100416c6:	429a      	cmp	r2, r3
100416c8:	d111      	bne.n	100416ee <HAL_GPIO_Init+0x226>
          {
            temp &= ~(1 << position);
100416ca:	2201      	movs	r2, #1
100416cc:	697b      	ldr	r3, [r7, #20]
100416ce:	409a      	lsls	r2, r3
100416d0:	0013      	movs	r3, r2
100416d2:	43db      	mvns	r3, r3
100416d4:	001a      	movs	r2, r3
100416d6:	693b      	ldr	r3, [r7, #16]
100416d8:	4013      	ands	r3, r2
100416da:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
100416dc:	2201      	movs	r2, #1
100416de:	697b      	ldr	r3, [r7, #20]
100416e0:	409a      	lsls	r2, r3
100416e2:	0013      	movs	r3, r2
100416e4:	001a      	movs	r2, r3
100416e6:	693b      	ldr	r3, [r7, #16]
100416e8:	4313      	orrs	r3, r2
100416ea:	613b      	str	r3, [r7, #16]
100416ec:	e012      	b.n	10041714 <HAL_GPIO_Init+0x24c>
          }
          else
          {
            temp &= ~((1 << position) << 16);
100416ee:	2201      	movs	r2, #1
100416f0:	697b      	ldr	r3, [r7, #20]
100416f2:	409a      	lsls	r2, r3
100416f4:	0013      	movs	r3, r2
100416f6:	041b      	lsls	r3, r3, #16
100416f8:	43db      	mvns	r3, r3
100416fa:	001a      	movs	r2, r3
100416fc:	693b      	ldr	r3, [r7, #16]
100416fe:	4013      	ands	r3, r2
10041700:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041702:	2201      	movs	r2, #1
10041704:	697b      	ldr	r3, [r7, #20]
10041706:	409a      	lsls	r2, r3
10041708:	0013      	movs	r3, r2
1004170a:	041b      	lsls	r3, r3, #16
1004170c:	001a      	movs	r2, r3
1004170e:	693b      	ldr	r3, [r7, #16]
10041710:	4313      	orrs	r3, r2
10041712:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IBER= temp;
10041714:	2380      	movs	r3, #128	@ 0x80
10041716:	05db      	lsls	r3, r3, #23
10041718:	693a      	ldr	r2, [r7, #16]
1004171a:	611a      	str	r2, [r3, #16]
        }

        /* Trigger mode configuration */
		if ((GPIO_Init->Mode & TRIGGER_MODE) != 0x00u)
1004171c:	683b      	ldr	r3, [r7, #0]
1004171e:	685a      	ldr	r2, [r3, #4]
10041720:	2380      	movs	r3, #128	@ 0x80
10041722:	03db      	lsls	r3, r3, #15
10041724:	4013      	ands	r3, r2
10041726:	d031      	beq.n	1004178c <HAL_GPIO_Init+0x2c4>
        {
          temp = SYSCFG->IO_IEVR;
10041728:	2380      	movs	r3, #128	@ 0x80
1004172a:	05db      	lsls	r3, r3, #23
1004172c:	695b      	ldr	r3, [r3, #20]
1004172e:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041730:	687a      	ldr	r2, [r7, #4]
10041732:	2390      	movs	r3, #144	@ 0x90
10041734:	05db      	lsls	r3, r3, #23
10041736:	429a      	cmp	r2, r3
10041738:	d111      	bne.n	1004175e <HAL_GPIO_Init+0x296>
          {
            temp &= ~(1 << position);
1004173a:	2201      	movs	r2, #1
1004173c:	697b      	ldr	r3, [r7, #20]
1004173e:	409a      	lsls	r2, r3
10041740:	0013      	movs	r3, r2
10041742:	43db      	mvns	r3, r3
10041744:	001a      	movs	r2, r3
10041746:	693b      	ldr	r3, [r7, #16]
10041748:	4013      	ands	r3, r2
1004174a:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
1004174c:	2201      	movs	r2, #1
1004174e:	697b      	ldr	r3, [r7, #20]
10041750:	409a      	lsls	r2, r3
10041752:	0013      	movs	r3, r2
10041754:	001a      	movs	r2, r3
10041756:	693b      	ldr	r3, [r7, #16]
10041758:	4313      	orrs	r3, r2
1004175a:	613b      	str	r3, [r7, #16]
1004175c:	e012      	b.n	10041784 <HAL_GPIO_Init+0x2bc>
          }
          else
          {
            temp &= ~((1 << position) << 16);
1004175e:	2201      	movs	r2, #1
10041760:	697b      	ldr	r3, [r7, #20]
10041762:	409a      	lsls	r2, r3
10041764:	0013      	movs	r3, r2
10041766:	041b      	lsls	r3, r3, #16
10041768:	43db      	mvns	r3, r3
1004176a:	001a      	movs	r2, r3
1004176c:	693b      	ldr	r3, [r7, #16]
1004176e:	4013      	ands	r3, r2
10041770:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041772:	2201      	movs	r2, #1
10041774:	697b      	ldr	r3, [r7, #20]
10041776:	409a      	lsls	r2, r3
10041778:	0013      	movs	r3, r2
1004177a:	041b      	lsls	r3, r3, #16
1004177c:	001a      	movs	r2, r3
1004177e:	693b      	ldr	r3, [r7, #16]
10041780:	4313      	orrs	r3, r2
10041782:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IEVR= temp;
10041784:	2380      	movs	r3, #128	@ 0x80
10041786:	05db      	lsls	r3, r3, #23
10041788:	693a      	ldr	r2, [r7, #16]
1004178a:	615a      	str	r2, [r3, #20]
        }

        /* Enable the specified EXTI interrupt line */
        if ((GPIO_Init->Mode & EXTI_IT) == EXTI_IT)
1004178c:	683b      	ldr	r3, [r7, #0]
1004178e:	685a      	ldr	r2, [r3, #4]
10041790:	2380      	movs	r3, #128	@ 0x80
10041792:	025b      	lsls	r3, r3, #9
10041794:	4013      	ands	r3, r2
10041796:	d031      	beq.n	100417fc <HAL_GPIO_Init+0x334>
        {
          temp = SYSCFG->IO_IER;
10041798:	2380      	movs	r3, #128	@ 0x80
1004179a:	05db      	lsls	r3, r3, #23
1004179c:	699b      	ldr	r3, [r3, #24]
1004179e:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
100417a0:	687a      	ldr	r2, [r7, #4]
100417a2:	2390      	movs	r3, #144	@ 0x90
100417a4:	05db      	lsls	r3, r3, #23
100417a6:	429a      	cmp	r2, r3
100417a8:	d111      	bne.n	100417ce <HAL_GPIO_Init+0x306>
          {
            temp &= ~(1 << position);
100417aa:	2201      	movs	r2, #1
100417ac:	697b      	ldr	r3, [r7, #20]
100417ae:	409a      	lsls	r2, r3
100417b0:	0013      	movs	r3, r2
100417b2:	43db      	mvns	r3, r3
100417b4:	001a      	movs	r2, r3
100417b6:	693b      	ldr	r3, [r7, #16]
100417b8:	4013      	ands	r3, r2
100417ba:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
100417bc:	2201      	movs	r2, #1
100417be:	697b      	ldr	r3, [r7, #20]
100417c0:	409a      	lsls	r2, r3
100417c2:	0013      	movs	r3, r2
100417c4:	001a      	movs	r2, r3
100417c6:	693b      	ldr	r3, [r7, #16]
100417c8:	4313      	orrs	r3, r2
100417ca:	613b      	str	r3, [r7, #16]
100417cc:	e012      	b.n	100417f4 <HAL_GPIO_Init+0x32c>
          }
          else
          {
            temp &= ~((1 << position) << 16);
100417ce:	2201      	movs	r2, #1
100417d0:	697b      	ldr	r3, [r7, #20]
100417d2:	409a      	lsls	r2, r3
100417d4:	0013      	movs	r3, r2
100417d6:	041b      	lsls	r3, r3, #16
100417d8:	43db      	mvns	r3, r3
100417da:	001a      	movs	r2, r3
100417dc:	693b      	ldr	r3, [r7, #16]
100417de:	4013      	ands	r3, r2
100417e0:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
100417e2:	2201      	movs	r2, #1
100417e4:	697b      	ldr	r3, [r7, #20]
100417e6:	409a      	lsls	r2, r3
100417e8:	0013      	movs	r3, r2
100417ea:	041b      	lsls	r3, r3, #16
100417ec:	001a      	movs	r2, r3
100417ee:	693b      	ldr	r3, [r7, #16]
100417f0:	4313      	orrs	r3, r2
100417f2:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IER= temp;
100417f4:	2380      	movs	r3, #128	@ 0x80
100417f6:	05db      	lsls	r3, r3, #23
100417f8:	693a      	ldr	r2, [r7, #16]
100417fa:	619a      	str	r2, [r3, #24]
        }
      }
    }

    position++;
100417fc:	697b      	ldr	r3, [r7, #20]
100417fe:	3301      	adds	r3, #1
10041800:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
10041802:	683b      	ldr	r3, [r7, #0]
10041804:	681a      	ldr	r2, [r3, #0]
10041806:	697b      	ldr	r3, [r7, #20]
10041808:	40da      	lsrs	r2, r3
1004180a:	1e13      	subs	r3, r2, #0
1004180c:	d000      	beq.n	10041810 <HAL_GPIO_Init+0x348>
1004180e:	e663      	b.n	100414d8 <HAL_GPIO_Init+0x10>
  }
}
10041810:	46c0      	nop			@ (mov r8, r8)
10041812:	46c0      	nop			@ (mov r8, r8)
10041814:	46bd      	mov	sp, r7
10041816:	b006      	add	sp, #24
10041818:	bd80      	pop	{r7, pc}

1004181a <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
1004181a:	b580      	push	{r7, lr}
1004181c:	b082      	sub	sp, #8
1004181e:	af00      	add	r7, sp, #0
10041820:	6078      	str	r0, [r7, #4]
10041822:	0008      	movs	r0, r1
10041824:	0011      	movs	r1, r2
10041826:	1cbb      	adds	r3, r7, #2
10041828:	1c02      	adds	r2, r0, #0
1004182a:	801a      	strh	r2, [r3, #0]
1004182c:	1c7b      	adds	r3, r7, #1
1004182e:	1c0a      	adds	r2, r1, #0
10041830:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
10041832:	1c7b      	adds	r3, r7, #1
10041834:	781b      	ldrb	r3, [r3, #0]
10041836:	2b00      	cmp	r3, #0
10041838:	d004      	beq.n	10041844 <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
1004183a:	1cbb      	adds	r3, r7, #2
1004183c:	881a      	ldrh	r2, [r3, #0]
1004183e:	687b      	ldr	r3, [r7, #4]
10041840:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
10041842:	e003      	b.n	1004184c <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
10041844:	1cbb      	adds	r3, r7, #2
10041846:	881a      	ldrh	r2, [r3, #0]
10041848:	687b      	ldr	r3, [r7, #4]
1004184a:	629a      	str	r2, [r3, #40]	@ 0x28
}
1004184c:	46c0      	nop			@ (mov r8, r8)
1004184e:	46bd      	mov	sp, r7
10041850:	b002      	add	sp, #8
10041852:	bd80      	pop	{r7, pc}

10041854 <HAL_GPIO_TogglePin>:
  * @param GPIOx where x can be (A..B) to select the GPIO peripheral for STM32WB0x family
  * @param GPIO_Pin specifies the pin to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
10041854:	b580      	push	{r7, lr}
10041856:	b084      	sub	sp, #16
10041858:	af00      	add	r7, sp, #0
1004185a:	6078      	str	r0, [r7, #4]
1004185c:	000a      	movs	r2, r1
1004185e:	1cbb      	adds	r3, r7, #2
10041860:	801a      	strh	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
10041862:	687b      	ldr	r3, [r7, #4]
10041864:	695b      	ldr	r3, [r3, #20]
10041866:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
10041868:	1cbb      	adds	r3, r7, #2
1004186a:	881b      	ldrh	r3, [r3, #0]
1004186c:	68fa      	ldr	r2, [r7, #12]
1004186e:	4013      	ands	r3, r2
10041870:	041a      	lsls	r2, r3, #16
10041872:	68fb      	ldr	r3, [r7, #12]
10041874:	43db      	mvns	r3, r3
10041876:	1cb9      	adds	r1, r7, #2
10041878:	8809      	ldrh	r1, [r1, #0]
1004187a:	400b      	ands	r3, r1
1004187c:	431a      	orrs	r2, r3
1004187e:	687b      	ldr	r3, [r7, #4]
10041880:	619a      	str	r2, [r3, #24]
}
10041882:	46c0      	nop			@ (mov r8, r8)
10041884:	46bd      	mov	sp, r7
10041886:	b004      	add	sp, #16
10041888:	bd80      	pop	{r7, pc}

1004188a <HAL_GPIO_EXTI_IRQHandler>:
  * @param GPIOx where x can be (A..B) to select the GPIO peripheral
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
1004188a:	b580      	push	{r7, lr}
1004188c:	b082      	sub	sp, #8
1004188e:	af00      	add	r7, sp, #0
10041890:	6078      	str	r0, [r7, #4]
10041892:	000a      	movs	r2, r1
10041894:	1cbb      	adds	r3, r7, #2
10041896:	801a      	strh	r2, [r3, #0]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIOx, GPIO_Pin) != 0x00u)
10041898:	687a      	ldr	r2, [r7, #4]
1004189a:	2390      	movs	r3, #144	@ 0x90
1004189c:	05db      	lsls	r3, r3, #23
1004189e:	429a      	cmp	r2, r3
100418a0:	d109      	bne.n	100418b6 <HAL_GPIO_EXTI_IRQHandler+0x2c>
100418a2:	2380      	movs	r3, #128	@ 0x80
100418a4:	05db      	lsls	r3, r3, #23
100418a6:	69db      	ldr	r3, [r3, #28]
100418a8:	1cba      	adds	r2, r7, #2
100418aa:	8812      	ldrh	r2, [r2, #0]
100418ac:	4013      	ands	r3, r2
100418ae:	1e5a      	subs	r2, r3, #1
100418b0:	4193      	sbcs	r3, r2
100418b2:	b2db      	uxtb	r3, r3
100418b4:	e009      	b.n	100418ca <HAL_GPIO_EXTI_IRQHandler+0x40>
100418b6:	2380      	movs	r3, #128	@ 0x80
100418b8:	05db      	lsls	r3, r3, #23
100418ba:	69db      	ldr	r3, [r3, #28]
100418bc:	1cba      	adds	r2, r7, #2
100418be:	8812      	ldrh	r2, [r2, #0]
100418c0:	0412      	lsls	r2, r2, #16
100418c2:	4013      	ands	r3, r2
100418c4:	1e5a      	subs	r2, r3, #1
100418c6:	4193      	sbcs	r3, r2
100418c8:	b2db      	uxtb	r3, r3
100418ca:	2b00      	cmp	r3, #0
100418cc:	d017      	beq.n	100418fe <HAL_GPIO_EXTI_IRQHandler+0x74>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIOx, GPIO_Pin);
100418ce:	687a      	ldr	r2, [r7, #4]
100418d0:	2390      	movs	r3, #144	@ 0x90
100418d2:	05db      	lsls	r3, r3, #23
100418d4:	429a      	cmp	r2, r3
100418d6:	d105      	bne.n	100418e4 <HAL_GPIO_EXTI_IRQHandler+0x5a>
100418d8:	2380      	movs	r3, #128	@ 0x80
100418da:	05db      	lsls	r3, r3, #23
100418dc:	1cba      	adds	r2, r7, #2
100418de:	8812      	ldrh	r2, [r2, #0]
100418e0:	61da      	str	r2, [r3, #28]
100418e2:	e005      	b.n	100418f0 <HAL_GPIO_EXTI_IRQHandler+0x66>
100418e4:	1cbb      	adds	r3, r7, #2
100418e6:	881a      	ldrh	r2, [r3, #0]
100418e8:	2380      	movs	r3, #128	@ 0x80
100418ea:	05db      	lsls	r3, r3, #23
100418ec:	0412      	lsls	r2, r2, #16
100418ee:	61da      	str	r2, [r3, #28]
    HAL_GPIO_EXTI_Callback(GPIOx, GPIO_Pin);
100418f0:	1cbb      	adds	r3, r7, #2
100418f2:	881a      	ldrh	r2, [r3, #0]
100418f4:	687b      	ldr	r3, [r7, #4]
100418f6:	0011      	movs	r1, r2
100418f8:	0018      	movs	r0, r3
100418fa:	f7fe fed9 	bl	100406b0 <HAL_GPIO_EXTI_Callback>
  }
}
100418fe:	46c0      	nop			@ (mov r8, r8)
10041900:	46bd      	mov	sp, r7
10041902:	b002      	add	sp, #8
10041904:	bd80      	pop	{r7, pc}
	...

10041908 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
10041908:	b580      	push	{r7, lr}
1004190a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
1004190c:	4b07      	ldr	r3, [pc, #28]	@ (1004192c <LL_RCC_HSE_IsReady+0x24>)
1004190e:	681a      	ldr	r2, [r3, #0]
10041910:	2380      	movs	r3, #128	@ 0x80
10041912:	029b      	lsls	r3, r3, #10
10041914:	401a      	ands	r2, r3
10041916:	2380      	movs	r3, #128	@ 0x80
10041918:	029b      	lsls	r3, r3, #10
1004191a:	429a      	cmp	r2, r3
1004191c:	d101      	bne.n	10041922 <LL_RCC_HSE_IsReady+0x1a>
1004191e:	2301      	movs	r3, #1
10041920:	e000      	b.n	10041924 <LL_RCC_HSE_IsReady+0x1c>
10041922:	2300      	movs	r3, #0
}
10041924:	0018      	movs	r0, r3
10041926:	46bd      	mov	sp, r7
10041928:	bd80      	pop	{r7, pc}
1004192a:	46c0      	nop			@ (mov r8, r8)
1004192c:	48400000 	.word	0x48400000

10041930 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
10041930:	b580      	push	{r7, lr}
10041932:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
10041934:	4b07      	ldr	r3, [pc, #28]	@ (10041954 <LL_RCC_HSI_Enable+0x24>)
10041936:	689a      	ldr	r2, [r3, #8]
10041938:	4b06      	ldr	r3, [pc, #24]	@ (10041954 <LL_RCC_HSI_Enable+0x24>)
1004193a:	2104      	movs	r1, #4
1004193c:	438a      	bics	r2, r1
1004193e:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
10041940:	4b04      	ldr	r3, [pc, #16]	@ (10041954 <LL_RCC_HSI_Enable+0x24>)
10041942:	689a      	ldr	r2, [r3, #8]
10041944:	4b03      	ldr	r3, [pc, #12]	@ (10041954 <LL_RCC_HSI_Enable+0x24>)
10041946:	2102      	movs	r1, #2
10041948:	438a      	bics	r2, r1
1004194a:	609a      	str	r2, [r3, #8]
}
1004194c:	46c0      	nop			@ (mov r8, r8)
1004194e:	46bd      	mov	sp, r7
10041950:	bd80      	pop	{r7, pc}
10041952:	46c0      	nop			@ (mov r8, r8)
10041954:	48400000 	.word	0x48400000

10041958 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
10041958:	b580      	push	{r7, lr}
1004195a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
1004195c:	4b07      	ldr	r3, [pc, #28]	@ (1004197c <LL_RCC_HSI_IsReady+0x24>)
1004195e:	681a      	ldr	r2, [r3, #0]
10041960:	2380      	movs	r3, #128	@ 0x80
10041962:	00db      	lsls	r3, r3, #3
10041964:	401a      	ands	r2, r3
10041966:	2380      	movs	r3, #128	@ 0x80
10041968:	00db      	lsls	r3, r3, #3
1004196a:	429a      	cmp	r2, r3
1004196c:	d101      	bne.n	10041972 <LL_RCC_HSI_IsReady+0x1a>
1004196e:	2301      	movs	r3, #1
10041970:	e000      	b.n	10041974 <LL_RCC_HSI_IsReady+0x1c>
10041972:	2300      	movs	r3, #0
}
10041974:	0018      	movs	r0, r3
10041976:	46bd      	mov	sp, r7
10041978:	bd80      	pop	{r7, pc}
1004197a:	46c0      	nop			@ (mov r8, r8)
1004197c:	48400000 	.word	0x48400000

10041980 <LL_RCC_DIRECT_HSE_Enable>:
  * @brief  Enable DIRECT_HSE mode
  * @rmtoll CFGR       HSESEL/STOPHSI         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_DIRECT_HSE_Enable(void)
{
10041980:	b580      	push	{r7, lr}
10041982:	b082      	sub	sp, #8
10041984:	af00      	add	r7, sp, #0
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0);
10041986:	46c0      	nop			@ (mov r8, r8)
10041988:	4b0f      	ldr	r3, [pc, #60]	@ (100419c8 <LL_RCC_DIRECT_HSE_Enable+0x48>)
1004198a:	681a      	ldr	r2, [r3, #0]
1004198c:	2380      	movs	r3, #128	@ 0x80
1004198e:	029b      	lsls	r3, r3, #10
10041990:	4013      	ands	r3, r2
10041992:	d0f9      	beq.n	10041988 <LL_RCC_DIRECT_HSE_Enable+0x8>
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
10041994:	4b0c      	ldr	r3, [pc, #48]	@ (100419c8 <LL_RCC_DIRECT_HSE_Enable+0x48>)
10041996:	689a      	ldr	r2, [r3, #8]
10041998:	4b0b      	ldr	r3, [pc, #44]	@ (100419c8 <LL_RCC_DIRECT_HSE_Enable+0x48>)
1004199a:	2102      	movs	r1, #2
1004199c:	430a      	orrs	r2, r1
1004199e:	609a      	str	r2, [r3, #8]
  for (volatile int i = 0; i < 6; i++)
100419a0:	2300      	movs	r3, #0
100419a2:	607b      	str	r3, [r7, #4]
100419a4:	e003      	b.n	100419ae <LL_RCC_DIRECT_HSE_Enable+0x2e>
  {
    __asm("NOP");
100419a6:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
100419a8:	687b      	ldr	r3, [r7, #4]
100419aa:	3301      	adds	r3, #1
100419ac:	607b      	str	r3, [r7, #4]
100419ae:	687b      	ldr	r3, [r7, #4]
100419b0:	2b05      	cmp	r3, #5
100419b2:	ddf8      	ble.n	100419a6 <LL_RCC_DIRECT_HSE_Enable+0x26>
  }
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
100419b4:	4b04      	ldr	r3, [pc, #16]	@ (100419c8 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100419b6:	689a      	ldr	r2, [r3, #8]
100419b8:	4b03      	ldr	r3, [pc, #12]	@ (100419c8 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100419ba:	2104      	movs	r1, #4
100419bc:	430a      	orrs	r2, r1
100419be:	609a      	str	r2, [r3, #8]
}
100419c0:	46c0      	nop			@ (mov r8, r8)
100419c2:	46bd      	mov	sp, r7
100419c4:	b002      	add	sp, #8
100419c6:	bd80      	pop	{r7, pc}
100419c8:	48400000 	.word	0x48400000

100419cc <LL_RCC_RC64MPLL_Enable>:
  * @brief  Enable RC64MPLL
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Enable(void)
{
100419cc:	b580      	push	{r7, lr}
100419ce:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSIPLLON);
100419d0:	4b04      	ldr	r3, [pc, #16]	@ (100419e4 <LL_RCC_RC64MPLL_Enable+0x18>)
100419d2:	681a      	ldr	r2, [r3, #0]
100419d4:	4b03      	ldr	r3, [pc, #12]	@ (100419e4 <LL_RCC_RC64MPLL_Enable+0x18>)
100419d6:	2180      	movs	r1, #128	@ 0x80
100419d8:	0189      	lsls	r1, r1, #6
100419da:	430a      	orrs	r2, r1
100419dc:	601a      	str	r2, [r3, #0]
}
100419de:	46c0      	nop			@ (mov r8, r8)
100419e0:	46bd      	mov	sp, r7
100419e2:	bd80      	pop	{r7, pc}
100419e4:	48400000 	.word	0x48400000

100419e8 <LL_RCC_RC64MPLL_Disable>:
  * @note Cannot be disabled if the RC64MPLL clock is used as the system clock
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Disable(void)
{
100419e8:	b580      	push	{r7, lr}
100419ea:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSIPLLON);
100419ec:	4b04      	ldr	r3, [pc, #16]	@ (10041a00 <LL_RCC_RC64MPLL_Disable+0x18>)
100419ee:	681a      	ldr	r2, [r3, #0]
100419f0:	4b03      	ldr	r3, [pc, #12]	@ (10041a00 <LL_RCC_RC64MPLL_Disable+0x18>)
100419f2:	4904      	ldr	r1, [pc, #16]	@ (10041a04 <LL_RCC_RC64MPLL_Disable+0x1c>)
100419f4:	400a      	ands	r2, r1
100419f6:	601a      	str	r2, [r3, #0]
}
100419f8:	46c0      	nop			@ (mov r8, r8)
100419fa:	46bd      	mov	sp, r7
100419fc:	bd80      	pop	{r7, pc}
100419fe:	46c0      	nop			@ (mov r8, r8)
10041a00:	48400000 	.word	0x48400000
10041a04:	ffffdfff 	.word	0xffffdfff

10041a08 <LL_RCC_RC64MPLL_IsReady>:
  * @brief  Check if RC64MPLL is Ready
  * @rmtoll CR           HSIPLLRDY        LL_RCC_RC64MPLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_RC64MPLL_IsReady(void)
{
10041a08:	b580      	push	{r7, lr}
10041a0a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
10041a0c:	4b07      	ldr	r3, [pc, #28]	@ (10041a2c <LL_RCC_RC64MPLL_IsReady+0x24>)
10041a0e:	681a      	ldr	r2, [r3, #0]
10041a10:	2380      	movs	r3, #128	@ 0x80
10041a12:	01db      	lsls	r3, r3, #7
10041a14:	401a      	ands	r2, r3
10041a16:	2380      	movs	r3, #128	@ 0x80
10041a18:	01db      	lsls	r3, r3, #7
10041a1a:	429a      	cmp	r2, r3
10041a1c:	d101      	bne.n	10041a22 <LL_RCC_RC64MPLL_IsReady+0x1a>
10041a1e:	2301      	movs	r3, #1
10041a20:	e000      	b.n	10041a24 <LL_RCC_RC64MPLL_IsReady+0x1c>
10041a22:	2300      	movs	r3, #0
}
10041a24:	0018      	movs	r0, r3
10041a26:	46bd      	mov	sp, r7
10041a28:	bd80      	pop	{r7, pc}
10041a2a:	46c0      	nop			@ (mov r8, r8)
10041a2c:	48400000 	.word	0x48400000

10041a30 <LL_RCC_SetRC64MPLLPrescaler>:
  *         @arg @ref LL_RCC_RC64MPLL_DIV_32
  *         @arg @ref LL_RCC_RC64MPLL_DIV_64
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRC64MPLLPrescaler(uint32_t Prescaler)
{
10041a30:	b580      	push	{r7, lr}
10041a32:	b082      	sub	sp, #8
10041a34:	af00      	add	r7, sp, #0
10041a36:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSYSDIV, Prescaler);
10041a38:	4b06      	ldr	r3, [pc, #24]	@ (10041a54 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10041a3a:	689b      	ldr	r3, [r3, #8]
10041a3c:	22e0      	movs	r2, #224	@ 0xe0
10041a3e:	4393      	bics	r3, r2
10041a40:	0019      	movs	r1, r3
10041a42:	4b04      	ldr	r3, [pc, #16]	@ (10041a54 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10041a44:	687a      	ldr	r2, [r7, #4]
10041a46:	430a      	orrs	r2, r1
10041a48:	609a      	str	r2, [r3, #8]
}
10041a4a:	46c0      	nop			@ (mov r8, r8)
10041a4c:	46bd      	mov	sp, r7
10041a4e:	b002      	add	sp, #8
10041a50:	bd80      	pop	{r7, pc}
10041a52:	46c0      	nop			@ (mov r8, r8)
10041a54:	48400000 	.word	0x48400000

10041a58 <HAL_RCC_ClockConfig>:
  *         currently used as system clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
10041a58:	b580      	push	{r7, lr}
10041a5a:	b084      	sub	sp, #16
10041a5c:	af00      	add	r7, sp, #0
10041a5e:	6078      	str	r0, [r7, #4]
10041a60:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
10041a62:	687b      	ldr	r3, [r7, #4]
10041a64:	2b00      	cmp	r3, #0
10041a66:	d101      	bne.n	10041a6c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
10041a68:	2301      	movs	r3, #1
10041a6a:	e098      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>

  /* Check the parameters */
  assert_param(IS_FLASH_WAIT_STATES(FLatency));

  /* Set FALSH_WAIT_STATES_1 */
  __HAL_FLASH_SET_WAIT_STATES(FLatency);
10041a6c:	4b4e      	ldr	r3, [pc, #312]	@ (10041ba8 <HAL_RCC_ClockConfig+0x150>)
10041a6e:	685b      	ldr	r3, [r3, #4]
10041a70:	2230      	movs	r2, #48	@ 0x30
10041a72:	4393      	bics	r3, r2
10041a74:	0019      	movs	r1, r3
10041a76:	4b4c      	ldr	r3, [pc, #304]	@ (10041ba8 <HAL_RCC_ClockConfig+0x150>)
10041a78:	683a      	ldr	r2, [r7, #0]
10041a7a:	430a      	orrs	r2, r1
10041a7c:	605a      	str	r2, [r3, #4]
  /*------------------------- SYSCLK Configuration ---------------------------*/
  assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
  assert_param(IS_RCC_SYSCLK_DIVIDER(RCC_ClkInitStruct->SYSCLKDivider));

  /* HSI is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
10041a7e:	687b      	ldr	r3, [r7, #4]
10041a80:	681b      	ldr	r3, [r3, #0]
10041a82:	2b02      	cmp	r3, #2
10041a84:	d10e      	bne.n	10041aa4 <HAL_RCC_ClockConfig+0x4c>
  {
    LL_RCC_HSI_Enable();
10041a86:	f7ff ff53 	bl	10041930 <LL_RCC_HSI_Enable>
    
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
10041a8a:	f7ff ff65 	bl	10041958 <LL_RCC_HSI_IsReady>
10041a8e:	1e03      	subs	r3, r0, #0
10041a90:	d101      	bne.n	10041a96 <HAL_RCC_ClockConfig+0x3e>
    {
      return HAL_ERROR;
10041a92:	2301      	movs	r3, #1
10041a94:	e083      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    }

    /* Disable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_DISABLE();
10041a96:	f7ff ffa7 	bl	100419e8 <LL_RCC_RC64MPLL_Disable>
    
    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10041a9a:	687b      	ldr	r3, [r7, #4]
10041a9c:	685b      	ldr	r3, [r3, #4]
10041a9e:	0018      	movs	r0, r3
10041aa0:	f7ff ffc6 	bl	10041a30 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* RC64MPLL is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_RC64MPLL)
10041aa4:	687b      	ldr	r3, [r7, #4]
10041aa6:	681b      	ldr	r3, [r3, #0]
10041aa8:	2b00      	cmp	r3, #0
10041aaa:	d124      	bne.n	10041af6 <HAL_RCC_ClockConfig+0x9e>
  {
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
10041aac:	f7ff ff54 	bl	10041958 <LL_RCC_HSI_IsReady>
10041ab0:	1e03      	subs	r3, r0, #0
10041ab2:	d101      	bne.n	10041ab8 <HAL_RCC_ClockConfig+0x60>
    {
      return HAL_ERROR;
10041ab4:	2301      	movs	r3, #1
10041ab6:	e072      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
10041ab8:	f7ff ff26 	bl	10041908 <LL_RCC_HSE_IsReady>
10041abc:	1e03      	subs	r3, r0, #0
10041abe:	d101      	bne.n	10041ac4 <HAL_RCC_ClockConfig+0x6c>
    {
      return HAL_ERROR;
10041ac0:	2301      	movs	r3, #1
10041ac2:	e06c      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    }

    /* Enable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_ENABLE();
10041ac4:	f7ff ff82 	bl	100419cc <LL_RCC_RC64MPLL_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
10041ac8:	f7ff fbe8 	bl	1004129c <HAL_GetTick>
10041acc:	0003      	movs	r3, r0
10041ace:	60fb      	str	r3, [r7, #12]

    /* Wait till RC64MPLL is ready */
    while (LL_RCC_RC64MPLL_IsReady() == 0)
10041ad0:	e008      	b.n	10041ae4 <HAL_RCC_ClockConfig+0x8c>
    {
      if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
10041ad2:	f7ff fbe3 	bl	1004129c <HAL_GetTick>
10041ad6:	0002      	movs	r2, r0
10041ad8:	68fb      	ldr	r3, [r7, #12]
10041ada:	1ad3      	subs	r3, r2, r3
10041adc:	2b02      	cmp	r3, #2
10041ade:	d901      	bls.n	10041ae4 <HAL_RCC_ClockConfig+0x8c>
      {
        return HAL_TIMEOUT;
10041ae0:	2303      	movs	r3, #3
10041ae2:	e05c      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    while (LL_RCC_RC64MPLL_IsReady() == 0)
10041ae4:	f7ff ff90 	bl	10041a08 <LL_RCC_RC64MPLL_IsReady>
10041ae8:	1e03      	subs	r3, r0, #0
10041aea:	d0f2      	beq.n	10041ad2 <HAL_RCC_ClockConfig+0x7a>
      }
    }

    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10041aec:	687b      	ldr	r3, [r7, #4]
10041aee:	685b      	ldr	r3, [r3, #4]
10041af0:	0018      	movs	r0, r3
10041af2:	f7ff ff9d 	bl	10041a30 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* DIRECT_HSE is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_DIRECT_HSE)
10041af6:	687b      	ldr	r3, [r7, #4]
10041af8:	681b      	ldr	r3, [r3, #0]
10041afa:	2b01      	cmp	r3, #1
10041afc:	d117      	bne.n	10041b2e <HAL_RCC_ClockConfig+0xd6>
  {
    /* Enable the DIRECT_HSE configuration */
    LL_RCC_DIRECT_HSE_Enable();
10041afe:	f7ff ff3f 	bl	10041980 <LL_RCC_DIRECT_HSE_Enable>

    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() != 0U)
10041b02:	f7ff ff29 	bl	10041958 <LL_RCC_HSI_IsReady>
10041b06:	1e03      	subs	r3, r0, #0
10041b08:	d001      	beq.n	10041b0e <HAL_RCC_ClockConfig+0xb6>
    {
      return HAL_ERROR;
10041b0a:	2301      	movs	r3, #1
10041b0c:	e047      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
10041b0e:	f7ff fefb 	bl	10041908 <LL_RCC_HSE_IsReady>
10041b12:	1e03      	subs	r3, r0, #0
10041b14:	d101      	bne.n	10041b1a <HAL_RCC_ClockConfig+0xc2>
    {
      return HAL_ERROR;
10041b16:	2301      	movs	r3, #1
10041b18:	e041      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    }

    /* Configure the DIRECT_HSE multiplication factor */
    __HAL_RCC_DIRECT_HSE_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10041b1a:	4b24      	ldr	r3, [pc, #144]	@ (10041bac <HAL_RCC_ClockConfig+0x154>)
10041b1c:	689b      	ldr	r3, [r3, #8]
10041b1e:	22e0      	movs	r2, #224	@ 0xe0
10041b20:	4393      	bics	r3, r2
10041b22:	0019      	movs	r1, r3
10041b24:	687b      	ldr	r3, [r7, #4]
10041b26:	685a      	ldr	r2, [r3, #4]
10041b28:	4b20      	ldr	r3, [pc, #128]	@ (10041bac <HAL_RCC_ClockConfig+0x154>)
10041b2a:	430a      	orrs	r2, r1
10041b2c:	609a      	str	r2, [r3, #8]
  /*----------------------- FLASH Latency Configuration ------------------------*/
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the FLASH clock */

  /* Setup flash wait states because according the system clock frequency */
  if (FLatency != __HAL_FLASH_GET_WAIT_STATES())
10041b2e:	4b1e      	ldr	r3, [pc, #120]	@ (10041ba8 <HAL_RCC_ClockConfig+0x150>)
10041b30:	685b      	ldr	r3, [r3, #4]
10041b32:	2230      	movs	r2, #48	@ 0x30
10041b34:	4013      	ands	r3, r2
10041b36:	683a      	ldr	r2, [r7, #0]
10041b38:	429a      	cmp	r2, r3
10041b3a:	d01d      	beq.n	10041b78 <HAL_RCC_ClockConfig+0x120>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_CONFIG register */
    __HAL_FLASH_SET_WAIT_STATES(FLatency);
10041b3c:	4b1a      	ldr	r3, [pc, #104]	@ (10041ba8 <HAL_RCC_ClockConfig+0x150>)
10041b3e:	685b      	ldr	r3, [r3, #4]
10041b40:	2230      	movs	r2, #48	@ 0x30
10041b42:	4393      	bics	r3, r2
10041b44:	0019      	movs	r1, r3
10041b46:	4b18      	ldr	r3, [pc, #96]	@ (10041ba8 <HAL_RCC_ClockConfig+0x150>)
10041b48:	683a      	ldr	r2, [r7, #0]
10041b4a:	430a      	orrs	r2, r1
10041b4c:	605a      	str	r2, [r3, #4]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
10041b4e:	f7ff fba5 	bl	1004129c <HAL_GetTick>
10041b52:	0003      	movs	r3, r0
10041b54:	60fb      	str	r3, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_CONFIG register */
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
10041b56:	e008      	b.n	10041b6a <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
10041b58:	f7ff fba0 	bl	1004129c <HAL_GetTick>
10041b5c:	0002      	movs	r2, r0
10041b5e:	68fb      	ldr	r3, [r7, #12]
10041b60:	1ad3      	subs	r3, r2, r3
10041b62:	2b02      	cmp	r3, #2
10041b64:	d901      	bls.n	10041b6a <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
10041b66:	2303      	movs	r3, #3
10041b68:	e019      	b.n	10041b9e <HAL_RCC_ClockConfig+0x146>
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
10041b6a:	4b0f      	ldr	r3, [pc, #60]	@ (10041ba8 <HAL_RCC_ClockConfig+0x150>)
10041b6c:	685b      	ldr	r3, [r3, #4]
10041b6e:	2230      	movs	r2, #48	@ 0x30
10041b70:	4013      	ands	r3, r2
10041b72:	683a      	ldr	r2, [r7, #0]
10041b74:	429a      	cmp	r2, r3
10041b76:	d1ef      	bne.n	10041b58 <HAL_RCC_ClockConfig+0x100>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  for (volatile int i = 0; i < 6; i++)
10041b78:	2300      	movs	r3, #0
10041b7a:	60bb      	str	r3, [r7, #8]
10041b7c:	e003      	b.n	10041b86 <HAL_RCC_ClockConfig+0x12e>
  {
    __asm("NOP");
10041b7e:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
10041b80:	68bb      	ldr	r3, [r7, #8]
10041b82:	3301      	adds	r3, #1
10041b84:	60bb      	str	r3, [r7, #8]
10041b86:	68bb      	ldr	r3, [r7, #8]
10041b88:	2b05      	cmp	r3, #5
10041b8a:	ddf8      	ble.n	10041b7e <HAL_RCC_ClockConfig+0x126>
  }
  SystemCoreClockUpdate();
10041b8c:	f7ff f80e 	bl	10040bac <SystemCoreClockUpdate>

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
10041b90:	f7ff fb8e 	bl	100412b0 <HAL_GetTickPrio>
10041b94:	0003      	movs	r3, r0
10041b96:	0018      	movs	r0, r3
10041b98:	f7ff fb26 	bl	100411e8 <HAL_InitTick>
10041b9c:	0003      	movs	r3, r0
}
10041b9e:	0018      	movs	r0, r3
10041ba0:	46bd      	mov	sp, r7
10041ba2:	b004      	add	sp, #16
10041ba4:	bd80      	pop	{r7, pc}
10041ba6:	46c0      	nop			@ (mov r8, r8)
10041ba8:	40001000 	.word	0x40001000
10041bac:	48400000 	.word	0x48400000

10041bb0 <HAL_RCC_GetSysClockFreq>:
  *         content of the SystemCoreClock CMSIS variable
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
10041bb0:	b580      	push	{r7, lr}
10041bb2:	af00      	add	r7, sp, #0
  return SystemCoreClock;
10041bb4:	4b02      	ldr	r3, [pc, #8]	@ (10041bc0 <HAL_RCC_GetSysClockFreq+0x10>)
10041bb6:	681b      	ldr	r3, [r3, #0]
}
10041bb8:	0018      	movs	r0, r3
10041bba:	46bd      	mov	sp, r7
10041bbc:	bd80      	pop	{r7, pc}
10041bbe:	46c0      	nop			@ (mov r8, r8)
10041bc0:	200002c0 	.word	0x200002c0

10041bc4 <LL_RCC_HSE_IsReady>:
{
10041bc4:	b580      	push	{r7, lr}
10041bc6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
10041bc8:	4b07      	ldr	r3, [pc, #28]	@ (10041be8 <LL_RCC_HSE_IsReady+0x24>)
10041bca:	681a      	ldr	r2, [r3, #0]
10041bcc:	2380      	movs	r3, #128	@ 0x80
10041bce:	029b      	lsls	r3, r3, #10
10041bd0:	401a      	ands	r2, r3
10041bd2:	2380      	movs	r3, #128	@ 0x80
10041bd4:	029b      	lsls	r3, r3, #10
10041bd6:	429a      	cmp	r2, r3
10041bd8:	d101      	bne.n	10041bde <LL_RCC_HSE_IsReady+0x1a>
10041bda:	2301      	movs	r3, #1
10041bdc:	e000      	b.n	10041be0 <LL_RCC_HSE_IsReady+0x1c>
10041bde:	2300      	movs	r3, #0
}
10041be0:	0018      	movs	r0, r3
10041be2:	46bd      	mov	sp, r7
10041be4:	bd80      	pop	{r7, pc}
10041be6:	46c0      	nop			@ (mov r8, r8)
10041be8:	48400000 	.word	0x48400000

10041bec <LL_RCC_DIRECT_HSE_IsEnabled>:
{
10041bec:	b580      	push	{r7, lr}
10041bee:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HSESEL_STATUS) == (RCC_CFGR_HSESEL_STATUS)) ? 1UL : 0UL);
10041bf0:	4b05      	ldr	r3, [pc, #20]	@ (10041c08 <LL_RCC_DIRECT_HSE_IsEnabled+0x1c>)
10041bf2:	689b      	ldr	r3, [r3, #8]
10041bf4:	2208      	movs	r2, #8
10041bf6:	4013      	ands	r3, r2
10041bf8:	2b08      	cmp	r3, #8
10041bfa:	d101      	bne.n	10041c00 <LL_RCC_DIRECT_HSE_IsEnabled+0x14>
10041bfc:	2301      	movs	r3, #1
10041bfe:	e000      	b.n	10041c02 <LL_RCC_DIRECT_HSE_IsEnabled+0x16>
10041c00:	2300      	movs	r3, #0
}
10041c02:	0018      	movs	r0, r3
10041c04:	46bd      	mov	sp, r7
10041c06:	bd80      	pop	{r7, pc}
10041c08:	48400000 	.word	0x48400000

10041c0c <LL_RCC_LSCO_SetSource>:
{
10041c0c:	b580      	push	{r7, lr}
10041c0e:	b082      	sub	sp, #8
10041c10:	af00      	add	r7, sp, #0
10041c12:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
10041c14:	4b06      	ldr	r3, [pc, #24]	@ (10041c30 <LL_RCC_LSCO_SetSource+0x24>)
10041c16:	689b      	ldr	r3, [r3, #8]
10041c18:	4a06      	ldr	r2, [pc, #24]	@ (10041c34 <LL_RCC_LSCO_SetSource+0x28>)
10041c1a:	4013      	ands	r3, r2
10041c1c:	0019      	movs	r1, r3
10041c1e:	4b04      	ldr	r3, [pc, #16]	@ (10041c30 <LL_RCC_LSCO_SetSource+0x24>)
10041c20:	687a      	ldr	r2, [r7, #4]
10041c22:	430a      	orrs	r2, r1
10041c24:	609a      	str	r2, [r3, #8]
}
10041c26:	46c0      	nop			@ (mov r8, r8)
10041c28:	46bd      	mov	sp, r7
10041c2a:	b002      	add	sp, #8
10041c2c:	bd80      	pop	{r7, pc}
10041c2e:	46c0      	nop			@ (mov r8, r8)
10041c30:	48400000 	.word	0x48400000
10041c34:	fffe7fff 	.word	0xfffe7fff

10041c38 <LL_RCC_LSCO_GetSource>:
{
10041c38:	b580      	push	{r7, lr}
10041c3a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_CLKSLOWSEL));
10041c3c:	4b03      	ldr	r3, [pc, #12]	@ (10041c4c <LL_RCC_LSCO_GetSource+0x14>)
10041c3e:	689a      	ldr	r2, [r3, #8]
10041c40:	23c0      	movs	r3, #192	@ 0xc0
10041c42:	025b      	lsls	r3, r3, #9
10041c44:	4013      	ands	r3, r2
}
10041c46:	0018      	movs	r0, r3
10041c48:	46bd      	mov	sp, r7
10041c4a:	bd80      	pop	{r7, pc}
10041c4c:	48400000 	.word	0x48400000

10041c50 <LL_RCC_SetRFClock>:
{
10041c50:	b580      	push	{r7, lr}
10041c52:	b082      	sub	sp, #8
10041c54:	af00      	add	r7, sp, #0
10041c56:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->APB2ENR, RCC_APB2ENR_CLKBLEDIV, Source);
10041c58:	4b06      	ldr	r3, [pc, #24]	@ (10041c74 <LL_RCC_SetRFClock+0x24>)
10041c5a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
10041c5c:	2204      	movs	r2, #4
10041c5e:	4393      	bics	r3, r2
10041c60:	0019      	movs	r1, r3
10041c62:	4b04      	ldr	r3, [pc, #16]	@ (10041c74 <LL_RCC_SetRFClock+0x24>)
10041c64:	687a      	ldr	r2, [r7, #4]
10041c66:	430a      	orrs	r2, r1
10041c68:	661a      	str	r2, [r3, #96]	@ 0x60
}
10041c6a:	46c0      	nop			@ (mov r8, r8)
10041c6c:	46bd      	mov	sp, r7
10041c6e:	b002      	add	sp, #8
10041c70:	bd80      	pop	{r7, pc}
10041c72:	46c0      	nop			@ (mov r8, r8)
10041c74:	48400000 	.word	0x48400000

10041c78 <LL_RCC_GetRFClock>:
{
10041c78:	b580      	push	{r7, lr}
10041c7a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->APB2ENR, RCC_APB2ENR_CLKBLEDIV));
10041c7c:	4b03      	ldr	r3, [pc, #12]	@ (10041c8c <LL_RCC_GetRFClock+0x14>)
10041c7e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
10041c80:	2204      	movs	r2, #4
10041c82:	4013      	ands	r3, r2
}
10041c84:	0018      	movs	r0, r3
10041c86:	46bd      	mov	sp, r7
10041c88:	bd80      	pop	{r7, pc}
10041c8a:	46c0      	nop			@ (mov r8, r8)
10041c8c:	48400000 	.word	0x48400000

10041c90 <LL_RCC_SetSMPSPrescaler>:
{
10041c90:	b580      	push	{r7, lr}
10041c92:	b082      	sub	sp, #8
10041c94:	af00      	add	r7, sp, #0
10041c96:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SMPSDIV, Prescaler);
10041c98:	4b06      	ldr	r3, [pc, #24]	@ (10041cb4 <LL_RCC_SetSMPSPrescaler+0x24>)
10041c9a:	689b      	ldr	r3, [r3, #8]
10041c9c:	4a06      	ldr	r2, [pc, #24]	@ (10041cb8 <LL_RCC_SetSMPSPrescaler+0x28>)
10041c9e:	4013      	ands	r3, r2
10041ca0:	0019      	movs	r1, r3
10041ca2:	4b04      	ldr	r3, [pc, #16]	@ (10041cb4 <LL_RCC_SetSMPSPrescaler+0x24>)
10041ca4:	687a      	ldr	r2, [r7, #4]
10041ca6:	430a      	orrs	r2, r1
10041ca8:	609a      	str	r2, [r3, #8]
}
10041caa:	46c0      	nop			@ (mov r8, r8)
10041cac:	46bd      	mov	sp, r7
10041cae:	b002      	add	sp, #8
10041cb0:	bd80      	pop	{r7, pc}
10041cb2:	46c0      	nop			@ (mov r8, r8)
10041cb4:	48400000 	.word	0x48400000
10041cb8:	ffffefff 	.word	0xffffefff

10041cbc <LL_RCC_GetSMPSPrescaler>:
{
10041cbc:	b580      	push	{r7, lr}
10041cbe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SMPSDIV));
10041cc0:	4b03      	ldr	r3, [pc, #12]	@ (10041cd0 <LL_RCC_GetSMPSPrescaler+0x14>)
10041cc2:	689a      	ldr	r2, [r3, #8]
10041cc4:	2380      	movs	r3, #128	@ 0x80
10041cc6:	015b      	lsls	r3, r3, #5
10041cc8:	4013      	ands	r3, r2
}
10041cca:	0018      	movs	r0, r3
10041ccc:	46bd      	mov	sp, r7
10041cce:	bd80      	pop	{r7, pc}
10041cd0:	48400000 	.word	0x48400000

10041cd4 <LL_RCC_SetLPUARTClockSource>:
{
10041cd4:	b580      	push	{r7, lr}
10041cd6:	b082      	sub	sp, #8
10041cd8:	af00      	add	r7, sp, #0
10041cda:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_LPUCLKSEL, Source);
10041cdc:	4b06      	ldr	r3, [pc, #24]	@ (10041cf8 <LL_RCC_SetLPUARTClockSource+0x24>)
10041cde:	689b      	ldr	r3, [r3, #8]
10041ce0:	4a06      	ldr	r2, [pc, #24]	@ (10041cfc <LL_RCC_SetLPUARTClockSource+0x28>)
10041ce2:	4013      	ands	r3, r2
10041ce4:	0019      	movs	r1, r3
10041ce6:	4b04      	ldr	r3, [pc, #16]	@ (10041cf8 <LL_RCC_SetLPUARTClockSource+0x24>)
10041ce8:	687a      	ldr	r2, [r7, #4]
10041cea:	430a      	orrs	r2, r1
10041cec:	609a      	str	r2, [r3, #8]
}
10041cee:	46c0      	nop			@ (mov r8, r8)
10041cf0:	46bd      	mov	sp, r7
10041cf2:	b002      	add	sp, #8
10041cf4:	bd80      	pop	{r7, pc}
10041cf6:	46c0      	nop			@ (mov r8, r8)
10041cf8:	48400000 	.word	0x48400000
10041cfc:	ffffdfff 	.word	0xffffdfff

10041d00 <LL_RCC_GetLPUARTClockSource>:
{
10041d00:	b580      	push	{r7, lr}
10041d02:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_LPUCLKSEL));
10041d04:	4b03      	ldr	r3, [pc, #12]	@ (10041d14 <LL_RCC_GetLPUARTClockSource+0x14>)
10041d06:	689a      	ldr	r2, [r3, #8]
10041d08:	2380      	movs	r3, #128	@ 0x80
10041d0a:	019b      	lsls	r3, r3, #6
10041d0c:	4013      	ands	r3, r2
}
10041d0e:	0018      	movs	r0, r3
10041d10:	46bd      	mov	sp, r7
10041d12:	bd80      	pop	{r7, pc}
10041d14:	48400000 	.word	0x48400000

10041d18 <LL_RCC_SetSPI3I2SClockSource>:
{
10041d18:	b580      	push	{r7, lr}
10041d1a:	b082      	sub	sp, #8
10041d1c:	af00      	add	r7, sp, #0
10041d1e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL, Source);
10041d20:	4b06      	ldr	r3, [pc, #24]	@ (10041d3c <LL_RCC_SetSPI3I2SClockSource+0x24>)
10041d22:	689b      	ldr	r3, [r3, #8]
10041d24:	4a06      	ldr	r2, [pc, #24]	@ (10041d40 <LL_RCC_SetSPI3I2SClockSource+0x28>)
10041d26:	4013      	ands	r3, r2
10041d28:	0019      	movs	r1, r3
10041d2a:	4b04      	ldr	r3, [pc, #16]	@ (10041d3c <LL_RCC_SetSPI3I2SClockSource+0x24>)
10041d2c:	687a      	ldr	r2, [r7, #4]
10041d2e:	430a      	orrs	r2, r1
10041d30:	609a      	str	r2, [r3, #8]
}
10041d32:	46c0      	nop			@ (mov r8, r8)
10041d34:	46bd      	mov	sp, r7
10041d36:	b002      	add	sp, #8
10041d38:	bd80      	pop	{r7, pc}
10041d3a:	46c0      	nop			@ (mov r8, r8)
10041d3c:	48400000 	.word	0x48400000
10041d40:	ff3fffff 	.word	0xff3fffff

10041d44 <LL_RCC_GetSPI3I2SClockSource>:
{
10041d44:	b580      	push	{r7, lr}
10041d46:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL));
10041d48:	4b03      	ldr	r3, [pc, #12]	@ (10041d58 <LL_RCC_GetSPI3I2SClockSource+0x14>)
10041d4a:	689a      	ldr	r2, [r3, #8]
10041d4c:	23c0      	movs	r3, #192	@ 0xc0
10041d4e:	041b      	lsls	r3, r3, #16
10041d50:	4013      	ands	r3, r2
}
10041d52:	0018      	movs	r0, r3
10041d54:	46bd      	mov	sp, r7
10041d56:	bd80      	pop	{r7, pc}
10041d58:	48400000 	.word	0x48400000

10041d5c <LL_RCC_RC64MPLL_IsReady>:
{
10041d5c:	b580      	push	{r7, lr}
10041d5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
10041d60:	4b07      	ldr	r3, [pc, #28]	@ (10041d80 <LL_RCC_RC64MPLL_IsReady+0x24>)
10041d62:	681a      	ldr	r2, [r3, #0]
10041d64:	2380      	movs	r3, #128	@ 0x80
10041d66:	01db      	lsls	r3, r3, #7
10041d68:	401a      	ands	r2, r3
10041d6a:	2380      	movs	r3, #128	@ 0x80
10041d6c:	01db      	lsls	r3, r3, #7
10041d6e:	429a      	cmp	r2, r3
10041d70:	d101      	bne.n	10041d76 <LL_RCC_RC64MPLL_IsReady+0x1a>
10041d72:	2301      	movs	r3, #1
10041d74:	e000      	b.n	10041d78 <LL_RCC_RC64MPLL_IsReady+0x1c>
10041d76:	2300      	movs	r3, #0
}
10041d78:	0018      	movs	r0, r3
10041d7a:	46bd      	mov	sp, r7
10041d7c:	bd80      	pop	{r7, pc}
10041d7e:	46c0      	nop			@ (mov r8, r8)
10041d80:	48400000 	.word	0x48400000

10041d84 <HAL_RCCEx_PeriphCLKConfig>:
  *  @note   (*) Peripherals are not available on all devices
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
10041d84:	b580      	push	{r7, lr}
10041d86:	b082      	sub	sp, #8
10041d88:	af00      	add	r7, sp, #0
10041d8a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RF_BLE clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RF) == RCC_PERIPHCLK_RF))
10041d8c:	687b      	ldr	r3, [r7, #4]
10041d8e:	681b      	ldr	r3, [r3, #0]
10041d90:	2201      	movs	r2, #1
10041d92:	4013      	ands	r3, r2
10041d94:	d004      	beq.n	10041da0 <HAL_RCCEx_PeriphCLKConfig+0x1c>
  {
    assert_param(IS_RCC_RF_BLE_CLOCK_SOURCE(PeriphClkInit->RFClockSelection));
    __HAL_RCC_RF_CLK_SET_CONFIG(PeriphClkInit->RFClockSelection);
10041d96:	687b      	ldr	r3, [r7, #4]
10041d98:	691b      	ldr	r3, [r3, #16]
10041d9a:	0018      	movs	r0, r3
10041d9c:	f7ff ff58 	bl	10041c50 <LL_RCC_SetRFClock>
  }

  /*-------------------------- SMPS clock configuration -------------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS))
10041da0:	687b      	ldr	r3, [r7, #4]
10041da2:	681b      	ldr	r3, [r3, #0]
10041da4:	2202      	movs	r2, #2
10041da6:	4013      	ands	r3, r2
10041da8:	d004      	beq.n	10041db4 <HAL_RCCEx_PeriphCLKConfig+0x30>
  {
    assert_param(IS_RCC_SMPS_CLOCK_PRESC(PeriphClkInit->SmpsDivSelection));
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
10041daa:	687b      	ldr	r3, [r7, #4]
10041dac:	695b      	ldr	r3, [r3, #20]
10041dae:	0018      	movs	r0, r3
10041db0:	f7ff ff6e 	bl	10041c90 <LL_RCC_SetSMPSPrescaler>
    __HAL_RCC_SPI2I2S_CLK_CONFIG(PeriphClkInit->SPI2I2SClockSelection);
  }
#endif
#if defined(SPI3)
  /*-------------------------- SPI3_I2S clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3_I2S) == RCC_PERIPHCLK_SPI3_I2S))
10041db4:	687b      	ldr	r3, [r7, #4]
10041db6:	681b      	ldr	r3, [r3, #0]
10041db8:	2208      	movs	r2, #8
10041dba:	4013      	ands	r3, r2
10041dbc:	d004      	beq.n	10041dc8 <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    assert_param(IS_RCC_SPI3I2S_CLOCK_SOURCE(PeriphClkInit->SPI3I2SClockSelection));
    __HAL_RCC_SPI3I2S_CLK_CONFIG(PeriphClkInit->SPI3I2SClockSelection);
10041dbe:	687b      	ldr	r3, [r7, #4]
10041dc0:	685b      	ldr	r3, [r3, #4]
10041dc2:	0018      	movs	r0, r3
10041dc4:	f7ff ffa8 	bl	10041d18 <LL_RCC_SetSPI3I2SClockSource>
  }
#endif

#if defined(RCC_CFGR_LPUCLKSEL)
  /*-------------------------- LPUART1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1))
10041dc8:	687b      	ldr	r3, [r7, #4]
10041dca:	681b      	ldr	r3, [r3, #0]
10041dcc:	2210      	movs	r2, #16
10041dce:	4013      	ands	r3, r2
10041dd0:	d004      	beq.n	10041ddc <HAL_RCCEx_PeriphCLKConfig+0x58>
  {
    assert_param(IS_RCC_LPUART1_CLOCK_SOURCE(PeriphClkInit->LPUART1ClockSelection));
    __HAL_RCC_LPUART1_CLK_CONFIG(PeriphClkInit->LPUART1ClockSelection);
10041dd2:	687b      	ldr	r3, [r7, #4]
10041dd4:	68db      	ldr	r3, [r3, #12]
10041dd6:	0018      	movs	r0, r3
10041dd8:	f7ff ff7c 	bl	10041cd4 <LL_RCC_SetLPUARTClockSource>
  }
#endif /* RCC_CFGR_LPUCLKSEL */

  /*-------------------------- RTC WDG BLEWKUP clock source configuration ---------------------*/
  if ((((PeriphClkInit->RTCWDGBLEWKUPClockSelection) & RCC_PERIPHCLK_RTC_WDG_BLEWKUP) == RCC_PERIPHCLK_RTC_WDG_BLEWKUP))
10041ddc:	687b      	ldr	r3, [r7, #4]
10041dde:	689b      	ldr	r3, [r3, #8]
10041de0:	2220      	movs	r2, #32
10041de2:	4013      	ands	r3, r2
10041de4:	d004      	beq.n	10041df0 <HAL_RCCEx_PeriphCLKConfig+0x6c>
  {
    assert_param(IS_RCC_RTC_WDG_BLEWKUP_CLOCK_SOURCE(PeriphClkInit->RTCWDGBLEWKUPClockSelection));
    __HAL_RCC_RTC_WDG_BLEWKUP_CLK_CONFIG(PeriphClkInit->RTCWDGBLEWKUPClockSelection);
10041de6:	687b      	ldr	r3, [r7, #4]
10041de8:	689b      	ldr	r3, [r3, #8]
10041dea:	0018      	movs	r0, r3
10041dec:	f7ff ff0e 	bl	10041c0c <LL_RCC_LSCO_SetSource>
  }

  return HAL_OK;
10041df0:	2300      	movs	r3, #0
}
10041df2:	0018      	movs	r0, r3
10041df4:	46bd      	mov	sp, r7
10041df6:	b002      	add	sp, #8
10041df8:	bd80      	pop	{r7, pc}
	...

10041dfc <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_RTC_WDG_BLEWKUP   RTC, WDG and BLEWKUP peripheral clock
  * @retval Frequency in Hz
  * @note   (*) Peripherals are not available on all devices
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
10041dfc:	b580      	push	{r7, lr}
10041dfe:	b084      	sub	sp, #16
10041e00:	af00      	add	r7, sp, #0
10041e02:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  /* No if clausule is covered */
  frequency = 0;
10041e04:	2300      	movs	r3, #0
10041e06:	60fb      	str	r3, [r7, #12]

  switch (PeriphClk)
10041e08:	687b      	ldr	r3, [r7, #4]
10041e0a:	2b20      	cmp	r3, #32
10041e0c:	d900      	bls.n	10041e10 <HAL_RCCEx_GetPeriphCLKFreq+0x14>
10041e0e:	e07b      	b.n	10041f08 <HAL_RCCEx_GetPeriphCLKFreq+0x10c>
10041e10:	687b      	ldr	r3, [r7, #4]
10041e12:	009a      	lsls	r2, r3, #2
10041e14:	4b40      	ldr	r3, [pc, #256]	@ (10041f18 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>)
10041e16:	18d3      	adds	r3, r2, r3
10041e18:	681b      	ldr	r3, [r3, #0]
10041e1a:	469f      	mov	pc, r3
  {
    case RCC_PERIPHCLK_RF :
      switch (__HAL_RCC_RF_CLK_GET_CONFIG())
10041e1c:	f7ff ff2c 	bl	10041c78 <LL_RCC_GetRFClock>
10041e20:	1e03      	subs	r3, r0, #0
10041e22:	d002      	beq.n	10041e2a <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
10041e24:	2b04      	cmp	r3, #4
10041e26:	d003      	beq.n	10041e30 <HAL_RCCEx_GetPeriphCLKFreq+0x34>
        case RCC_RF_CLK_16M:
          frequency = HSE_VALUE / 2;
          break;
      }

      break;
10041e28:	e071      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>
          frequency = HSE_VALUE;
10041e2a:	4b3c      	ldr	r3, [pc, #240]	@ (10041f1c <HAL_RCCEx_GetPeriphCLKFreq+0x120>)
10041e2c:	60fb      	str	r3, [r7, #12]
          break;
10041e2e:	e002      	b.n	10041e36 <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          frequency = HSE_VALUE / 2;
10041e30:	4b3b      	ldr	r3, [pc, #236]	@ (10041f20 <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10041e32:	60fb      	str	r3, [r7, #12]
          break;
10041e34:	46c0      	nop			@ (mov r8, r8)
      break;
10041e36:	e06a      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>

    case RCC_PERIPHCLK_SMPS :
      switch (__HAL_RCC_GET_SMPS_DIV())
10041e38:	f7ff ff40 	bl	10041cbc <LL_RCC_GetSMPSPrescaler>
10041e3c:	1e03      	subs	r3, r0, #0
10041e3e:	d004      	beq.n	10041e4a <HAL_RCCEx_GetPeriphCLKFreq+0x4e>
10041e40:	2280      	movs	r2, #128	@ 0x80
10041e42:	0152      	lsls	r2, r2, #5
10041e44:	4293      	cmp	r3, r2
10041e46:	d003      	beq.n	10041e50 <HAL_RCCEx_GetPeriphCLKFreq+0x54>
          break;
        case RCC_SMPSCLK_DIV4:
          frequency = HSE_VALUE / 8;
          break;
      }
      break;
10041e48:	e061      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>
          frequency = HSE_VALUE / 4;
10041e4a:	4b36      	ldr	r3, [pc, #216]	@ (10041f24 <HAL_RCCEx_GetPeriphCLKFreq+0x128>)
10041e4c:	60fb      	str	r3, [r7, #12]
          break;
10041e4e:	e002      	b.n	10041e56 <HAL_RCCEx_GetPeriphCLKFreq+0x5a>
          frequency = HSE_VALUE / 8;
10041e50:	4b35      	ldr	r3, [pc, #212]	@ (10041f28 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>)
10041e52:	60fb      	str	r3, [r7, #12]
          break;
10041e54:	46c0      	nop			@ (mov r8, r8)
      break;
10041e56:	e05a      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>
      }
      break;
#endif

    case RCC_PERIPHCLK_SPI3_I2S :
      if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_DIRECT_HSE)
10041e58:	f7ff fec8 	bl	10041bec <LL_RCC_DIRECT_HSE_IsEnabled>
10041e5c:	1e03      	subs	r3, r0, #0
10041e5e:	d005      	beq.n	10041e6c <HAL_RCCEx_GetPeriphCLKFreq+0x70>
      {
        if (__HAL_RCC_GET_HSE_READYFLAG() == 0)
10041e60:	f7ff feb0 	bl	10041bc4 <LL_RCC_HSE_IsReady>
10041e64:	1e03      	subs	r3, r0, #0
10041e66:	d107      	bne.n	10041e78 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
        {
          return 0;
10041e68:	2300      	movs	r3, #0
10041e6a:	e051      	b.n	10041f10 <HAL_RCCEx_GetPeriphCLKFreq+0x114>
        }
      }
      else
      {
        if (__HAL_RCC_RC64MPLL_READYFLAG() == 0)
10041e6c:	f7ff ff76 	bl	10041d5c <LL_RCC_RC64MPLL_IsReady>
10041e70:	1e03      	subs	r3, r0, #0
10041e72:	d101      	bne.n	10041e78 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
        {
          return 0;
10041e74:	2300      	movs	r3, #0
10041e76:	e04b      	b.n	10041f10 <HAL_RCCEx_GetPeriphCLKFreq+0x114>
        }
      }
      spiFreqValue = __HAL_RCC_GET_SPI3I2S_CLK_CONFIG();
10041e78:	f7ff ff64 	bl	10041d44 <LL_RCC_GetSPI3I2SClockSource>
10041e7c:	0003      	movs	r3, r0
10041e7e:	60bb      	str	r3, [r7, #8]
      if (spiFreqValue == RCC_SPI3I2S_CLKSOURCE_16M)
10041e80:	68bb      	ldr	r3, [r7, #8]
10041e82:	2b00      	cmp	r3, #0
10041e84:	d101      	bne.n	10041e8a <HAL_RCCEx_GetPeriphCLKFreq+0x8e>
      {
        frequency = HSE_VALUE / 2;
10041e86:	4b26      	ldr	r3, [pc, #152]	@ (10041f20 <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10041e88:	60fb      	str	r3, [r7, #12]
      }

      if (spiFreqValue == RCC_SPI3I2S_CLKSOURCE_32M)
10041e8a:	68ba      	ldr	r2, [r7, #8]
10041e8c:	2380      	movs	r3, #128	@ 0x80
10041e8e:	03db      	lsls	r3, r3, #15
10041e90:	429a      	cmp	r2, r3
10041e92:	d101      	bne.n	10041e98 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
      {
        frequency = HSE_VALUE;
10041e94:	4b21      	ldr	r3, [pc, #132]	@ (10041f1c <HAL_RCCEx_GetPeriphCLKFreq+0x120>)
10041e96:	60fb      	str	r3, [r7, #12]
      }
#if defined(RCC_SPI3I2S_CLKSOURCE_64M)
      if (spiFreqValue == RCC_SPI3I2S_CLKSOURCE_64M)
10041e98:	68ba      	ldr	r2, [r7, #8]
10041e9a:	2380      	movs	r3, #128	@ 0x80
10041e9c:	041b      	lsls	r3, r3, #16
10041e9e:	429a      	cmp	r2, r3
10041ea0:	d134      	bne.n	10041f0c <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      {
        frequency = HSE_VALUE * 2;
10041ea2:	4b22      	ldr	r3, [pc, #136]	@ (10041f2c <HAL_RCCEx_GetPeriphCLKFreq+0x130>)
10041ea4:	60fb      	str	r3, [r7, #12]
      }
#endif
      break;
10041ea6:	e031      	b.n	10041f0c <HAL_RCCEx_GetPeriphCLKFreq+0x110>

#if defined(RCC_CFGR_LPUCLKSEL)
    case RCC_PERIPHCLK_LPUART1 :
      switch (__HAL_RCC_GET_LPUART1_CLK_CONFIG())
10041ea8:	f7ff ff2a 	bl	10041d00 <LL_RCC_GetLPUARTClockSource>
10041eac:	0002      	movs	r2, r0
10041eae:	2380      	movs	r3, #128	@ 0x80
10041eb0:	019b      	lsls	r3, r3, #6
10041eb2:	429a      	cmp	r2, r3
10041eb4:	d103      	bne.n	10041ebe <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
      {
        case RCC_LPUART1_CLKSOURCE_LSE:
          frequency = LSE_VALUE;
10041eb6:	2380      	movs	r3, #128	@ 0x80
10041eb8:	021b      	lsls	r3, r3, #8
10041eba:	60fb      	str	r3, [r7, #12]
          break;
10041ebc:	e002      	b.n	10041ec4 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
        case RCC_LPUART1_CLKSOURCE_16M:
        default:
          frequency = HSE_VALUE / 2;
10041ebe:	4b18      	ldr	r3, [pc, #96]	@ (10041f20 <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10041ec0:	60fb      	str	r3, [r7, #12]
          break;
10041ec2:	46c0      	nop			@ (mov r8, r8)
      }
      break;
10041ec4:	e023      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>
#endif /* RCC_CFGR_LPUCLKSEL */

    case RCC_PERIPHCLK_RTC_WDG_BLEWKUP :
      switch (LL_RCC_LSCO_GetSource())
10041ec6:	f7ff feb7 	bl	10041c38 <LL_RCC_LSCO_GetSource>
10041eca:	0003      	movs	r3, r0
10041ecc:	22c0      	movs	r2, #192	@ 0xc0
10041ece:	0252      	lsls	r2, r2, #9
10041ed0:	4293      	cmp	r3, r2
10041ed2:	d014      	beq.n	10041efe <HAL_RCCEx_GetPeriphCLKFreq+0x102>
10041ed4:	22c0      	movs	r2, #192	@ 0xc0
10041ed6:	0252      	lsls	r2, r2, #9
10041ed8:	4293      	cmp	r3, r2
10041eda:	d813      	bhi.n	10041f04 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
10041edc:	2280      	movs	r2, #128	@ 0x80
10041ede:	0212      	lsls	r2, r2, #8
10041ee0:	4293      	cmp	r3, r2
10041ee2:	d004      	beq.n	10041eee <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
10041ee4:	2280      	movs	r2, #128	@ 0x80
10041ee6:	0252      	lsls	r2, r2, #9
10041ee8:	4293      	cmp	r3, r2
10041eea:	d004      	beq.n	10041ef6 <HAL_RCCEx_GetPeriphCLKFreq+0xfa>
          break;
        case LL_RCC_LSCO_CLKSOURCE_HSI64M_DIV2048:
          frequency = HSE_VALUE >> 10;
          break;
        default :
          break;
10041eec:	e00a      	b.n	10041f04 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
          frequency = LSE_VALUE;
10041eee:	2380      	movs	r3, #128	@ 0x80
10041ef0:	021b      	lsls	r3, r3, #8
10041ef2:	60fb      	str	r3, [r7, #12]
          break;
10041ef4:	e007      	b.n	10041f06 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
          frequency = LSI_VALUE;
10041ef6:	23fa      	movs	r3, #250	@ 0xfa
10041ef8:	01db      	lsls	r3, r3, #7
10041efa:	60fb      	str	r3, [r7, #12]
          break;
10041efc:	e003      	b.n	10041f06 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
          frequency = HSE_VALUE >> 10;
10041efe:	4b0c      	ldr	r3, [pc, #48]	@ (10041f30 <HAL_RCCEx_GetPeriphCLKFreq+0x134>)
10041f00:	60fb      	str	r3, [r7, #12]
          break;
10041f02:	e000      	b.n	10041f06 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
          break;
10041f04:	46c0      	nop			@ (mov r8, r8)
      }
      break;
10041f06:	e002      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>
    default :
      break;
10041f08:	46c0      	nop			@ (mov r8, r8)
10041f0a:	e000      	b.n	10041f0e <HAL_RCCEx_GetPeriphCLKFreq+0x112>
      break;
10041f0c:	46c0      	nop			@ (mov r8, r8)
  }

  return (frequency);
10041f0e:	68fb      	ldr	r3, [r7, #12]
}
10041f10:	0018      	movs	r0, r3
10041f12:	46bd      	mov	sp, r7
10041f14:	b004      	add	sp, #16
10041f16:	bd80      	pop	{r7, pc}
10041f18:	100437dc 	.word	0x100437dc
10041f1c:	01e84800 	.word	0x01e84800
10041f20:	00f42400 	.word	0x00f42400
10041f24:	007a1200 	.word	0x007a1200
10041f28:	003d0900 	.word	0x003d0900
10041f2c:	03d09000 	.word	0x03d09000
10041f30:	00007a12 	.word	0x00007a12

10041f34 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
10041f34:	b580      	push	{r7, lr}
10041f36:	b082      	sub	sp, #8
10041f38:	af00      	add	r7, sp, #0
10041f3a:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
10041f3c:	687b      	ldr	r3, [r7, #4]
10041f3e:	2b00      	cmp	r3, #0
10041f40:	d101      	bne.n	10041f46 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
10041f42:	2301      	movs	r3, #1
10041f44:	e046      	b.n	10041fd4 <HAL_UART_Init+0xa0>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
10041f46:	687b      	ldr	r3, [r7, #4]
10041f48:	2288      	movs	r2, #136	@ 0x88
10041f4a:	589b      	ldr	r3, [r3, r2]
10041f4c:	2b00      	cmp	r3, #0
10041f4e:	d107      	bne.n	10041f60 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
10041f50:	687b      	ldr	r3, [r7, #4]
10041f52:	2284      	movs	r2, #132	@ 0x84
10041f54:	2100      	movs	r1, #0
10041f56:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
10041f58:	687b      	ldr	r3, [r7, #4]
10041f5a:	0018      	movs	r0, r3
10041f5c:	f000 f840 	bl	10041fe0 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
10041f60:	687b      	ldr	r3, [r7, #4]
10041f62:	2288      	movs	r2, #136	@ 0x88
10041f64:	2124      	movs	r1, #36	@ 0x24
10041f66:	5099      	str	r1, [r3, r2]

  __HAL_UART_DISABLE(huart);
10041f68:	687b      	ldr	r3, [r7, #4]
10041f6a:	681b      	ldr	r3, [r3, #0]
10041f6c:	681a      	ldr	r2, [r3, #0]
10041f6e:	687b      	ldr	r3, [r7, #4]
10041f70:	681b      	ldr	r3, [r3, #0]
10041f72:	2101      	movs	r1, #1
10041f74:	438a      	bics	r2, r1
10041f76:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
10041f78:	687b      	ldr	r3, [r7, #4]
10041f7a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041f7c:	2b00      	cmp	r3, #0
10041f7e:	d003      	beq.n	10041f88 <HAL_UART_Init+0x54>
  {
    UART_AdvFeatureConfig(huart);
10041f80:	687b      	ldr	r3, [r7, #4]
10041f82:	0018      	movs	r0, r3
10041f84:	f000 fa40 	bl	10042408 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
10041f88:	687b      	ldr	r3, [r7, #4]
10041f8a:	0018      	movs	r0, r3
10041f8c:	f000 f8d4 	bl	10042138 <UART_SetConfig>
10041f90:	0003      	movs	r3, r0
10041f92:	2b01      	cmp	r3, #1
10041f94:	d101      	bne.n	10041f9a <HAL_UART_Init+0x66>
  {
    return HAL_ERROR;
10041f96:	2301      	movs	r3, #1
10041f98:	e01c      	b.n	10041fd4 <HAL_UART_Init+0xa0>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
10041f9a:	687b      	ldr	r3, [r7, #4]
10041f9c:	681b      	ldr	r3, [r3, #0]
10041f9e:	685a      	ldr	r2, [r3, #4]
10041fa0:	687b      	ldr	r3, [r7, #4]
10041fa2:	681b      	ldr	r3, [r3, #0]
10041fa4:	490d      	ldr	r1, [pc, #52]	@ (10041fdc <HAL_UART_Init+0xa8>)
10041fa6:	400a      	ands	r2, r1
10041fa8:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
10041faa:	687b      	ldr	r3, [r7, #4]
10041fac:	681b      	ldr	r3, [r3, #0]
10041fae:	689a      	ldr	r2, [r3, #8]
10041fb0:	687b      	ldr	r3, [r7, #4]
10041fb2:	681b      	ldr	r3, [r3, #0]
10041fb4:	212a      	movs	r1, #42	@ 0x2a
10041fb6:	438a      	bics	r2, r1
10041fb8:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
10041fba:	687b      	ldr	r3, [r7, #4]
10041fbc:	681b      	ldr	r3, [r3, #0]
10041fbe:	681a      	ldr	r2, [r3, #0]
10041fc0:	687b      	ldr	r3, [r7, #4]
10041fc2:	681b      	ldr	r3, [r3, #0]
10041fc4:	2101      	movs	r1, #1
10041fc6:	430a      	orrs	r2, r1
10041fc8:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
10041fca:	687b      	ldr	r3, [r7, #4]
10041fcc:	0018      	movs	r0, r3
10041fce:	f000 facf 	bl	10042570 <UART_CheckIdleState>
10041fd2:	0003      	movs	r3, r0
}
10041fd4:	0018      	movs	r0, r3
10041fd6:	46bd      	mov	sp, r7
10041fd8:	b002      	add	sp, #8
10041fda:	bd80      	pop	{r7, pc}
10041fdc:	ffffb7ff 	.word	0xffffb7ff

10041fe0 <HAL_UART_MspInit>:
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
10041fe0:	b580      	push	{r7, lr}
10041fe2:	b082      	sub	sp, #8
10041fe4:	af00      	add	r7, sp, #0
10041fe6:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
10041fe8:	46c0      	nop			@ (mov r8, r8)
10041fea:	46bd      	mov	sp, r7
10041fec:	b002      	add	sp, #8
10041fee:	bd80      	pop	{r7, pc}

10041ff0 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
10041ff0:	b580      	push	{r7, lr}
10041ff2:	b08a      	sub	sp, #40	@ 0x28
10041ff4:	af02      	add	r7, sp, #8
10041ff6:	60f8      	str	r0, [r7, #12]
10041ff8:	60b9      	str	r1, [r7, #8]
10041ffa:	603b      	str	r3, [r7, #0]
10041ffc:	1dbb      	adds	r3, r7, #6
10041ffe:	801a      	strh	r2, [r3, #0]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
10042000:	68fb      	ldr	r3, [r7, #12]
10042002:	2288      	movs	r2, #136	@ 0x88
10042004:	589b      	ldr	r3, [r3, r2]
10042006:	2b20      	cmp	r3, #32
10042008:	d000      	beq.n	1004200c <HAL_UART_Transmit+0x1c>
1004200a:	e090      	b.n	1004212e <HAL_UART_Transmit+0x13e>
  {
    if ((pData == NULL) || (Size == 0U))
1004200c:	68bb      	ldr	r3, [r7, #8]
1004200e:	2b00      	cmp	r3, #0
10042010:	d003      	beq.n	1004201a <HAL_UART_Transmit+0x2a>
10042012:	1dbb      	adds	r3, r7, #6
10042014:	881b      	ldrh	r3, [r3, #0]
10042016:	2b00      	cmp	r3, #0
10042018:	d101      	bne.n	1004201e <HAL_UART_Transmit+0x2e>
    {
      return  HAL_ERROR;
1004201a:	2301      	movs	r3, #1
1004201c:	e088      	b.n	10042130 <HAL_UART_Transmit+0x140>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
1004201e:	68fb      	ldr	r3, [r7, #12]
10042020:	689a      	ldr	r2, [r3, #8]
10042022:	2380      	movs	r3, #128	@ 0x80
10042024:	015b      	lsls	r3, r3, #5
10042026:	429a      	cmp	r2, r3
10042028:	d109      	bne.n	1004203e <HAL_UART_Transmit+0x4e>
1004202a:	68fb      	ldr	r3, [r7, #12]
1004202c:	691b      	ldr	r3, [r3, #16]
1004202e:	2b00      	cmp	r3, #0
10042030:	d105      	bne.n	1004203e <HAL_UART_Transmit+0x4e>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
10042032:	68bb      	ldr	r3, [r7, #8]
10042034:	2201      	movs	r2, #1
10042036:	4013      	ands	r3, r2
10042038:	d001      	beq.n	1004203e <HAL_UART_Transmit+0x4e>
      {
        return  HAL_ERROR;
1004203a:	2301      	movs	r3, #1
1004203c:	e078      	b.n	10042130 <HAL_UART_Transmit+0x140>
      }
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
1004203e:	68fb      	ldr	r3, [r7, #12]
10042040:	2290      	movs	r2, #144	@ 0x90
10042042:	2100      	movs	r1, #0
10042044:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
10042046:	68fb      	ldr	r3, [r7, #12]
10042048:	2288      	movs	r2, #136	@ 0x88
1004204a:	2121      	movs	r1, #33	@ 0x21
1004204c:	5099      	str	r1, [r3, r2]

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
1004204e:	f7ff f925 	bl	1004129c <HAL_GetTick>
10042052:	0003      	movs	r3, r0
10042054:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
10042056:	68fb      	ldr	r3, [r7, #12]
10042058:	1dba      	adds	r2, r7, #6
1004205a:	2154      	movs	r1, #84	@ 0x54
1004205c:	8812      	ldrh	r2, [r2, #0]
1004205e:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
10042060:	68fb      	ldr	r3, [r7, #12]
10042062:	1dba      	adds	r2, r7, #6
10042064:	2156      	movs	r1, #86	@ 0x56
10042066:	8812      	ldrh	r2, [r2, #0]
10042068:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
1004206a:	68fb      	ldr	r3, [r7, #12]
1004206c:	689a      	ldr	r2, [r3, #8]
1004206e:	2380      	movs	r3, #128	@ 0x80
10042070:	015b      	lsls	r3, r3, #5
10042072:	429a      	cmp	r2, r3
10042074:	d108      	bne.n	10042088 <HAL_UART_Transmit+0x98>
10042076:	68fb      	ldr	r3, [r7, #12]
10042078:	691b      	ldr	r3, [r3, #16]
1004207a:	2b00      	cmp	r3, #0
1004207c:	d104      	bne.n	10042088 <HAL_UART_Transmit+0x98>
    {
      pdata8bits  = NULL;
1004207e:	2300      	movs	r3, #0
10042080:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
10042082:	68bb      	ldr	r3, [r7, #8]
10042084:	61bb      	str	r3, [r7, #24]
10042086:	e003      	b.n	10042090 <HAL_UART_Transmit+0xa0>
    }
    else
    {
      pdata8bits  = pData;
10042088:	68bb      	ldr	r3, [r7, #8]
1004208a:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
1004208c:	2300      	movs	r3, #0
1004208e:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
10042090:	e030      	b.n	100420f4 <HAL_UART_Transmit+0x104>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
10042092:	697a      	ldr	r2, [r7, #20]
10042094:	68f8      	ldr	r0, [r7, #12]
10042096:	683b      	ldr	r3, [r7, #0]
10042098:	9300      	str	r3, [sp, #0]
1004209a:	0013      	movs	r3, r2
1004209c:	2200      	movs	r2, #0
1004209e:	2180      	movs	r1, #128	@ 0x80
100420a0:	f000 fb10 	bl	100426c4 <UART_WaitOnFlagUntilTimeout>
100420a4:	1e03      	subs	r3, r0, #0
100420a6:	d005      	beq.n	100420b4 <HAL_UART_Transmit+0xc4>
      {

        huart->gState = HAL_UART_STATE_READY;
100420a8:	68fb      	ldr	r3, [r7, #12]
100420aa:	2288      	movs	r2, #136	@ 0x88
100420ac:	2120      	movs	r1, #32
100420ae:	5099      	str	r1, [r3, r2]

        return HAL_TIMEOUT;
100420b0:	2303      	movs	r3, #3
100420b2:	e03d      	b.n	10042130 <HAL_UART_Transmit+0x140>
      }
      if (pdata8bits == NULL)
100420b4:	69fb      	ldr	r3, [r7, #28]
100420b6:	2b00      	cmp	r3, #0
100420b8:	d10b      	bne.n	100420d2 <HAL_UART_Transmit+0xe2>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
100420ba:	69bb      	ldr	r3, [r7, #24]
100420bc:	881b      	ldrh	r3, [r3, #0]
100420be:	001a      	movs	r2, r3
100420c0:	68fb      	ldr	r3, [r7, #12]
100420c2:	681b      	ldr	r3, [r3, #0]
100420c4:	05d2      	lsls	r2, r2, #23
100420c6:	0dd2      	lsrs	r2, r2, #23
100420c8:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
100420ca:	69bb      	ldr	r3, [r7, #24]
100420cc:	3302      	adds	r3, #2
100420ce:	61bb      	str	r3, [r7, #24]
100420d0:	e007      	b.n	100420e2 <HAL_UART_Transmit+0xf2>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
100420d2:	69fb      	ldr	r3, [r7, #28]
100420d4:	781a      	ldrb	r2, [r3, #0]
100420d6:	68fb      	ldr	r3, [r7, #12]
100420d8:	681b      	ldr	r3, [r3, #0]
100420da:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
100420dc:	69fb      	ldr	r3, [r7, #28]
100420de:	3301      	adds	r3, #1
100420e0:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
100420e2:	68fb      	ldr	r3, [r7, #12]
100420e4:	2256      	movs	r2, #86	@ 0x56
100420e6:	5a9b      	ldrh	r3, [r3, r2]
100420e8:	b29b      	uxth	r3, r3
100420ea:	3b01      	subs	r3, #1
100420ec:	b299      	uxth	r1, r3
100420ee:	68fb      	ldr	r3, [r7, #12]
100420f0:	2256      	movs	r2, #86	@ 0x56
100420f2:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
100420f4:	68fb      	ldr	r3, [r7, #12]
100420f6:	2256      	movs	r2, #86	@ 0x56
100420f8:	5a9b      	ldrh	r3, [r3, r2]
100420fa:	b29b      	uxth	r3, r3
100420fc:	2b00      	cmp	r3, #0
100420fe:	d1c8      	bne.n	10042092 <HAL_UART_Transmit+0xa2>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
10042100:	697a      	ldr	r2, [r7, #20]
10042102:	68f8      	ldr	r0, [r7, #12]
10042104:	683b      	ldr	r3, [r7, #0]
10042106:	9300      	str	r3, [sp, #0]
10042108:	0013      	movs	r3, r2
1004210a:	2200      	movs	r2, #0
1004210c:	2140      	movs	r1, #64	@ 0x40
1004210e:	f000 fad9 	bl	100426c4 <UART_WaitOnFlagUntilTimeout>
10042112:	1e03      	subs	r3, r0, #0
10042114:	d005      	beq.n	10042122 <HAL_UART_Transmit+0x132>
    {
      huart->gState = HAL_UART_STATE_READY;
10042116:	68fb      	ldr	r3, [r7, #12]
10042118:	2288      	movs	r2, #136	@ 0x88
1004211a:	2120      	movs	r1, #32
1004211c:	5099      	str	r1, [r3, r2]

      return HAL_TIMEOUT;
1004211e:	2303      	movs	r3, #3
10042120:	e006      	b.n	10042130 <HAL_UART_Transmit+0x140>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
10042122:	68fb      	ldr	r3, [r7, #12]
10042124:	2288      	movs	r2, #136	@ 0x88
10042126:	2120      	movs	r1, #32
10042128:	5099      	str	r1, [r3, r2]

    return HAL_OK;
1004212a:	2300      	movs	r3, #0
1004212c:	e000      	b.n	10042130 <HAL_UART_Transmit+0x140>
  }
  else
  {
    return HAL_BUSY;
1004212e:	2302      	movs	r3, #2
  }
}
10042130:	0018      	movs	r0, r3
10042132:	46bd      	mov	sp, r7
10042134:	b008      	add	sp, #32
10042136:	bd80      	pop	{r7, pc}

10042138 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
10042138:	b5b0      	push	{r4, r5, r7, lr}
1004213a:	b090      	sub	sp, #64	@ 0x40
1004213c:	af00      	add	r7, sp, #0
1004213e:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
10042140:	231b      	movs	r3, #27
10042142:	2220      	movs	r2, #32
10042144:	189b      	adds	r3, r3, r2
10042146:	19db      	adds	r3, r3, r7
10042148:	2200      	movs	r2, #0
1004214a:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
1004214c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004214e:	689a      	ldr	r2, [r3, #8]
10042150:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042152:	691b      	ldr	r3, [r3, #16]
10042154:	431a      	orrs	r2, r3
10042156:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042158:	695b      	ldr	r3, [r3, #20]
1004215a:	431a      	orrs	r2, r3
1004215c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004215e:	69db      	ldr	r3, [r3, #28]
10042160:	4313      	orrs	r3, r2
10042162:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
10042164:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042166:	681b      	ldr	r3, [r3, #0]
10042168:	681b      	ldr	r3, [r3, #0]
1004216a:	4aa1      	ldr	r2, [pc, #644]	@ (100423f0 <UART_SetConfig+0x2b8>)
1004216c:	4013      	ands	r3, r2
1004216e:	0019      	movs	r1, r3
10042170:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042172:	681a      	ldr	r2, [r3, #0]
10042174:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10042176:	430b      	orrs	r3, r1
10042178:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
1004217a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004217c:	681b      	ldr	r3, [r3, #0]
1004217e:	685b      	ldr	r3, [r3, #4]
10042180:	4a9c      	ldr	r2, [pc, #624]	@ (100423f4 <UART_SetConfig+0x2bc>)
10042182:	4013      	ands	r3, r2
10042184:	0018      	movs	r0, r3
10042186:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042188:	68d9      	ldr	r1, [r3, #12]
1004218a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004218c:	681a      	ldr	r2, [r3, #0]
1004218e:	0003      	movs	r3, r0
10042190:	430b      	orrs	r3, r1
10042192:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
10042194:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042196:	699b      	ldr	r3, [r3, #24]
10042198:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
1004219a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004219c:	681b      	ldr	r3, [r3, #0]
1004219e:	4a96      	ldr	r2, [pc, #600]	@ (100423f8 <UART_SetConfig+0x2c0>)
100421a0:	4293      	cmp	r3, r2
100421a2:	d004      	beq.n	100421ae <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
100421a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421a6:	6a1b      	ldr	r3, [r3, #32]
100421a8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
100421aa:	4313      	orrs	r3, r2
100421ac:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
100421ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421b0:	681b      	ldr	r3, [r3, #0]
100421b2:	689b      	ldr	r3, [r3, #8]
100421b4:	4a91      	ldr	r2, [pc, #580]	@ (100423fc <UART_SetConfig+0x2c4>)
100421b6:	4013      	ands	r3, r2
100421b8:	0019      	movs	r1, r3
100421ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421bc:	681a      	ldr	r2, [r3, #0]
100421be:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
100421c0:	430b      	orrs	r3, r1
100421c2:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
100421c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421c6:	681b      	ldr	r3, [r3, #0]
100421c8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
100421ca:	220f      	movs	r2, #15
100421cc:	4393      	bics	r3, r2
100421ce:	0018      	movs	r0, r3
100421d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421d2:	6a59      	ldr	r1, [r3, #36]	@ 0x24
100421d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421d6:	681a      	ldr	r2, [r3, #0]
100421d8:	0003      	movs	r3, r0
100421da:	430b      	orrs	r3, r1
100421dc:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
100421de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421e0:	681b      	ldr	r3, [r3, #0]
100421e2:	4a85      	ldr	r2, [pc, #532]	@ (100423f8 <UART_SetConfig+0x2c0>)
100421e4:	4293      	cmp	r3, r2
100421e6:	d16d      	bne.n	100422c4 <UART_SetConfig+0x18c>
  {
    /* Retrieve frequency clock */
#if defined(RCC_CFGR_LPUCLKSEL)
    pclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_LPUART1);
100421e8:	2010      	movs	r0, #16
100421ea:	f7ff fe07 	bl	10041dfc <HAL_RCCEx_GetPeriphCLKFreq>
100421ee:	0003      	movs	r3, r0
100421f0:	637b      	str	r3, [r7, #52]	@ 0x34
#else
    pclk = UART_PERIPHCLK;
#endif /* RCC_CFGR_LPUCLKSEL */

    /* If proper clock source reported */
    if (pclk != 0U)
100421f2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
100421f4:	2b00      	cmp	r3, #0
100421f6:	d100      	bne.n	100421fa <UART_SetConfig+0xc2>
100421f8:	e0e3      	b.n	100423c2 <UART_SetConfig+0x28a>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
100421fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100421fc:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
100421fe:	4b80      	ldr	r3, [pc, #512]	@ (10042400 <UART_SetConfig+0x2c8>)
10042200:	0052      	lsls	r2, r2, #1
10042202:	5ad3      	ldrh	r3, [r2, r3]
10042204:	0019      	movs	r1, r3
10042206:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10042208:	f7fd ff64 	bl	100400d4 <__udivsi3>
1004220c:	0003      	movs	r3, r0
1004220e:	62bb      	str	r3, [r7, #40]	@ 0x28

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10042210:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042212:	685a      	ldr	r2, [r3, #4]
10042214:	0013      	movs	r3, r2
10042216:	005b      	lsls	r3, r3, #1
10042218:	189b      	adds	r3, r3, r2
1004221a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
1004221c:	429a      	cmp	r2, r3
1004221e:	d305      	bcc.n	1004222c <UART_SetConfig+0xf4>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
10042220:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042222:	685b      	ldr	r3, [r3, #4]
10042224:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10042226:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10042228:	429a      	cmp	r2, r3
1004222a:	d906      	bls.n	1004223a <UART_SetConfig+0x102>
      {
        ret = HAL_ERROR;
1004222c:	231b      	movs	r3, #27
1004222e:	2220      	movs	r2, #32
10042230:	189b      	adds	r3, r3, r2
10042232:	19db      	adds	r3, r3, r7
10042234:	2201      	movs	r2, #1
10042236:	701a      	strb	r2, [r3, #0]
10042238:	e0c3      	b.n	100423c2 <UART_SetConfig+0x28a>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
1004223a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
1004223c:	61bb      	str	r3, [r7, #24]
1004223e:	2300      	movs	r3, #0
10042240:	61fb      	str	r3, [r7, #28]
10042242:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042244:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10042246:	4b6e      	ldr	r3, [pc, #440]	@ (10042400 <UART_SetConfig+0x2c8>)
10042248:	0052      	lsls	r2, r2, #1
1004224a:	5ad3      	ldrh	r3, [r2, r3]
1004224c:	613b      	str	r3, [r7, #16]
1004224e:	2300      	movs	r3, #0
10042250:	617b      	str	r3, [r7, #20]
10042252:	693a      	ldr	r2, [r7, #16]
10042254:	697b      	ldr	r3, [r7, #20]
10042256:	69b8      	ldr	r0, [r7, #24]
10042258:	69f9      	ldr	r1, [r7, #28]
1004225a:	f7fd ffc7 	bl	100401ec <__aeabi_uldivmod>
1004225e:	0002      	movs	r2, r0
10042260:	000b      	movs	r3, r1
10042262:	0e11      	lsrs	r1, r2, #24
10042264:	021d      	lsls	r5, r3, #8
10042266:	430d      	orrs	r5, r1
10042268:	0214      	lsls	r4, r2, #8
1004226a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004226c:	685b      	ldr	r3, [r3, #4]
1004226e:	085b      	lsrs	r3, r3, #1
10042270:	60bb      	str	r3, [r7, #8]
10042272:	2300      	movs	r3, #0
10042274:	60fb      	str	r3, [r7, #12]
10042276:	68b8      	ldr	r0, [r7, #8]
10042278:	68f9      	ldr	r1, [r7, #12]
1004227a:	1900      	adds	r0, r0, r4
1004227c:	4169      	adcs	r1, r5
1004227e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042280:	685b      	ldr	r3, [r3, #4]
10042282:	603b      	str	r3, [r7, #0]
10042284:	2300      	movs	r3, #0
10042286:	607b      	str	r3, [r7, #4]
10042288:	683a      	ldr	r2, [r7, #0]
1004228a:	687b      	ldr	r3, [r7, #4]
1004228c:	f7fd ffae 	bl	100401ec <__aeabi_uldivmod>
10042290:	0002      	movs	r2, r0
10042292:	000b      	movs	r3, r1
10042294:	0013      	movs	r3, r2
10042296:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
10042298:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
1004229a:	23c0      	movs	r3, #192	@ 0xc0
1004229c:	009b      	lsls	r3, r3, #2
1004229e:	429a      	cmp	r2, r3
100422a0:	d309      	bcc.n	100422b6 <UART_SetConfig+0x17e>
100422a2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100422a4:	2380      	movs	r3, #128	@ 0x80
100422a6:	035b      	lsls	r3, r3, #13
100422a8:	429a      	cmp	r2, r3
100422aa:	d204      	bcs.n	100422b6 <UART_SetConfig+0x17e>
        {
          huart->Instance->BRR = usartdiv;
100422ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100422ae:	681b      	ldr	r3, [r3, #0]
100422b0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100422b2:	60da      	str	r2, [r3, #12]
100422b4:	e085      	b.n	100423c2 <UART_SetConfig+0x28a>
        }
        else
        {
          ret = HAL_ERROR;
100422b6:	231b      	movs	r3, #27
100422b8:	2220      	movs	r2, #32
100422ba:	189b      	adds	r3, r3, r2
100422bc:	19db      	adds	r3, r3, r7
100422be:	2201      	movs	r2, #1
100422c0:	701a      	strb	r2, [r3, #0]
100422c2:	e07e      	b.n	100423c2 <UART_SetConfig+0x28a>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
100422c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100422c6:	69da      	ldr	r2, [r3, #28]
100422c8:	2380      	movs	r3, #128	@ 0x80
100422ca:	021b      	lsls	r3, r3, #8
100422cc:	429a      	cmp	r2, r3
100422ce:	d148      	bne.n	10042362 <UART_SetConfig+0x22a>
  {
    pclk = UART_PERIPHCLK;
100422d0:	4b4c      	ldr	r3, [pc, #304]	@ (10042404 <UART_SetConfig+0x2cc>)
100422d2:	637b      	str	r3, [r7, #52]	@ 0x34

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
100422d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
100422d6:	2b00      	cmp	r3, #0
100422d8:	d100      	bne.n	100422dc <UART_SetConfig+0x1a4>
100422da:	e072      	b.n	100423c2 <UART_SetConfig+0x28a>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
100422dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100422de:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
100422e0:	4b47      	ldr	r3, [pc, #284]	@ (10042400 <UART_SetConfig+0x2c8>)
100422e2:	0052      	lsls	r2, r2, #1
100422e4:	5ad3      	ldrh	r3, [r2, r3]
100422e6:	0019      	movs	r1, r3
100422e8:	6b78      	ldr	r0, [r7, #52]	@ 0x34
100422ea:	f7fd fef3 	bl	100400d4 <__udivsi3>
100422ee:	0003      	movs	r3, r0
100422f0:	005a      	lsls	r2, r3, #1
100422f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100422f4:	685b      	ldr	r3, [r3, #4]
100422f6:	085b      	lsrs	r3, r3, #1
100422f8:	18d2      	adds	r2, r2, r3
100422fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100422fc:	685b      	ldr	r3, [r3, #4]
100422fe:	0019      	movs	r1, r3
10042300:	0010      	movs	r0, r2
10042302:	f7fd fee7 	bl	100400d4 <__udivsi3>
10042306:	0003      	movs	r3, r0
10042308:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
1004230a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
1004230c:	2b0f      	cmp	r3, #15
1004230e:	d921      	bls.n	10042354 <UART_SetConfig+0x21c>
10042310:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10042312:	2380      	movs	r3, #128	@ 0x80
10042314:	025b      	lsls	r3, r3, #9
10042316:	429a      	cmp	r2, r3
10042318:	d21c      	bcs.n	10042354 <UART_SetConfig+0x21c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
1004231a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
1004231c:	b29a      	uxth	r2, r3
1004231e:	200e      	movs	r0, #14
10042320:	2420      	movs	r4, #32
10042322:	1903      	adds	r3, r0, r4
10042324:	19db      	adds	r3, r3, r7
10042326:	210f      	movs	r1, #15
10042328:	438a      	bics	r2, r1
1004232a:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
1004232c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
1004232e:	085b      	lsrs	r3, r3, #1
10042330:	b29b      	uxth	r3, r3
10042332:	2207      	movs	r2, #7
10042334:	4013      	ands	r3, r2
10042336:	b299      	uxth	r1, r3
10042338:	1903      	adds	r3, r0, r4
1004233a:	19db      	adds	r3, r3, r7
1004233c:	1902      	adds	r2, r0, r4
1004233e:	19d2      	adds	r2, r2, r7
10042340:	8812      	ldrh	r2, [r2, #0]
10042342:	430a      	orrs	r2, r1
10042344:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
10042346:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042348:	681b      	ldr	r3, [r3, #0]
1004234a:	1902      	adds	r2, r0, r4
1004234c:	19d2      	adds	r2, r2, r7
1004234e:	8812      	ldrh	r2, [r2, #0]
10042350:	60da      	str	r2, [r3, #12]
10042352:	e036      	b.n	100423c2 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
10042354:	231b      	movs	r3, #27
10042356:	2220      	movs	r2, #32
10042358:	189b      	adds	r3, r3, r2
1004235a:	19db      	adds	r3, r3, r7
1004235c:	2201      	movs	r2, #1
1004235e:	701a      	strb	r2, [r3, #0]
10042360:	e02f      	b.n	100423c2 <UART_SetConfig+0x28a>
      }
    }
  }
  else
  {
    pclk = UART_PERIPHCLK;
10042362:	4b28      	ldr	r3, [pc, #160]	@ (10042404 <UART_SetConfig+0x2cc>)
10042364:	637b      	str	r3, [r7, #52]	@ 0x34

    if (pclk != 0U)
10042366:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10042368:	2b00      	cmp	r3, #0
1004236a:	d02a      	beq.n	100423c2 <UART_SetConfig+0x28a>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
1004236c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004236e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10042370:	4b23      	ldr	r3, [pc, #140]	@ (10042400 <UART_SetConfig+0x2c8>)
10042372:	0052      	lsls	r2, r2, #1
10042374:	5ad3      	ldrh	r3, [r2, r3]
10042376:	0019      	movs	r1, r3
10042378:	6b78      	ldr	r0, [r7, #52]	@ 0x34
1004237a:	f7fd feab 	bl	100400d4 <__udivsi3>
1004237e:	0003      	movs	r3, r0
10042380:	001a      	movs	r2, r3
10042382:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042384:	685b      	ldr	r3, [r3, #4]
10042386:	085b      	lsrs	r3, r3, #1
10042388:	18d2      	adds	r2, r2, r3
1004238a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004238c:	685b      	ldr	r3, [r3, #4]
1004238e:	0019      	movs	r1, r3
10042390:	0010      	movs	r0, r2
10042392:	f7fd fe9f 	bl	100400d4 <__udivsi3>
10042396:	0003      	movs	r3, r0
10042398:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
1004239a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
1004239c:	2b0f      	cmp	r3, #15
1004239e:	d90a      	bls.n	100423b6 <UART_SetConfig+0x27e>
100423a0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
100423a2:	2380      	movs	r3, #128	@ 0x80
100423a4:	025b      	lsls	r3, r3, #9
100423a6:	429a      	cmp	r2, r3
100423a8:	d205      	bcs.n	100423b6 <UART_SetConfig+0x27e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
100423aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
100423ac:	b29a      	uxth	r2, r3
100423ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100423b0:	681b      	ldr	r3, [r3, #0]
100423b2:	60da      	str	r2, [r3, #12]
100423b4:	e005      	b.n	100423c2 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
100423b6:	231b      	movs	r3, #27
100423b8:	2220      	movs	r2, #32
100423ba:	189b      	adds	r3, r3, r2
100423bc:	19db      	adds	r3, r3, r7
100423be:	2201      	movs	r2, #1
100423c0:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
100423c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100423c4:	226a      	movs	r2, #106	@ 0x6a
100423c6:	2101      	movs	r1, #1
100423c8:	5299      	strh	r1, [r3, r2]
  huart->NbRxDataToProcess = 1;
100423ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100423cc:	2268      	movs	r2, #104	@ 0x68
100423ce:	2101      	movs	r1, #1
100423d0:	5299      	strh	r1, [r3, r2]

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
100423d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100423d4:	2200      	movs	r2, #0
100423d6:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
100423d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100423da:	2200      	movs	r2, #0
100423dc:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
100423de:	231b      	movs	r3, #27
100423e0:	2220      	movs	r2, #32
100423e2:	189b      	adds	r3, r3, r2
100423e4:	19db      	adds	r3, r3, r7
100423e6:	781b      	ldrb	r3, [r3, #0]
}
100423e8:	0018      	movs	r0, r3
100423ea:	46bd      	mov	sp, r7
100423ec:	b010      	add	sp, #64	@ 0x40
100423ee:	bdb0      	pop	{r4, r5, r7, pc}
100423f0:	cfff69f3 	.word	0xcfff69f3
100423f4:	ffffcfff 	.word	0xffffcfff
100423f8:	41005000 	.word	0x41005000
100423fc:	11fff4ff 	.word	0x11fff4ff
10042400:	10043860 	.word	0x10043860
10042404:	00f42400 	.word	0x00f42400

10042408 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
10042408:	b580      	push	{r7, lr}
1004240a:	b082      	sub	sp, #8
1004240c:	af00      	add	r7, sp, #0
1004240e:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
10042410:	687b      	ldr	r3, [r7, #4]
10042412:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10042414:	2208      	movs	r2, #8
10042416:	4013      	ands	r3, r2
10042418:	d00b      	beq.n	10042432 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
1004241a:	687b      	ldr	r3, [r7, #4]
1004241c:	681b      	ldr	r3, [r3, #0]
1004241e:	685b      	ldr	r3, [r3, #4]
10042420:	4a4a      	ldr	r2, [pc, #296]	@ (1004254c <UART_AdvFeatureConfig+0x144>)
10042422:	4013      	ands	r3, r2
10042424:	0019      	movs	r1, r3
10042426:	687b      	ldr	r3, [r7, #4]
10042428:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
1004242a:	687b      	ldr	r3, [r7, #4]
1004242c:	681b      	ldr	r3, [r3, #0]
1004242e:	430a      	orrs	r2, r1
10042430:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
10042432:	687b      	ldr	r3, [r7, #4]
10042434:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10042436:	2201      	movs	r2, #1
10042438:	4013      	ands	r3, r2
1004243a:	d00b      	beq.n	10042454 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
1004243c:	687b      	ldr	r3, [r7, #4]
1004243e:	681b      	ldr	r3, [r3, #0]
10042440:	685b      	ldr	r3, [r3, #4]
10042442:	4a43      	ldr	r2, [pc, #268]	@ (10042550 <UART_AdvFeatureConfig+0x148>)
10042444:	4013      	ands	r3, r2
10042446:	0019      	movs	r1, r3
10042448:	687b      	ldr	r3, [r7, #4]
1004244a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
1004244c:	687b      	ldr	r3, [r7, #4]
1004244e:	681b      	ldr	r3, [r3, #0]
10042450:	430a      	orrs	r2, r1
10042452:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
10042454:	687b      	ldr	r3, [r7, #4]
10042456:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10042458:	2202      	movs	r2, #2
1004245a:	4013      	ands	r3, r2
1004245c:	d00b      	beq.n	10042476 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
1004245e:	687b      	ldr	r3, [r7, #4]
10042460:	681b      	ldr	r3, [r3, #0]
10042462:	685b      	ldr	r3, [r3, #4]
10042464:	4a3b      	ldr	r2, [pc, #236]	@ (10042554 <UART_AdvFeatureConfig+0x14c>)
10042466:	4013      	ands	r3, r2
10042468:	0019      	movs	r1, r3
1004246a:	687b      	ldr	r3, [r7, #4]
1004246c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
1004246e:	687b      	ldr	r3, [r7, #4]
10042470:	681b      	ldr	r3, [r3, #0]
10042472:	430a      	orrs	r2, r1
10042474:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
10042476:	687b      	ldr	r3, [r7, #4]
10042478:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
1004247a:	2204      	movs	r2, #4
1004247c:	4013      	ands	r3, r2
1004247e:	d00b      	beq.n	10042498 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
10042480:	687b      	ldr	r3, [r7, #4]
10042482:	681b      	ldr	r3, [r3, #0]
10042484:	685b      	ldr	r3, [r3, #4]
10042486:	4a34      	ldr	r2, [pc, #208]	@ (10042558 <UART_AdvFeatureConfig+0x150>)
10042488:	4013      	ands	r3, r2
1004248a:	0019      	movs	r1, r3
1004248c:	687b      	ldr	r3, [r7, #4]
1004248e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
10042490:	687b      	ldr	r3, [r7, #4]
10042492:	681b      	ldr	r3, [r3, #0]
10042494:	430a      	orrs	r2, r1
10042496:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
10042498:	687b      	ldr	r3, [r7, #4]
1004249a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
1004249c:	2210      	movs	r2, #16
1004249e:	4013      	ands	r3, r2
100424a0:	d00b      	beq.n	100424ba <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
100424a2:	687b      	ldr	r3, [r7, #4]
100424a4:	681b      	ldr	r3, [r3, #0]
100424a6:	689b      	ldr	r3, [r3, #8]
100424a8:	4a2c      	ldr	r2, [pc, #176]	@ (1004255c <UART_AdvFeatureConfig+0x154>)
100424aa:	4013      	ands	r3, r2
100424ac:	0019      	movs	r1, r3
100424ae:	687b      	ldr	r3, [r7, #4]
100424b0:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
100424b2:	687b      	ldr	r3, [r7, #4]
100424b4:	681b      	ldr	r3, [r3, #0]
100424b6:	430a      	orrs	r2, r1
100424b8:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
100424ba:	687b      	ldr	r3, [r7, #4]
100424bc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100424be:	2220      	movs	r2, #32
100424c0:	4013      	ands	r3, r2
100424c2:	d00b      	beq.n	100424dc <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
100424c4:	687b      	ldr	r3, [r7, #4]
100424c6:	681b      	ldr	r3, [r3, #0]
100424c8:	689b      	ldr	r3, [r3, #8]
100424ca:	4a25      	ldr	r2, [pc, #148]	@ (10042560 <UART_AdvFeatureConfig+0x158>)
100424cc:	4013      	ands	r3, r2
100424ce:	0019      	movs	r1, r3
100424d0:	687b      	ldr	r3, [r7, #4]
100424d2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
100424d4:	687b      	ldr	r3, [r7, #4]
100424d6:	681b      	ldr	r3, [r3, #0]
100424d8:	430a      	orrs	r2, r1
100424da:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
100424dc:	687b      	ldr	r3, [r7, #4]
100424de:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
100424e0:	2240      	movs	r2, #64	@ 0x40
100424e2:	4013      	ands	r3, r2
100424e4:	d01d      	beq.n	10042522 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
100424e6:	687b      	ldr	r3, [r7, #4]
100424e8:	681b      	ldr	r3, [r3, #0]
100424ea:	685b      	ldr	r3, [r3, #4]
100424ec:	4a1d      	ldr	r2, [pc, #116]	@ (10042564 <UART_AdvFeatureConfig+0x15c>)
100424ee:	4013      	ands	r3, r2
100424f0:	0019      	movs	r1, r3
100424f2:	687b      	ldr	r3, [r7, #4]
100424f4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
100424f6:	687b      	ldr	r3, [r7, #4]
100424f8:	681b      	ldr	r3, [r3, #0]
100424fa:	430a      	orrs	r2, r1
100424fc:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
100424fe:	687b      	ldr	r3, [r7, #4]
10042500:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10042502:	2380      	movs	r3, #128	@ 0x80
10042504:	035b      	lsls	r3, r3, #13
10042506:	429a      	cmp	r2, r3
10042508:	d10b      	bne.n	10042522 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
1004250a:	687b      	ldr	r3, [r7, #4]
1004250c:	681b      	ldr	r3, [r3, #0]
1004250e:	685b      	ldr	r3, [r3, #4]
10042510:	4a15      	ldr	r2, [pc, #84]	@ (10042568 <UART_AdvFeatureConfig+0x160>)
10042512:	4013      	ands	r3, r2
10042514:	0019      	movs	r1, r3
10042516:	687b      	ldr	r3, [r7, #4]
10042518:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
1004251a:	687b      	ldr	r3, [r7, #4]
1004251c:	681b      	ldr	r3, [r3, #0]
1004251e:	430a      	orrs	r2, r1
10042520:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
10042522:	687b      	ldr	r3, [r7, #4]
10042524:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10042526:	2280      	movs	r2, #128	@ 0x80
10042528:	4013      	ands	r3, r2
1004252a:	d00b      	beq.n	10042544 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
1004252c:	687b      	ldr	r3, [r7, #4]
1004252e:	681b      	ldr	r3, [r3, #0]
10042530:	685b      	ldr	r3, [r3, #4]
10042532:	4a0e      	ldr	r2, [pc, #56]	@ (1004256c <UART_AdvFeatureConfig+0x164>)
10042534:	4013      	ands	r3, r2
10042536:	0019      	movs	r1, r3
10042538:	687b      	ldr	r3, [r7, #4]
1004253a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
1004253c:	687b      	ldr	r3, [r7, #4]
1004253e:	681b      	ldr	r3, [r3, #0]
10042540:	430a      	orrs	r2, r1
10042542:	605a      	str	r2, [r3, #4]
  }
}
10042544:	46c0      	nop			@ (mov r8, r8)
10042546:	46bd      	mov	sp, r7
10042548:	b002      	add	sp, #8
1004254a:	bd80      	pop	{r7, pc}
1004254c:	ffff7fff 	.word	0xffff7fff
10042550:	fffdffff 	.word	0xfffdffff
10042554:	fffeffff 	.word	0xfffeffff
10042558:	fffbffff 	.word	0xfffbffff
1004255c:	ffffefff 	.word	0xffffefff
10042560:	ffffdfff 	.word	0xffffdfff
10042564:	ffefffff 	.word	0xffefffff
10042568:	ff9fffff 	.word	0xff9fffff
1004256c:	fff7ffff 	.word	0xfff7ffff

10042570 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
10042570:	b580      	push	{r7, lr}
10042572:	b092      	sub	sp, #72	@ 0x48
10042574:	af02      	add	r7, sp, #8
10042576:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
10042578:	687b      	ldr	r3, [r7, #4]
1004257a:	2290      	movs	r2, #144	@ 0x90
1004257c:	2100      	movs	r1, #0
1004257e:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
10042580:	f7fe fe8c 	bl	1004129c <HAL_GetTick>
10042584:	0003      	movs	r3, r0
10042586:	63fb      	str	r3, [r7, #60]	@ 0x3c

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
10042588:	687b      	ldr	r3, [r7, #4]
1004258a:	681b      	ldr	r3, [r3, #0]
1004258c:	681b      	ldr	r3, [r3, #0]
1004258e:	2208      	movs	r2, #8
10042590:	4013      	ands	r3, r2
10042592:	2b08      	cmp	r3, #8
10042594:	d12d      	bne.n	100425f2 <UART_CheckIdleState+0x82>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
10042596:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10042598:	2280      	movs	r2, #128	@ 0x80
1004259a:	0391      	lsls	r1, r2, #14
1004259c:	6878      	ldr	r0, [r7, #4]
1004259e:	4a47      	ldr	r2, [pc, #284]	@ (100426bc <UART_CheckIdleState+0x14c>)
100425a0:	9200      	str	r2, [sp, #0]
100425a2:	2200      	movs	r2, #0
100425a4:	f000 f88e 	bl	100426c4 <UART_WaitOnFlagUntilTimeout>
100425a8:	1e03      	subs	r3, r0, #0
100425aa:	d022      	beq.n	100425f2 <UART_CheckIdleState+0x82>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100425ac:	f3ef 8310 	mrs	r3, PRIMASK
100425b0:	627b      	str	r3, [r7, #36]	@ 0x24
  return(result);
100425b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
100425b4:	63bb      	str	r3, [r7, #56]	@ 0x38
100425b6:	2301      	movs	r3, #1
100425b8:	62bb      	str	r3, [r7, #40]	@ 0x28
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100425ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
100425bc:	f383 8810 	msr	PRIMASK, r3
}
100425c0:	46c0      	nop			@ (mov r8, r8)
100425c2:	687b      	ldr	r3, [r7, #4]
100425c4:	681b      	ldr	r3, [r3, #0]
100425c6:	681a      	ldr	r2, [r3, #0]
100425c8:	687b      	ldr	r3, [r7, #4]
100425ca:	681b      	ldr	r3, [r3, #0]
100425cc:	2180      	movs	r1, #128	@ 0x80
100425ce:	438a      	bics	r2, r1
100425d0:	601a      	str	r2, [r3, #0]
100425d2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
100425d4:	62fb      	str	r3, [r7, #44]	@ 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100425d6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
100425d8:	f383 8810 	msr	PRIMASK, r3
}
100425dc:	46c0      	nop			@ (mov r8, r8)

      huart->gState = HAL_UART_STATE_READY;
100425de:	687b      	ldr	r3, [r7, #4]
100425e0:	2288      	movs	r2, #136	@ 0x88
100425e2:	2120      	movs	r1, #32
100425e4:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
100425e6:	687b      	ldr	r3, [r7, #4]
100425e8:	2284      	movs	r2, #132	@ 0x84
100425ea:	2100      	movs	r1, #0
100425ec:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
100425ee:	2303      	movs	r3, #3
100425f0:	e060      	b.n	100426b4 <UART_CheckIdleState+0x144>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
100425f2:	687b      	ldr	r3, [r7, #4]
100425f4:	681b      	ldr	r3, [r3, #0]
100425f6:	681b      	ldr	r3, [r3, #0]
100425f8:	2204      	movs	r2, #4
100425fa:	4013      	ands	r3, r2
100425fc:	2b04      	cmp	r3, #4
100425fe:	d146      	bne.n	1004268e <UART_CheckIdleState+0x11e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
10042600:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10042602:	2280      	movs	r2, #128	@ 0x80
10042604:	03d1      	lsls	r1, r2, #15
10042606:	6878      	ldr	r0, [r7, #4]
10042608:	4a2c      	ldr	r2, [pc, #176]	@ (100426bc <UART_CheckIdleState+0x14c>)
1004260a:	9200      	str	r2, [sp, #0]
1004260c:	2200      	movs	r2, #0
1004260e:	f000 f859 	bl	100426c4 <UART_WaitOnFlagUntilTimeout>
10042612:	1e03      	subs	r3, r0, #0
10042614:	d03b      	beq.n	1004268e <UART_CheckIdleState+0x11e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10042616:	f3ef 8310 	mrs	r3, PRIMASK
1004261a:	60fb      	str	r3, [r7, #12]
  return(result);
1004261c:	68fb      	ldr	r3, [r7, #12]
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
1004261e:	637b      	str	r3, [r7, #52]	@ 0x34
10042620:	2301      	movs	r3, #1
10042622:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042624:	693b      	ldr	r3, [r7, #16]
10042626:	f383 8810 	msr	PRIMASK, r3
}
1004262a:	46c0      	nop			@ (mov r8, r8)
1004262c:	687b      	ldr	r3, [r7, #4]
1004262e:	681b      	ldr	r3, [r3, #0]
10042630:	681a      	ldr	r2, [r3, #0]
10042632:	687b      	ldr	r3, [r7, #4]
10042634:	681b      	ldr	r3, [r3, #0]
10042636:	4922      	ldr	r1, [pc, #136]	@ (100426c0 <UART_CheckIdleState+0x150>)
10042638:	400a      	ands	r2, r1
1004263a:	601a      	str	r2, [r3, #0]
1004263c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
1004263e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042640:	697b      	ldr	r3, [r7, #20]
10042642:	f383 8810 	msr	PRIMASK, r3
}
10042646:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10042648:	f3ef 8310 	mrs	r3, PRIMASK
1004264c:	61bb      	str	r3, [r7, #24]
  return(result);
1004264e:	69bb      	ldr	r3, [r7, #24]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
10042650:	633b      	str	r3, [r7, #48]	@ 0x30
10042652:	2301      	movs	r3, #1
10042654:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042656:	69fb      	ldr	r3, [r7, #28]
10042658:	f383 8810 	msr	PRIMASK, r3
}
1004265c:	46c0      	nop			@ (mov r8, r8)
1004265e:	687b      	ldr	r3, [r7, #4]
10042660:	681b      	ldr	r3, [r3, #0]
10042662:	689a      	ldr	r2, [r3, #8]
10042664:	687b      	ldr	r3, [r7, #4]
10042666:	681b      	ldr	r3, [r3, #0]
10042668:	2101      	movs	r1, #1
1004266a:	438a      	bics	r2, r1
1004266c:	609a      	str	r2, [r3, #8]
1004266e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10042670:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042672:	6a3b      	ldr	r3, [r7, #32]
10042674:	f383 8810 	msr	PRIMASK, r3
}
10042678:	46c0      	nop			@ (mov r8, r8)

      huart->RxState = HAL_UART_STATE_READY;
1004267a:	687b      	ldr	r3, [r7, #4]
1004267c:	228c      	movs	r2, #140	@ 0x8c
1004267e:	2120      	movs	r1, #32
10042680:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
10042682:	687b      	ldr	r3, [r7, #4]
10042684:	2284      	movs	r2, #132	@ 0x84
10042686:	2100      	movs	r1, #0
10042688:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
1004268a:	2303      	movs	r3, #3
1004268c:	e012      	b.n	100426b4 <UART_CheckIdleState+0x144>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
1004268e:	687b      	ldr	r3, [r7, #4]
10042690:	2288      	movs	r2, #136	@ 0x88
10042692:	2120      	movs	r1, #32
10042694:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_READY;
10042696:	687b      	ldr	r3, [r7, #4]
10042698:	228c      	movs	r2, #140	@ 0x8c
1004269a:	2120      	movs	r1, #32
1004269c:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
1004269e:	687b      	ldr	r3, [r7, #4]
100426a0:	2200      	movs	r2, #0
100426a2:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
100426a4:	687b      	ldr	r3, [r7, #4]
100426a6:	2200      	movs	r2, #0
100426a8:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
100426aa:	687b      	ldr	r3, [r7, #4]
100426ac:	2284      	movs	r2, #132	@ 0x84
100426ae:	2100      	movs	r1, #0
100426b0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
100426b2:	2300      	movs	r3, #0
}
100426b4:	0018      	movs	r0, r3
100426b6:	46bd      	mov	sp, r7
100426b8:	b010      	add	sp, #64	@ 0x40
100426ba:	bd80      	pop	{r7, pc}
100426bc:	01ffffff 	.word	0x01ffffff
100426c0:	fffffedf 	.word	0xfffffedf

100426c4 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
100426c4:	b580      	push	{r7, lr}
100426c6:	b084      	sub	sp, #16
100426c8:	af00      	add	r7, sp, #0
100426ca:	60f8      	str	r0, [r7, #12]
100426cc:	60b9      	str	r1, [r7, #8]
100426ce:	603b      	str	r3, [r7, #0]
100426d0:	1dfb      	adds	r3, r7, #7
100426d2:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
100426d4:	e051      	b.n	1004277a <UART_WaitOnFlagUntilTimeout+0xb6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
100426d6:	69bb      	ldr	r3, [r7, #24]
100426d8:	3301      	adds	r3, #1
100426da:	d04e      	beq.n	1004277a <UART_WaitOnFlagUntilTimeout+0xb6>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
100426dc:	f7fe fdde 	bl	1004129c <HAL_GetTick>
100426e0:	0002      	movs	r2, r0
100426e2:	683b      	ldr	r3, [r7, #0]
100426e4:	1ad3      	subs	r3, r2, r3
100426e6:	69ba      	ldr	r2, [r7, #24]
100426e8:	429a      	cmp	r2, r3
100426ea:	d302      	bcc.n	100426f2 <UART_WaitOnFlagUntilTimeout+0x2e>
100426ec:	69bb      	ldr	r3, [r7, #24]
100426ee:	2b00      	cmp	r3, #0
100426f0:	d101      	bne.n	100426f6 <UART_WaitOnFlagUntilTimeout+0x32>
      {

        return HAL_TIMEOUT;
100426f2:	2303      	movs	r3, #3
100426f4:	e051      	b.n	1004279a <UART_WaitOnFlagUntilTimeout+0xd6>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
100426f6:	68fb      	ldr	r3, [r7, #12]
100426f8:	681b      	ldr	r3, [r3, #0]
100426fa:	681b      	ldr	r3, [r3, #0]
100426fc:	2204      	movs	r2, #4
100426fe:	4013      	ands	r3, r2
10042700:	d03b      	beq.n	1004277a <UART_WaitOnFlagUntilTimeout+0xb6>
10042702:	68bb      	ldr	r3, [r7, #8]
10042704:	2b80      	cmp	r3, #128	@ 0x80
10042706:	d038      	beq.n	1004277a <UART_WaitOnFlagUntilTimeout+0xb6>
10042708:	68bb      	ldr	r3, [r7, #8]
1004270a:	2b40      	cmp	r3, #64	@ 0x40
1004270c:	d035      	beq.n	1004277a <UART_WaitOnFlagUntilTimeout+0xb6>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
1004270e:	68fb      	ldr	r3, [r7, #12]
10042710:	681b      	ldr	r3, [r3, #0]
10042712:	69db      	ldr	r3, [r3, #28]
10042714:	2208      	movs	r2, #8
10042716:	4013      	ands	r3, r2
10042718:	2b08      	cmp	r3, #8
1004271a:	d111      	bne.n	10042740 <UART_WaitOnFlagUntilTimeout+0x7c>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
1004271c:	68fb      	ldr	r3, [r7, #12]
1004271e:	681b      	ldr	r3, [r3, #0]
10042720:	2208      	movs	r2, #8
10042722:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
10042724:	68fb      	ldr	r3, [r7, #12]
10042726:	0018      	movs	r0, r3
10042728:	f000 f83c 	bl	100427a4 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
1004272c:	68fb      	ldr	r3, [r7, #12]
1004272e:	2290      	movs	r2, #144	@ 0x90
10042730:	2108      	movs	r1, #8
10042732:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
10042734:	68fb      	ldr	r3, [r7, #12]
10042736:	2284      	movs	r2, #132	@ 0x84
10042738:	2100      	movs	r1, #0
1004273a:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
1004273c:	2301      	movs	r3, #1
1004273e:	e02c      	b.n	1004279a <UART_WaitOnFlagUntilTimeout+0xd6>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
10042740:	68fb      	ldr	r3, [r7, #12]
10042742:	681b      	ldr	r3, [r3, #0]
10042744:	69da      	ldr	r2, [r3, #28]
10042746:	2380      	movs	r3, #128	@ 0x80
10042748:	011b      	lsls	r3, r3, #4
1004274a:	401a      	ands	r2, r3
1004274c:	2380      	movs	r3, #128	@ 0x80
1004274e:	011b      	lsls	r3, r3, #4
10042750:	429a      	cmp	r2, r3
10042752:	d112      	bne.n	1004277a <UART_WaitOnFlagUntilTimeout+0xb6>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
10042754:	68fb      	ldr	r3, [r7, #12]
10042756:	681b      	ldr	r3, [r3, #0]
10042758:	2280      	movs	r2, #128	@ 0x80
1004275a:	0112      	lsls	r2, r2, #4
1004275c:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
1004275e:	68fb      	ldr	r3, [r7, #12]
10042760:	0018      	movs	r0, r3
10042762:	f000 f81f 	bl	100427a4 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
10042766:	68fb      	ldr	r3, [r7, #12]
10042768:	2290      	movs	r2, #144	@ 0x90
1004276a:	2120      	movs	r1, #32
1004276c:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
1004276e:	68fb      	ldr	r3, [r7, #12]
10042770:	2284      	movs	r2, #132	@ 0x84
10042772:	2100      	movs	r1, #0
10042774:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
10042776:	2303      	movs	r3, #3
10042778:	e00f      	b.n	1004279a <UART_WaitOnFlagUntilTimeout+0xd6>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
1004277a:	68fb      	ldr	r3, [r7, #12]
1004277c:	681b      	ldr	r3, [r3, #0]
1004277e:	69db      	ldr	r3, [r3, #28]
10042780:	68ba      	ldr	r2, [r7, #8]
10042782:	4013      	ands	r3, r2
10042784:	68ba      	ldr	r2, [r7, #8]
10042786:	1ad3      	subs	r3, r2, r3
10042788:	425a      	negs	r2, r3
1004278a:	4153      	adcs	r3, r2
1004278c:	b2db      	uxtb	r3, r3
1004278e:	001a      	movs	r2, r3
10042790:	1dfb      	adds	r3, r7, #7
10042792:	781b      	ldrb	r3, [r3, #0]
10042794:	429a      	cmp	r2, r3
10042796:	d09e      	beq.n	100426d6 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
10042798:	2300      	movs	r3, #0
}
1004279a:	0018      	movs	r0, r3
1004279c:	46bd      	mov	sp, r7
1004279e:	b004      	add	sp, #16
100427a0:	bd80      	pop	{r7, pc}
	...

100427a4 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
100427a4:	b580      	push	{r7, lr}
100427a6:	b08e      	sub	sp, #56	@ 0x38
100427a8:	af00      	add	r7, sp, #0
100427aa:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100427ac:	f3ef 8310 	mrs	r3, PRIMASK
100427b0:	617b      	str	r3, [r7, #20]
  return(result);
100427b2:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
100427b4:	637b      	str	r3, [r7, #52]	@ 0x34
100427b6:	2301      	movs	r3, #1
100427b8:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100427ba:	69bb      	ldr	r3, [r7, #24]
100427bc:	f383 8810 	msr	PRIMASK, r3
}
100427c0:	46c0      	nop			@ (mov r8, r8)
100427c2:	687b      	ldr	r3, [r7, #4]
100427c4:	681b      	ldr	r3, [r3, #0]
100427c6:	681a      	ldr	r2, [r3, #0]
100427c8:	687b      	ldr	r3, [r7, #4]
100427ca:	681b      	ldr	r3, [r3, #0]
100427cc:	4926      	ldr	r1, [pc, #152]	@ (10042868 <UART_EndRxTransfer+0xc4>)
100427ce:	400a      	ands	r2, r1
100427d0:	601a      	str	r2, [r3, #0]
100427d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
100427d4:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100427d6:	69fb      	ldr	r3, [r7, #28]
100427d8:	f383 8810 	msr	PRIMASK, r3
}
100427dc:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100427de:	f3ef 8310 	mrs	r3, PRIMASK
100427e2:	623b      	str	r3, [r7, #32]
  return(result);
100427e4:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
100427e6:	633b      	str	r3, [r7, #48]	@ 0x30
100427e8:	2301      	movs	r3, #1
100427ea:	627b      	str	r3, [r7, #36]	@ 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100427ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100427ee:	f383 8810 	msr	PRIMASK, r3
}
100427f2:	46c0      	nop			@ (mov r8, r8)
100427f4:	687b      	ldr	r3, [r7, #4]
100427f6:	681b      	ldr	r3, [r3, #0]
100427f8:	689a      	ldr	r2, [r3, #8]
100427fa:	687b      	ldr	r3, [r7, #4]
100427fc:	681b      	ldr	r3, [r3, #0]
100427fe:	491b      	ldr	r1, [pc, #108]	@ (1004286c <UART_EndRxTransfer+0xc8>)
10042800:	400a      	ands	r2, r1
10042802:	609a      	str	r2, [r3, #8]
10042804:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10042806:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042808:	6abb      	ldr	r3, [r7, #40]	@ 0x28
1004280a:	f383 8810 	msr	PRIMASK, r3
}
1004280e:	46c0      	nop			@ (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
10042810:	687b      	ldr	r3, [r7, #4]
10042812:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
10042814:	2b01      	cmp	r3, #1
10042816:	d118      	bne.n	1004284a <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10042818:	f3ef 8310 	mrs	r3, PRIMASK
1004281c:	60bb      	str	r3, [r7, #8]
  return(result);
1004281e:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
10042820:	62fb      	str	r3, [r7, #44]	@ 0x2c
10042822:	2301      	movs	r3, #1
10042824:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042826:	68fb      	ldr	r3, [r7, #12]
10042828:	f383 8810 	msr	PRIMASK, r3
}
1004282c:	46c0      	nop			@ (mov r8, r8)
1004282e:	687b      	ldr	r3, [r7, #4]
10042830:	681b      	ldr	r3, [r3, #0]
10042832:	681a      	ldr	r2, [r3, #0]
10042834:	687b      	ldr	r3, [r7, #4]
10042836:	681b      	ldr	r3, [r3, #0]
10042838:	2110      	movs	r1, #16
1004283a:	438a      	bics	r2, r1
1004283c:	601a      	str	r2, [r3, #0]
1004283e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10042840:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042842:	693b      	ldr	r3, [r7, #16]
10042844:	f383 8810 	msr	PRIMASK, r3
}
10042848:	46c0      	nop			@ (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
1004284a:	687b      	ldr	r3, [r7, #4]
1004284c:	228c      	movs	r2, #140	@ 0x8c
1004284e:	2120      	movs	r1, #32
10042850:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
10042852:	687b      	ldr	r3, [r7, #4]
10042854:	2200      	movs	r2, #0
10042856:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
10042858:	687b      	ldr	r3, [r7, #4]
1004285a:	2200      	movs	r2, #0
1004285c:	675a      	str	r2, [r3, #116]	@ 0x74
}
1004285e:	46c0      	nop			@ (mov r8, r8)
10042860:	46bd      	mov	sp, r7
10042862:	b00e      	add	sp, #56	@ 0x38
10042864:	bd80      	pop	{r7, pc}
10042866:	46c0      	nop			@ (mov r8, r8)
10042868:	fffffedf 	.word	0xfffffedf
1004286c:	effffffe 	.word	0xeffffffe

10042870 <std>:
10042870:	2300      	movs	r3, #0
10042872:	b510      	push	{r4, lr}
10042874:	0004      	movs	r4, r0
10042876:	6003      	str	r3, [r0, #0]
10042878:	6043      	str	r3, [r0, #4]
1004287a:	6083      	str	r3, [r0, #8]
1004287c:	8181      	strh	r1, [r0, #12]
1004287e:	6643      	str	r3, [r0, #100]	@ 0x64
10042880:	81c2      	strh	r2, [r0, #14]
10042882:	6103      	str	r3, [r0, #16]
10042884:	6143      	str	r3, [r0, #20]
10042886:	6183      	str	r3, [r0, #24]
10042888:	0019      	movs	r1, r3
1004288a:	2208      	movs	r2, #8
1004288c:	305c      	adds	r0, #92	@ 0x5c
1004288e:	f000 fa0f 	bl	10042cb0 <memset>
10042892:	4b0b      	ldr	r3, [pc, #44]	@ (100428c0 <std+0x50>)
10042894:	6224      	str	r4, [r4, #32]
10042896:	6263      	str	r3, [r4, #36]	@ 0x24
10042898:	4b0a      	ldr	r3, [pc, #40]	@ (100428c4 <std+0x54>)
1004289a:	62a3      	str	r3, [r4, #40]	@ 0x28
1004289c:	4b0a      	ldr	r3, [pc, #40]	@ (100428c8 <std+0x58>)
1004289e:	62e3      	str	r3, [r4, #44]	@ 0x2c
100428a0:	4b0a      	ldr	r3, [pc, #40]	@ (100428cc <std+0x5c>)
100428a2:	6323      	str	r3, [r4, #48]	@ 0x30
100428a4:	4b0a      	ldr	r3, [pc, #40]	@ (100428d0 <std+0x60>)
100428a6:	429c      	cmp	r4, r3
100428a8:	d005      	beq.n	100428b6 <std+0x46>
100428aa:	4b0a      	ldr	r3, [pc, #40]	@ (100428d4 <std+0x64>)
100428ac:	429c      	cmp	r4, r3
100428ae:	d002      	beq.n	100428b6 <std+0x46>
100428b0:	4b09      	ldr	r3, [pc, #36]	@ (100428d8 <std+0x68>)
100428b2:	429c      	cmp	r4, r3
100428b4:	d103      	bne.n	100428be <std+0x4e>
100428b6:	0020      	movs	r0, r4
100428b8:	3058      	adds	r0, #88	@ 0x58
100428ba:	f000 fa55 	bl	10042d68 <__retarget_lock_init_recursive>
100428be:	bd10      	pop	{r4, pc}
100428c0:	10042ad9 	.word	0x10042ad9
100428c4:	10042b01 	.word	0x10042b01
100428c8:	10042b39 	.word	0x10042b39
100428cc:	10042b65 	.word	0x10042b65
100428d0:	20000170 	.word	0x20000170
100428d4:	200001d8 	.word	0x200001d8
100428d8:	20000240 	.word	0x20000240

100428dc <stdio_exit_handler>:
100428dc:	b510      	push	{r4, lr}
100428de:	4a03      	ldr	r2, [pc, #12]	@ (100428ec <stdio_exit_handler+0x10>)
100428e0:	4903      	ldr	r1, [pc, #12]	@ (100428f0 <stdio_exit_handler+0x14>)
100428e2:	4804      	ldr	r0, [pc, #16]	@ (100428f4 <stdio_exit_handler+0x18>)
100428e4:	f000 f86c 	bl	100429c0 <_fwalk_sglue>
100428e8:	bd10      	pop	{r4, pc}
100428ea:	46c0      	nop			@ (mov r8, r8)
100428ec:	200002fc 	.word	0x200002fc
100428f0:	100435f9 	.word	0x100435f9
100428f4:	2000030c 	.word	0x2000030c

100428f8 <cleanup_stdio>:
100428f8:	6841      	ldr	r1, [r0, #4]
100428fa:	4b0b      	ldr	r3, [pc, #44]	@ (10042928 <cleanup_stdio+0x30>)
100428fc:	b510      	push	{r4, lr}
100428fe:	0004      	movs	r4, r0
10042900:	4299      	cmp	r1, r3
10042902:	d001      	beq.n	10042908 <cleanup_stdio+0x10>
10042904:	f000 fe78 	bl	100435f8 <_fflush_r>
10042908:	68a1      	ldr	r1, [r4, #8]
1004290a:	4b08      	ldr	r3, [pc, #32]	@ (1004292c <cleanup_stdio+0x34>)
1004290c:	4299      	cmp	r1, r3
1004290e:	d002      	beq.n	10042916 <cleanup_stdio+0x1e>
10042910:	0020      	movs	r0, r4
10042912:	f000 fe71 	bl	100435f8 <_fflush_r>
10042916:	68e1      	ldr	r1, [r4, #12]
10042918:	4b05      	ldr	r3, [pc, #20]	@ (10042930 <cleanup_stdio+0x38>)
1004291a:	4299      	cmp	r1, r3
1004291c:	d002      	beq.n	10042924 <cleanup_stdio+0x2c>
1004291e:	0020      	movs	r0, r4
10042920:	f000 fe6a 	bl	100435f8 <_fflush_r>
10042924:	bd10      	pop	{r4, pc}
10042926:	46c0      	nop			@ (mov r8, r8)
10042928:	20000170 	.word	0x20000170
1004292c:	200001d8 	.word	0x200001d8
10042930:	20000240 	.word	0x20000240

10042934 <global_stdio_init.part.0>:
10042934:	b510      	push	{r4, lr}
10042936:	4b09      	ldr	r3, [pc, #36]	@ (1004295c <global_stdio_init.part.0+0x28>)
10042938:	4a09      	ldr	r2, [pc, #36]	@ (10042960 <global_stdio_init.part.0+0x2c>)
1004293a:	2104      	movs	r1, #4
1004293c:	601a      	str	r2, [r3, #0]
1004293e:	4809      	ldr	r0, [pc, #36]	@ (10042964 <global_stdio_init.part.0+0x30>)
10042940:	2200      	movs	r2, #0
10042942:	f7ff ff95 	bl	10042870 <std>
10042946:	2201      	movs	r2, #1
10042948:	2109      	movs	r1, #9
1004294a:	4807      	ldr	r0, [pc, #28]	@ (10042968 <global_stdio_init.part.0+0x34>)
1004294c:	f7ff ff90 	bl	10042870 <std>
10042950:	2202      	movs	r2, #2
10042952:	2112      	movs	r1, #18
10042954:	4805      	ldr	r0, [pc, #20]	@ (1004296c <global_stdio_init.part.0+0x38>)
10042956:	f7ff ff8b 	bl	10042870 <std>
1004295a:	bd10      	pop	{r4, pc}
1004295c:	200002a8 	.word	0x200002a8
10042960:	100428dd 	.word	0x100428dd
10042964:	20000170 	.word	0x20000170
10042968:	200001d8 	.word	0x200001d8
1004296c:	20000240 	.word	0x20000240

10042970 <__sfp_lock_acquire>:
10042970:	b510      	push	{r4, lr}
10042972:	4802      	ldr	r0, [pc, #8]	@ (1004297c <__sfp_lock_acquire+0xc>)
10042974:	f000 f9f9 	bl	10042d6a <__retarget_lock_acquire_recursive>
10042978:	bd10      	pop	{r4, pc}
1004297a:	46c0      	nop			@ (mov r8, r8)
1004297c:	200002b1 	.word	0x200002b1

10042980 <__sfp_lock_release>:
10042980:	b510      	push	{r4, lr}
10042982:	4802      	ldr	r0, [pc, #8]	@ (1004298c <__sfp_lock_release+0xc>)
10042984:	f000 f9f2 	bl	10042d6c <__retarget_lock_release_recursive>
10042988:	bd10      	pop	{r4, pc}
1004298a:	46c0      	nop			@ (mov r8, r8)
1004298c:	200002b1 	.word	0x200002b1

10042990 <__sinit>:
10042990:	b510      	push	{r4, lr}
10042992:	0004      	movs	r4, r0
10042994:	f7ff ffec 	bl	10042970 <__sfp_lock_acquire>
10042998:	6a23      	ldr	r3, [r4, #32]
1004299a:	2b00      	cmp	r3, #0
1004299c:	d002      	beq.n	100429a4 <__sinit+0x14>
1004299e:	f7ff ffef 	bl	10042980 <__sfp_lock_release>
100429a2:	bd10      	pop	{r4, pc}
100429a4:	4b04      	ldr	r3, [pc, #16]	@ (100429b8 <__sinit+0x28>)
100429a6:	6223      	str	r3, [r4, #32]
100429a8:	4b04      	ldr	r3, [pc, #16]	@ (100429bc <__sinit+0x2c>)
100429aa:	681b      	ldr	r3, [r3, #0]
100429ac:	2b00      	cmp	r3, #0
100429ae:	d1f6      	bne.n	1004299e <__sinit+0xe>
100429b0:	f7ff ffc0 	bl	10042934 <global_stdio_init.part.0>
100429b4:	e7f3      	b.n	1004299e <__sinit+0xe>
100429b6:	46c0      	nop			@ (mov r8, r8)
100429b8:	100428f9 	.word	0x100428f9
100429bc:	200002a8 	.word	0x200002a8

100429c0 <_fwalk_sglue>:
100429c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100429c2:	0014      	movs	r4, r2
100429c4:	2600      	movs	r6, #0
100429c6:	9000      	str	r0, [sp, #0]
100429c8:	9101      	str	r1, [sp, #4]
100429ca:	68a5      	ldr	r5, [r4, #8]
100429cc:	6867      	ldr	r7, [r4, #4]
100429ce:	3f01      	subs	r7, #1
100429d0:	d504      	bpl.n	100429dc <_fwalk_sglue+0x1c>
100429d2:	6824      	ldr	r4, [r4, #0]
100429d4:	2c00      	cmp	r4, #0
100429d6:	d1f8      	bne.n	100429ca <_fwalk_sglue+0xa>
100429d8:	0030      	movs	r0, r6
100429da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
100429dc:	89ab      	ldrh	r3, [r5, #12]
100429de:	2b01      	cmp	r3, #1
100429e0:	d908      	bls.n	100429f4 <_fwalk_sglue+0x34>
100429e2:	220e      	movs	r2, #14
100429e4:	5eab      	ldrsh	r3, [r5, r2]
100429e6:	3301      	adds	r3, #1
100429e8:	d004      	beq.n	100429f4 <_fwalk_sglue+0x34>
100429ea:	0029      	movs	r1, r5
100429ec:	9800      	ldr	r0, [sp, #0]
100429ee:	9b01      	ldr	r3, [sp, #4]
100429f0:	4798      	blx	r3
100429f2:	4306      	orrs	r6, r0
100429f4:	3568      	adds	r5, #104	@ 0x68
100429f6:	e7ea      	b.n	100429ce <_fwalk_sglue+0xe>

100429f8 <iprintf>:
100429f8:	b40f      	push	{r0, r1, r2, r3}
100429fa:	b507      	push	{r0, r1, r2, lr}
100429fc:	4905      	ldr	r1, [pc, #20]	@ (10042a14 <iprintf+0x1c>)
100429fe:	ab04      	add	r3, sp, #16
10042a00:	6808      	ldr	r0, [r1, #0]
10042a02:	cb04      	ldmia	r3!, {r2}
10042a04:	6881      	ldr	r1, [r0, #8]
10042a06:	9301      	str	r3, [sp, #4]
10042a08:	f000 fad6 	bl	10042fb8 <_vfiprintf_r>
10042a0c:	b003      	add	sp, #12
10042a0e:	bc08      	pop	{r3}
10042a10:	b004      	add	sp, #16
10042a12:	4718      	bx	r3
10042a14:	20000308 	.word	0x20000308

10042a18 <_puts_r>:
10042a18:	6a03      	ldr	r3, [r0, #32]
10042a1a:	b570      	push	{r4, r5, r6, lr}
10042a1c:	0005      	movs	r5, r0
10042a1e:	000e      	movs	r6, r1
10042a20:	6884      	ldr	r4, [r0, #8]
10042a22:	2b00      	cmp	r3, #0
10042a24:	d101      	bne.n	10042a2a <_puts_r+0x12>
10042a26:	f7ff ffb3 	bl	10042990 <__sinit>
10042a2a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
10042a2c:	07db      	lsls	r3, r3, #31
10042a2e:	d405      	bmi.n	10042a3c <_puts_r+0x24>
10042a30:	89a3      	ldrh	r3, [r4, #12]
10042a32:	059b      	lsls	r3, r3, #22
10042a34:	d402      	bmi.n	10042a3c <_puts_r+0x24>
10042a36:	6da0      	ldr	r0, [r4, #88]	@ 0x58
10042a38:	f000 f997 	bl	10042d6a <__retarget_lock_acquire_recursive>
10042a3c:	89a3      	ldrh	r3, [r4, #12]
10042a3e:	071b      	lsls	r3, r3, #28
10042a40:	d502      	bpl.n	10042a48 <_puts_r+0x30>
10042a42:	6923      	ldr	r3, [r4, #16]
10042a44:	2b00      	cmp	r3, #0
10042a46:	d11f      	bne.n	10042a88 <_puts_r+0x70>
10042a48:	0021      	movs	r1, r4
10042a4a:	0028      	movs	r0, r5
10042a4c:	f000 f8d2 	bl	10042bf4 <__swsetup_r>
10042a50:	2800      	cmp	r0, #0
10042a52:	d019      	beq.n	10042a88 <_puts_r+0x70>
10042a54:	2501      	movs	r5, #1
10042a56:	426d      	negs	r5, r5
10042a58:	6e63      	ldr	r3, [r4, #100]	@ 0x64
10042a5a:	07db      	lsls	r3, r3, #31
10042a5c:	d405      	bmi.n	10042a6a <_puts_r+0x52>
10042a5e:	89a3      	ldrh	r3, [r4, #12]
10042a60:	059b      	lsls	r3, r3, #22
10042a62:	d402      	bmi.n	10042a6a <_puts_r+0x52>
10042a64:	6da0      	ldr	r0, [r4, #88]	@ 0x58
10042a66:	f000 f981 	bl	10042d6c <__retarget_lock_release_recursive>
10042a6a:	0028      	movs	r0, r5
10042a6c:	bd70      	pop	{r4, r5, r6, pc}
10042a6e:	3601      	adds	r6, #1
10042a70:	60a3      	str	r3, [r4, #8]
10042a72:	2b00      	cmp	r3, #0
10042a74:	da04      	bge.n	10042a80 <_puts_r+0x68>
10042a76:	69a2      	ldr	r2, [r4, #24]
10042a78:	429a      	cmp	r2, r3
10042a7a:	dc16      	bgt.n	10042aaa <_puts_r+0x92>
10042a7c:	290a      	cmp	r1, #10
10042a7e:	d014      	beq.n	10042aaa <_puts_r+0x92>
10042a80:	6823      	ldr	r3, [r4, #0]
10042a82:	1c5a      	adds	r2, r3, #1
10042a84:	6022      	str	r2, [r4, #0]
10042a86:	7019      	strb	r1, [r3, #0]
10042a88:	68a3      	ldr	r3, [r4, #8]
10042a8a:	7831      	ldrb	r1, [r6, #0]
10042a8c:	3b01      	subs	r3, #1
10042a8e:	2900      	cmp	r1, #0
10042a90:	d1ed      	bne.n	10042a6e <_puts_r+0x56>
10042a92:	60a3      	str	r3, [r4, #8]
10042a94:	2b00      	cmp	r3, #0
10042a96:	da0f      	bge.n	10042ab8 <_puts_r+0xa0>
10042a98:	0022      	movs	r2, r4
10042a9a:	0028      	movs	r0, r5
10042a9c:	310a      	adds	r1, #10
10042a9e:	f000 f867 	bl	10042b70 <__swbuf_r>
10042aa2:	3001      	adds	r0, #1
10042aa4:	d0d6      	beq.n	10042a54 <_puts_r+0x3c>
10042aa6:	250a      	movs	r5, #10
10042aa8:	e7d6      	b.n	10042a58 <_puts_r+0x40>
10042aaa:	0022      	movs	r2, r4
10042aac:	0028      	movs	r0, r5
10042aae:	f000 f85f 	bl	10042b70 <__swbuf_r>
10042ab2:	3001      	adds	r0, #1
10042ab4:	d1e8      	bne.n	10042a88 <_puts_r+0x70>
10042ab6:	e7cd      	b.n	10042a54 <_puts_r+0x3c>
10042ab8:	6823      	ldr	r3, [r4, #0]
10042aba:	1c5a      	adds	r2, r3, #1
10042abc:	6022      	str	r2, [r4, #0]
10042abe:	220a      	movs	r2, #10
10042ac0:	701a      	strb	r2, [r3, #0]
10042ac2:	e7f0      	b.n	10042aa6 <_puts_r+0x8e>

10042ac4 <puts>:
10042ac4:	b510      	push	{r4, lr}
10042ac6:	4b03      	ldr	r3, [pc, #12]	@ (10042ad4 <puts+0x10>)
10042ac8:	0001      	movs	r1, r0
10042aca:	6818      	ldr	r0, [r3, #0]
10042acc:	f7ff ffa4 	bl	10042a18 <_puts_r>
10042ad0:	bd10      	pop	{r4, pc}
10042ad2:	46c0      	nop			@ (mov r8, r8)
10042ad4:	20000308 	.word	0x20000308

10042ad8 <__sread>:
10042ad8:	b570      	push	{r4, r5, r6, lr}
10042ada:	000c      	movs	r4, r1
10042adc:	250e      	movs	r5, #14
10042ade:	5f49      	ldrsh	r1, [r1, r5]
10042ae0:	f000 f914 	bl	10042d0c <_read_r>
10042ae4:	2800      	cmp	r0, #0
10042ae6:	db03      	blt.n	10042af0 <__sread+0x18>
10042ae8:	6d63      	ldr	r3, [r4, #84]	@ 0x54
10042aea:	181b      	adds	r3, r3, r0
10042aec:	6563      	str	r3, [r4, #84]	@ 0x54
10042aee:	bd70      	pop	{r4, r5, r6, pc}
10042af0:	89a3      	ldrh	r3, [r4, #12]
10042af2:	4a02      	ldr	r2, [pc, #8]	@ (10042afc <__sread+0x24>)
10042af4:	4013      	ands	r3, r2
10042af6:	81a3      	strh	r3, [r4, #12]
10042af8:	e7f9      	b.n	10042aee <__sread+0x16>
10042afa:	46c0      	nop			@ (mov r8, r8)
10042afc:	ffffefff 	.word	0xffffefff

10042b00 <__swrite>:
10042b00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10042b02:	001f      	movs	r7, r3
10042b04:	898b      	ldrh	r3, [r1, #12]
10042b06:	0005      	movs	r5, r0
10042b08:	000c      	movs	r4, r1
10042b0a:	0016      	movs	r6, r2
10042b0c:	05db      	lsls	r3, r3, #23
10042b0e:	d505      	bpl.n	10042b1c <__swrite+0x1c>
10042b10:	230e      	movs	r3, #14
10042b12:	5ec9      	ldrsh	r1, [r1, r3]
10042b14:	2200      	movs	r2, #0
10042b16:	2302      	movs	r3, #2
10042b18:	f000 f8e4 	bl	10042ce4 <_lseek_r>
10042b1c:	89a3      	ldrh	r3, [r4, #12]
10042b1e:	4a05      	ldr	r2, [pc, #20]	@ (10042b34 <__swrite+0x34>)
10042b20:	0028      	movs	r0, r5
10042b22:	4013      	ands	r3, r2
10042b24:	81a3      	strh	r3, [r4, #12]
10042b26:	0032      	movs	r2, r6
10042b28:	230e      	movs	r3, #14
10042b2a:	5ee1      	ldrsh	r1, [r4, r3]
10042b2c:	003b      	movs	r3, r7
10042b2e:	f000 f901 	bl	10042d34 <_write_r>
10042b32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10042b34:	ffffefff 	.word	0xffffefff

10042b38 <__sseek>:
10042b38:	b570      	push	{r4, r5, r6, lr}
10042b3a:	000c      	movs	r4, r1
10042b3c:	250e      	movs	r5, #14
10042b3e:	5f49      	ldrsh	r1, [r1, r5]
10042b40:	f000 f8d0 	bl	10042ce4 <_lseek_r>
10042b44:	89a3      	ldrh	r3, [r4, #12]
10042b46:	1c42      	adds	r2, r0, #1
10042b48:	d103      	bne.n	10042b52 <__sseek+0x1a>
10042b4a:	4a05      	ldr	r2, [pc, #20]	@ (10042b60 <__sseek+0x28>)
10042b4c:	4013      	ands	r3, r2
10042b4e:	81a3      	strh	r3, [r4, #12]
10042b50:	bd70      	pop	{r4, r5, r6, pc}
10042b52:	2280      	movs	r2, #128	@ 0x80
10042b54:	0152      	lsls	r2, r2, #5
10042b56:	4313      	orrs	r3, r2
10042b58:	81a3      	strh	r3, [r4, #12]
10042b5a:	6560      	str	r0, [r4, #84]	@ 0x54
10042b5c:	e7f8      	b.n	10042b50 <__sseek+0x18>
10042b5e:	46c0      	nop			@ (mov r8, r8)
10042b60:	ffffefff 	.word	0xffffefff

10042b64 <__sclose>:
10042b64:	b510      	push	{r4, lr}
10042b66:	230e      	movs	r3, #14
10042b68:	5ec9      	ldrsh	r1, [r1, r3]
10042b6a:	f000 f8a9 	bl	10042cc0 <_close_r>
10042b6e:	bd10      	pop	{r4, pc}

10042b70 <__swbuf_r>:
10042b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10042b72:	0006      	movs	r6, r0
10042b74:	000d      	movs	r5, r1
10042b76:	0014      	movs	r4, r2
10042b78:	2800      	cmp	r0, #0
10042b7a:	d004      	beq.n	10042b86 <__swbuf_r+0x16>
10042b7c:	6a03      	ldr	r3, [r0, #32]
10042b7e:	2b00      	cmp	r3, #0
10042b80:	d101      	bne.n	10042b86 <__swbuf_r+0x16>
10042b82:	f7ff ff05 	bl	10042990 <__sinit>
10042b86:	69a3      	ldr	r3, [r4, #24]
10042b88:	60a3      	str	r3, [r4, #8]
10042b8a:	89a3      	ldrh	r3, [r4, #12]
10042b8c:	071b      	lsls	r3, r3, #28
10042b8e:	d502      	bpl.n	10042b96 <__swbuf_r+0x26>
10042b90:	6923      	ldr	r3, [r4, #16]
10042b92:	2b00      	cmp	r3, #0
10042b94:	d109      	bne.n	10042baa <__swbuf_r+0x3a>
10042b96:	0021      	movs	r1, r4
10042b98:	0030      	movs	r0, r6
10042b9a:	f000 f82b 	bl	10042bf4 <__swsetup_r>
10042b9e:	2800      	cmp	r0, #0
10042ba0:	d003      	beq.n	10042baa <__swbuf_r+0x3a>
10042ba2:	2501      	movs	r5, #1
10042ba4:	426d      	negs	r5, r5
10042ba6:	0028      	movs	r0, r5
10042ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10042baa:	6923      	ldr	r3, [r4, #16]
10042bac:	6820      	ldr	r0, [r4, #0]
10042bae:	b2ef      	uxtb	r7, r5
10042bb0:	1ac0      	subs	r0, r0, r3
10042bb2:	6963      	ldr	r3, [r4, #20]
10042bb4:	b2ed      	uxtb	r5, r5
10042bb6:	4283      	cmp	r3, r0
10042bb8:	dc05      	bgt.n	10042bc6 <__swbuf_r+0x56>
10042bba:	0021      	movs	r1, r4
10042bbc:	0030      	movs	r0, r6
10042bbe:	f000 fd1b 	bl	100435f8 <_fflush_r>
10042bc2:	2800      	cmp	r0, #0
10042bc4:	d1ed      	bne.n	10042ba2 <__swbuf_r+0x32>
10042bc6:	68a3      	ldr	r3, [r4, #8]
10042bc8:	3001      	adds	r0, #1
10042bca:	3b01      	subs	r3, #1
10042bcc:	60a3      	str	r3, [r4, #8]
10042bce:	6823      	ldr	r3, [r4, #0]
10042bd0:	1c5a      	adds	r2, r3, #1
10042bd2:	6022      	str	r2, [r4, #0]
10042bd4:	701f      	strb	r7, [r3, #0]
10042bd6:	6963      	ldr	r3, [r4, #20]
10042bd8:	4283      	cmp	r3, r0
10042bda:	d004      	beq.n	10042be6 <__swbuf_r+0x76>
10042bdc:	89a3      	ldrh	r3, [r4, #12]
10042bde:	07db      	lsls	r3, r3, #31
10042be0:	d5e1      	bpl.n	10042ba6 <__swbuf_r+0x36>
10042be2:	2d0a      	cmp	r5, #10
10042be4:	d1df      	bne.n	10042ba6 <__swbuf_r+0x36>
10042be6:	0021      	movs	r1, r4
10042be8:	0030      	movs	r0, r6
10042bea:	f000 fd05 	bl	100435f8 <_fflush_r>
10042bee:	2800      	cmp	r0, #0
10042bf0:	d0d9      	beq.n	10042ba6 <__swbuf_r+0x36>
10042bf2:	e7d6      	b.n	10042ba2 <__swbuf_r+0x32>

10042bf4 <__swsetup_r>:
10042bf4:	4b2d      	ldr	r3, [pc, #180]	@ (10042cac <__swsetup_r+0xb8>)
10042bf6:	b570      	push	{r4, r5, r6, lr}
10042bf8:	0005      	movs	r5, r0
10042bfa:	6818      	ldr	r0, [r3, #0]
10042bfc:	000c      	movs	r4, r1
10042bfe:	2800      	cmp	r0, #0
10042c00:	d004      	beq.n	10042c0c <__swsetup_r+0x18>
10042c02:	6a03      	ldr	r3, [r0, #32]
10042c04:	2b00      	cmp	r3, #0
10042c06:	d101      	bne.n	10042c0c <__swsetup_r+0x18>
10042c08:	f7ff fec2 	bl	10042990 <__sinit>
10042c0c:	230c      	movs	r3, #12
10042c0e:	5ee2      	ldrsh	r2, [r4, r3]
10042c10:	0713      	lsls	r3, r2, #28
10042c12:	d423      	bmi.n	10042c5c <__swsetup_r+0x68>
10042c14:	06d3      	lsls	r3, r2, #27
10042c16:	d407      	bmi.n	10042c28 <__swsetup_r+0x34>
10042c18:	2309      	movs	r3, #9
10042c1a:	602b      	str	r3, [r5, #0]
10042c1c:	2340      	movs	r3, #64	@ 0x40
10042c1e:	2001      	movs	r0, #1
10042c20:	4313      	orrs	r3, r2
10042c22:	81a3      	strh	r3, [r4, #12]
10042c24:	4240      	negs	r0, r0
10042c26:	e03a      	b.n	10042c9e <__swsetup_r+0xaa>
10042c28:	0752      	lsls	r2, r2, #29
10042c2a:	d513      	bpl.n	10042c54 <__swsetup_r+0x60>
10042c2c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
10042c2e:	2900      	cmp	r1, #0
10042c30:	d008      	beq.n	10042c44 <__swsetup_r+0x50>
10042c32:	0023      	movs	r3, r4
10042c34:	3344      	adds	r3, #68	@ 0x44
10042c36:	4299      	cmp	r1, r3
10042c38:	d002      	beq.n	10042c40 <__swsetup_r+0x4c>
10042c3a:	0028      	movs	r0, r5
10042c3c:	f000 f898 	bl	10042d70 <_free_r>
10042c40:	2300      	movs	r3, #0
10042c42:	6363      	str	r3, [r4, #52]	@ 0x34
10042c44:	2224      	movs	r2, #36	@ 0x24
10042c46:	89a3      	ldrh	r3, [r4, #12]
10042c48:	4393      	bics	r3, r2
10042c4a:	81a3      	strh	r3, [r4, #12]
10042c4c:	2300      	movs	r3, #0
10042c4e:	6063      	str	r3, [r4, #4]
10042c50:	6923      	ldr	r3, [r4, #16]
10042c52:	6023      	str	r3, [r4, #0]
10042c54:	2308      	movs	r3, #8
10042c56:	89a2      	ldrh	r2, [r4, #12]
10042c58:	4313      	orrs	r3, r2
10042c5a:	81a3      	strh	r3, [r4, #12]
10042c5c:	6923      	ldr	r3, [r4, #16]
10042c5e:	2b00      	cmp	r3, #0
10042c60:	d10b      	bne.n	10042c7a <__swsetup_r+0x86>
10042c62:	21a0      	movs	r1, #160	@ 0xa0
10042c64:	2280      	movs	r2, #128	@ 0x80
10042c66:	89a3      	ldrh	r3, [r4, #12]
10042c68:	0089      	lsls	r1, r1, #2
10042c6a:	0092      	lsls	r2, r2, #2
10042c6c:	400b      	ands	r3, r1
10042c6e:	4293      	cmp	r3, r2
10042c70:	d003      	beq.n	10042c7a <__swsetup_r+0x86>
10042c72:	0021      	movs	r1, r4
10042c74:	0028      	movs	r0, r5
10042c76:	f000 fd15 	bl	100436a4 <__smakebuf_r>
10042c7a:	230c      	movs	r3, #12
10042c7c:	5ee2      	ldrsh	r2, [r4, r3]
10042c7e:	2101      	movs	r1, #1
10042c80:	0013      	movs	r3, r2
10042c82:	400b      	ands	r3, r1
10042c84:	420a      	tst	r2, r1
10042c86:	d00b      	beq.n	10042ca0 <__swsetup_r+0xac>
10042c88:	2300      	movs	r3, #0
10042c8a:	60a3      	str	r3, [r4, #8]
10042c8c:	6963      	ldr	r3, [r4, #20]
10042c8e:	425b      	negs	r3, r3
10042c90:	61a3      	str	r3, [r4, #24]
10042c92:	2000      	movs	r0, #0
10042c94:	6923      	ldr	r3, [r4, #16]
10042c96:	4283      	cmp	r3, r0
10042c98:	d101      	bne.n	10042c9e <__swsetup_r+0xaa>
10042c9a:	0613      	lsls	r3, r2, #24
10042c9c:	d4be      	bmi.n	10042c1c <__swsetup_r+0x28>
10042c9e:	bd70      	pop	{r4, r5, r6, pc}
10042ca0:	0791      	lsls	r1, r2, #30
10042ca2:	d400      	bmi.n	10042ca6 <__swsetup_r+0xb2>
10042ca4:	6963      	ldr	r3, [r4, #20]
10042ca6:	60a3      	str	r3, [r4, #8]
10042ca8:	e7f3      	b.n	10042c92 <__swsetup_r+0x9e>
10042caa:	46c0      	nop			@ (mov r8, r8)
10042cac:	20000308 	.word	0x20000308

10042cb0 <memset>:
10042cb0:	0003      	movs	r3, r0
10042cb2:	1882      	adds	r2, r0, r2
10042cb4:	4293      	cmp	r3, r2
10042cb6:	d100      	bne.n	10042cba <memset+0xa>
10042cb8:	4770      	bx	lr
10042cba:	7019      	strb	r1, [r3, #0]
10042cbc:	3301      	adds	r3, #1
10042cbe:	e7f9      	b.n	10042cb4 <memset+0x4>

10042cc0 <_close_r>:
10042cc0:	2300      	movs	r3, #0
10042cc2:	b570      	push	{r4, r5, r6, lr}
10042cc4:	4d06      	ldr	r5, [pc, #24]	@ (10042ce0 <_close_r+0x20>)
10042cc6:	0004      	movs	r4, r0
10042cc8:	0008      	movs	r0, r1
10042cca:	602b      	str	r3, [r5, #0]
10042ccc:	f7fd fdb3 	bl	10040836 <_close>
10042cd0:	1c43      	adds	r3, r0, #1
10042cd2:	d103      	bne.n	10042cdc <_close_r+0x1c>
10042cd4:	682b      	ldr	r3, [r5, #0]
10042cd6:	2b00      	cmp	r3, #0
10042cd8:	d000      	beq.n	10042cdc <_close_r+0x1c>
10042cda:	6023      	str	r3, [r4, #0]
10042cdc:	bd70      	pop	{r4, r5, r6, pc}
10042cde:	46c0      	nop			@ (mov r8, r8)
10042ce0:	200002ac 	.word	0x200002ac

10042ce4 <_lseek_r>:
10042ce4:	b570      	push	{r4, r5, r6, lr}
10042ce6:	0004      	movs	r4, r0
10042ce8:	0008      	movs	r0, r1
10042cea:	0011      	movs	r1, r2
10042cec:	001a      	movs	r2, r3
10042cee:	2300      	movs	r3, #0
10042cf0:	4d05      	ldr	r5, [pc, #20]	@ (10042d08 <_lseek_r+0x24>)
10042cf2:	602b      	str	r3, [r5, #0]
10042cf4:	f7fd fdc0 	bl	10040878 <_lseek>
10042cf8:	1c43      	adds	r3, r0, #1
10042cfa:	d103      	bne.n	10042d04 <_lseek_r+0x20>
10042cfc:	682b      	ldr	r3, [r5, #0]
10042cfe:	2b00      	cmp	r3, #0
10042d00:	d000      	beq.n	10042d04 <_lseek_r+0x20>
10042d02:	6023      	str	r3, [r4, #0]
10042d04:	bd70      	pop	{r4, r5, r6, pc}
10042d06:	46c0      	nop			@ (mov r8, r8)
10042d08:	200002ac 	.word	0x200002ac

10042d0c <_read_r>:
10042d0c:	b570      	push	{r4, r5, r6, lr}
10042d0e:	0004      	movs	r4, r0
10042d10:	0008      	movs	r0, r1
10042d12:	0011      	movs	r1, r2
10042d14:	001a      	movs	r2, r3
10042d16:	2300      	movs	r3, #0
10042d18:	4d05      	ldr	r5, [pc, #20]	@ (10042d30 <_read_r+0x24>)
10042d1a:	602b      	str	r3, [r5, #0]
10042d1c:	f7fd fd52 	bl	100407c4 <_read>
10042d20:	1c43      	adds	r3, r0, #1
10042d22:	d103      	bne.n	10042d2c <_read_r+0x20>
10042d24:	682b      	ldr	r3, [r5, #0]
10042d26:	2b00      	cmp	r3, #0
10042d28:	d000      	beq.n	10042d2c <_read_r+0x20>
10042d2a:	6023      	str	r3, [r4, #0]
10042d2c:	bd70      	pop	{r4, r5, r6, pc}
10042d2e:	46c0      	nop			@ (mov r8, r8)
10042d30:	200002ac 	.word	0x200002ac

10042d34 <_write_r>:
10042d34:	b570      	push	{r4, r5, r6, lr}
10042d36:	0004      	movs	r4, r0
10042d38:	0008      	movs	r0, r1
10042d3a:	0011      	movs	r1, r2
10042d3c:	001a      	movs	r2, r3
10042d3e:	2300      	movs	r3, #0
10042d40:	4d05      	ldr	r5, [pc, #20]	@ (10042d58 <_write_r+0x24>)
10042d42:	602b      	str	r3, [r5, #0]
10042d44:	f7fd fd5b 	bl	100407fe <_write>
10042d48:	1c43      	adds	r3, r0, #1
10042d4a:	d103      	bne.n	10042d54 <_write_r+0x20>
10042d4c:	682b      	ldr	r3, [r5, #0]
10042d4e:	2b00      	cmp	r3, #0
10042d50:	d000      	beq.n	10042d54 <_write_r+0x20>
10042d52:	6023      	str	r3, [r4, #0]
10042d54:	bd70      	pop	{r4, r5, r6, pc}
10042d56:	46c0      	nop			@ (mov r8, r8)
10042d58:	200002ac 	.word	0x200002ac

10042d5c <__errno>:
10042d5c:	4b01      	ldr	r3, [pc, #4]	@ (10042d64 <__errno+0x8>)
10042d5e:	6818      	ldr	r0, [r3, #0]
10042d60:	4770      	bx	lr
10042d62:	46c0      	nop			@ (mov r8, r8)
10042d64:	20000308 	.word	0x20000308

10042d68 <__retarget_lock_init_recursive>:
10042d68:	4770      	bx	lr

10042d6a <__retarget_lock_acquire_recursive>:
10042d6a:	4770      	bx	lr

10042d6c <__retarget_lock_release_recursive>:
10042d6c:	4770      	bx	lr
	...

10042d70 <_free_r>:
10042d70:	b570      	push	{r4, r5, r6, lr}
10042d72:	0005      	movs	r5, r0
10042d74:	1e0c      	subs	r4, r1, #0
10042d76:	d010      	beq.n	10042d9a <_free_r+0x2a>
10042d78:	3c04      	subs	r4, #4
10042d7a:	6823      	ldr	r3, [r4, #0]
10042d7c:	2b00      	cmp	r3, #0
10042d7e:	da00      	bge.n	10042d82 <_free_r+0x12>
10042d80:	18e4      	adds	r4, r4, r3
10042d82:	0028      	movs	r0, r5
10042d84:	f000 f8e0 	bl	10042f48 <__malloc_lock>
10042d88:	4a1d      	ldr	r2, [pc, #116]	@ (10042e00 <_free_r+0x90>)
10042d8a:	6813      	ldr	r3, [r2, #0]
10042d8c:	2b00      	cmp	r3, #0
10042d8e:	d105      	bne.n	10042d9c <_free_r+0x2c>
10042d90:	6063      	str	r3, [r4, #4]
10042d92:	6014      	str	r4, [r2, #0]
10042d94:	0028      	movs	r0, r5
10042d96:	f000 f8df 	bl	10042f58 <__malloc_unlock>
10042d9a:	bd70      	pop	{r4, r5, r6, pc}
10042d9c:	42a3      	cmp	r3, r4
10042d9e:	d908      	bls.n	10042db2 <_free_r+0x42>
10042da0:	6820      	ldr	r0, [r4, #0]
10042da2:	1821      	adds	r1, r4, r0
10042da4:	428b      	cmp	r3, r1
10042da6:	d1f3      	bne.n	10042d90 <_free_r+0x20>
10042da8:	6819      	ldr	r1, [r3, #0]
10042daa:	685b      	ldr	r3, [r3, #4]
10042dac:	1809      	adds	r1, r1, r0
10042dae:	6021      	str	r1, [r4, #0]
10042db0:	e7ee      	b.n	10042d90 <_free_r+0x20>
10042db2:	001a      	movs	r2, r3
10042db4:	685b      	ldr	r3, [r3, #4]
10042db6:	2b00      	cmp	r3, #0
10042db8:	d001      	beq.n	10042dbe <_free_r+0x4e>
10042dba:	42a3      	cmp	r3, r4
10042dbc:	d9f9      	bls.n	10042db2 <_free_r+0x42>
10042dbe:	6811      	ldr	r1, [r2, #0]
10042dc0:	1850      	adds	r0, r2, r1
10042dc2:	42a0      	cmp	r0, r4
10042dc4:	d10b      	bne.n	10042dde <_free_r+0x6e>
10042dc6:	6820      	ldr	r0, [r4, #0]
10042dc8:	1809      	adds	r1, r1, r0
10042dca:	1850      	adds	r0, r2, r1
10042dcc:	6011      	str	r1, [r2, #0]
10042dce:	4283      	cmp	r3, r0
10042dd0:	d1e0      	bne.n	10042d94 <_free_r+0x24>
10042dd2:	6818      	ldr	r0, [r3, #0]
10042dd4:	685b      	ldr	r3, [r3, #4]
10042dd6:	1841      	adds	r1, r0, r1
10042dd8:	6011      	str	r1, [r2, #0]
10042dda:	6053      	str	r3, [r2, #4]
10042ddc:	e7da      	b.n	10042d94 <_free_r+0x24>
10042dde:	42a0      	cmp	r0, r4
10042de0:	d902      	bls.n	10042de8 <_free_r+0x78>
10042de2:	230c      	movs	r3, #12
10042de4:	602b      	str	r3, [r5, #0]
10042de6:	e7d5      	b.n	10042d94 <_free_r+0x24>
10042de8:	6820      	ldr	r0, [r4, #0]
10042dea:	1821      	adds	r1, r4, r0
10042dec:	428b      	cmp	r3, r1
10042dee:	d103      	bne.n	10042df8 <_free_r+0x88>
10042df0:	6819      	ldr	r1, [r3, #0]
10042df2:	685b      	ldr	r3, [r3, #4]
10042df4:	1809      	adds	r1, r1, r0
10042df6:	6021      	str	r1, [r4, #0]
10042df8:	6063      	str	r3, [r4, #4]
10042dfa:	6054      	str	r4, [r2, #4]
10042dfc:	e7ca      	b.n	10042d94 <_free_r+0x24>
10042dfe:	46c0      	nop			@ (mov r8, r8)
10042e00:	200002b8 	.word	0x200002b8

10042e04 <sbrk_aligned>:
10042e04:	b570      	push	{r4, r5, r6, lr}
10042e06:	4e0f      	ldr	r6, [pc, #60]	@ (10042e44 <sbrk_aligned+0x40>)
10042e08:	000d      	movs	r5, r1
10042e0a:	6831      	ldr	r1, [r6, #0]
10042e0c:	0004      	movs	r4, r0
10042e0e:	2900      	cmp	r1, #0
10042e10:	d102      	bne.n	10042e18 <sbrk_aligned+0x14>
10042e12:	f000 fcad 	bl	10043770 <_sbrk_r>
10042e16:	6030      	str	r0, [r6, #0]
10042e18:	0029      	movs	r1, r5
10042e1a:	0020      	movs	r0, r4
10042e1c:	f000 fca8 	bl	10043770 <_sbrk_r>
10042e20:	1c43      	adds	r3, r0, #1
10042e22:	d103      	bne.n	10042e2c <sbrk_aligned+0x28>
10042e24:	2501      	movs	r5, #1
10042e26:	426d      	negs	r5, r5
10042e28:	0028      	movs	r0, r5
10042e2a:	bd70      	pop	{r4, r5, r6, pc}
10042e2c:	2303      	movs	r3, #3
10042e2e:	1cc5      	adds	r5, r0, #3
10042e30:	439d      	bics	r5, r3
10042e32:	42a8      	cmp	r0, r5
10042e34:	d0f8      	beq.n	10042e28 <sbrk_aligned+0x24>
10042e36:	1a29      	subs	r1, r5, r0
10042e38:	0020      	movs	r0, r4
10042e3a:	f000 fc99 	bl	10043770 <_sbrk_r>
10042e3e:	3001      	adds	r0, #1
10042e40:	d1f2      	bne.n	10042e28 <sbrk_aligned+0x24>
10042e42:	e7ef      	b.n	10042e24 <sbrk_aligned+0x20>
10042e44:	200002b4 	.word	0x200002b4

10042e48 <_malloc_r>:
10042e48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
10042e4a:	2203      	movs	r2, #3
10042e4c:	1ccb      	adds	r3, r1, #3
10042e4e:	4393      	bics	r3, r2
10042e50:	3308      	adds	r3, #8
10042e52:	0005      	movs	r5, r0
10042e54:	001f      	movs	r7, r3
10042e56:	2b0c      	cmp	r3, #12
10042e58:	d234      	bcs.n	10042ec4 <_malloc_r+0x7c>
10042e5a:	270c      	movs	r7, #12
10042e5c:	42b9      	cmp	r1, r7
10042e5e:	d833      	bhi.n	10042ec8 <_malloc_r+0x80>
10042e60:	0028      	movs	r0, r5
10042e62:	f000 f871 	bl	10042f48 <__malloc_lock>
10042e66:	4e37      	ldr	r6, [pc, #220]	@ (10042f44 <_malloc_r+0xfc>)
10042e68:	6833      	ldr	r3, [r6, #0]
10042e6a:	001c      	movs	r4, r3
10042e6c:	2c00      	cmp	r4, #0
10042e6e:	d12f      	bne.n	10042ed0 <_malloc_r+0x88>
10042e70:	0039      	movs	r1, r7
10042e72:	0028      	movs	r0, r5
10042e74:	f7ff ffc6 	bl	10042e04 <sbrk_aligned>
10042e78:	0004      	movs	r4, r0
10042e7a:	1c43      	adds	r3, r0, #1
10042e7c:	d15f      	bne.n	10042f3e <_malloc_r+0xf6>
10042e7e:	6834      	ldr	r4, [r6, #0]
10042e80:	9400      	str	r4, [sp, #0]
10042e82:	9b00      	ldr	r3, [sp, #0]
10042e84:	2b00      	cmp	r3, #0
10042e86:	d14a      	bne.n	10042f1e <_malloc_r+0xd6>
10042e88:	2c00      	cmp	r4, #0
10042e8a:	d052      	beq.n	10042f32 <_malloc_r+0xea>
10042e8c:	6823      	ldr	r3, [r4, #0]
10042e8e:	0028      	movs	r0, r5
10042e90:	18e3      	adds	r3, r4, r3
10042e92:	9900      	ldr	r1, [sp, #0]
10042e94:	9301      	str	r3, [sp, #4]
10042e96:	f000 fc6b 	bl	10043770 <_sbrk_r>
10042e9a:	9b01      	ldr	r3, [sp, #4]
10042e9c:	4283      	cmp	r3, r0
10042e9e:	d148      	bne.n	10042f32 <_malloc_r+0xea>
10042ea0:	6823      	ldr	r3, [r4, #0]
10042ea2:	0028      	movs	r0, r5
10042ea4:	1aff      	subs	r7, r7, r3
10042ea6:	0039      	movs	r1, r7
10042ea8:	f7ff ffac 	bl	10042e04 <sbrk_aligned>
10042eac:	3001      	adds	r0, #1
10042eae:	d040      	beq.n	10042f32 <_malloc_r+0xea>
10042eb0:	6823      	ldr	r3, [r4, #0]
10042eb2:	19db      	adds	r3, r3, r7
10042eb4:	6023      	str	r3, [r4, #0]
10042eb6:	6833      	ldr	r3, [r6, #0]
10042eb8:	685a      	ldr	r2, [r3, #4]
10042eba:	2a00      	cmp	r2, #0
10042ebc:	d133      	bne.n	10042f26 <_malloc_r+0xde>
10042ebe:	9b00      	ldr	r3, [sp, #0]
10042ec0:	6033      	str	r3, [r6, #0]
10042ec2:	e019      	b.n	10042ef8 <_malloc_r+0xb0>
10042ec4:	2b00      	cmp	r3, #0
10042ec6:	dac9      	bge.n	10042e5c <_malloc_r+0x14>
10042ec8:	230c      	movs	r3, #12
10042eca:	602b      	str	r3, [r5, #0]
10042ecc:	2000      	movs	r0, #0
10042ece:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
10042ed0:	6821      	ldr	r1, [r4, #0]
10042ed2:	1bc9      	subs	r1, r1, r7
10042ed4:	d420      	bmi.n	10042f18 <_malloc_r+0xd0>
10042ed6:	290b      	cmp	r1, #11
10042ed8:	d90a      	bls.n	10042ef0 <_malloc_r+0xa8>
10042eda:	19e2      	adds	r2, r4, r7
10042edc:	6027      	str	r7, [r4, #0]
10042ede:	42a3      	cmp	r3, r4
10042ee0:	d104      	bne.n	10042eec <_malloc_r+0xa4>
10042ee2:	6032      	str	r2, [r6, #0]
10042ee4:	6863      	ldr	r3, [r4, #4]
10042ee6:	6011      	str	r1, [r2, #0]
10042ee8:	6053      	str	r3, [r2, #4]
10042eea:	e005      	b.n	10042ef8 <_malloc_r+0xb0>
10042eec:	605a      	str	r2, [r3, #4]
10042eee:	e7f9      	b.n	10042ee4 <_malloc_r+0x9c>
10042ef0:	6862      	ldr	r2, [r4, #4]
10042ef2:	42a3      	cmp	r3, r4
10042ef4:	d10e      	bne.n	10042f14 <_malloc_r+0xcc>
10042ef6:	6032      	str	r2, [r6, #0]
10042ef8:	0028      	movs	r0, r5
10042efa:	f000 f82d 	bl	10042f58 <__malloc_unlock>
10042efe:	0020      	movs	r0, r4
10042f00:	2207      	movs	r2, #7
10042f02:	300b      	adds	r0, #11
10042f04:	1d23      	adds	r3, r4, #4
10042f06:	4390      	bics	r0, r2
10042f08:	1ac2      	subs	r2, r0, r3
10042f0a:	4298      	cmp	r0, r3
10042f0c:	d0df      	beq.n	10042ece <_malloc_r+0x86>
10042f0e:	1a1b      	subs	r3, r3, r0
10042f10:	50a3      	str	r3, [r4, r2]
10042f12:	e7dc      	b.n	10042ece <_malloc_r+0x86>
10042f14:	605a      	str	r2, [r3, #4]
10042f16:	e7ef      	b.n	10042ef8 <_malloc_r+0xb0>
10042f18:	0023      	movs	r3, r4
10042f1a:	6864      	ldr	r4, [r4, #4]
10042f1c:	e7a6      	b.n	10042e6c <_malloc_r+0x24>
10042f1e:	9c00      	ldr	r4, [sp, #0]
10042f20:	6863      	ldr	r3, [r4, #4]
10042f22:	9300      	str	r3, [sp, #0]
10042f24:	e7ad      	b.n	10042e82 <_malloc_r+0x3a>
10042f26:	001a      	movs	r2, r3
10042f28:	685b      	ldr	r3, [r3, #4]
10042f2a:	42a3      	cmp	r3, r4
10042f2c:	d1fb      	bne.n	10042f26 <_malloc_r+0xde>
10042f2e:	2300      	movs	r3, #0
10042f30:	e7da      	b.n	10042ee8 <_malloc_r+0xa0>
10042f32:	230c      	movs	r3, #12
10042f34:	0028      	movs	r0, r5
10042f36:	602b      	str	r3, [r5, #0]
10042f38:	f000 f80e 	bl	10042f58 <__malloc_unlock>
10042f3c:	e7c6      	b.n	10042ecc <_malloc_r+0x84>
10042f3e:	6007      	str	r7, [r0, #0]
10042f40:	e7da      	b.n	10042ef8 <_malloc_r+0xb0>
10042f42:	46c0      	nop			@ (mov r8, r8)
10042f44:	200002b8 	.word	0x200002b8

10042f48 <__malloc_lock>:
10042f48:	b510      	push	{r4, lr}
10042f4a:	4802      	ldr	r0, [pc, #8]	@ (10042f54 <__malloc_lock+0xc>)
10042f4c:	f7ff ff0d 	bl	10042d6a <__retarget_lock_acquire_recursive>
10042f50:	bd10      	pop	{r4, pc}
10042f52:	46c0      	nop			@ (mov r8, r8)
10042f54:	200002b0 	.word	0x200002b0

10042f58 <__malloc_unlock>:
10042f58:	b510      	push	{r4, lr}
10042f5a:	4802      	ldr	r0, [pc, #8]	@ (10042f64 <__malloc_unlock+0xc>)
10042f5c:	f7ff ff06 	bl	10042d6c <__retarget_lock_release_recursive>
10042f60:	bd10      	pop	{r4, pc}
10042f62:	46c0      	nop			@ (mov r8, r8)
10042f64:	200002b0 	.word	0x200002b0

10042f68 <__sfputc_r>:
10042f68:	6893      	ldr	r3, [r2, #8]
10042f6a:	b510      	push	{r4, lr}
10042f6c:	3b01      	subs	r3, #1
10042f6e:	6093      	str	r3, [r2, #8]
10042f70:	2b00      	cmp	r3, #0
10042f72:	da04      	bge.n	10042f7e <__sfputc_r+0x16>
10042f74:	6994      	ldr	r4, [r2, #24]
10042f76:	42a3      	cmp	r3, r4
10042f78:	db07      	blt.n	10042f8a <__sfputc_r+0x22>
10042f7a:	290a      	cmp	r1, #10
10042f7c:	d005      	beq.n	10042f8a <__sfputc_r+0x22>
10042f7e:	6813      	ldr	r3, [r2, #0]
10042f80:	1c58      	adds	r0, r3, #1
10042f82:	6010      	str	r0, [r2, #0]
10042f84:	7019      	strb	r1, [r3, #0]
10042f86:	0008      	movs	r0, r1
10042f88:	bd10      	pop	{r4, pc}
10042f8a:	f7ff fdf1 	bl	10042b70 <__swbuf_r>
10042f8e:	0001      	movs	r1, r0
10042f90:	e7f9      	b.n	10042f86 <__sfputc_r+0x1e>

10042f92 <__sfputs_r>:
10042f92:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10042f94:	0006      	movs	r6, r0
10042f96:	000f      	movs	r7, r1
10042f98:	0014      	movs	r4, r2
10042f9a:	18d5      	adds	r5, r2, r3
10042f9c:	42ac      	cmp	r4, r5
10042f9e:	d101      	bne.n	10042fa4 <__sfputs_r+0x12>
10042fa0:	2000      	movs	r0, #0
10042fa2:	e007      	b.n	10042fb4 <__sfputs_r+0x22>
10042fa4:	7821      	ldrb	r1, [r4, #0]
10042fa6:	003a      	movs	r2, r7
10042fa8:	0030      	movs	r0, r6
10042faa:	f7ff ffdd 	bl	10042f68 <__sfputc_r>
10042fae:	3401      	adds	r4, #1
10042fb0:	1c43      	adds	r3, r0, #1
10042fb2:	d1f3      	bne.n	10042f9c <__sfputs_r+0xa>
10042fb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

10042fb8 <_vfiprintf_r>:
10042fb8:	b5f0      	push	{r4, r5, r6, r7, lr}
10042fba:	b0a1      	sub	sp, #132	@ 0x84
10042fbc:	000f      	movs	r7, r1
10042fbe:	0015      	movs	r5, r2
10042fc0:	001e      	movs	r6, r3
10042fc2:	9003      	str	r0, [sp, #12]
10042fc4:	2800      	cmp	r0, #0
10042fc6:	d004      	beq.n	10042fd2 <_vfiprintf_r+0x1a>
10042fc8:	6a03      	ldr	r3, [r0, #32]
10042fca:	2b00      	cmp	r3, #0
10042fcc:	d101      	bne.n	10042fd2 <_vfiprintf_r+0x1a>
10042fce:	f7ff fcdf 	bl	10042990 <__sinit>
10042fd2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10042fd4:	07db      	lsls	r3, r3, #31
10042fd6:	d405      	bmi.n	10042fe4 <_vfiprintf_r+0x2c>
10042fd8:	89bb      	ldrh	r3, [r7, #12]
10042fda:	059b      	lsls	r3, r3, #22
10042fdc:	d402      	bmi.n	10042fe4 <_vfiprintf_r+0x2c>
10042fde:	6db8      	ldr	r0, [r7, #88]	@ 0x58
10042fe0:	f7ff fec3 	bl	10042d6a <__retarget_lock_acquire_recursive>
10042fe4:	89bb      	ldrh	r3, [r7, #12]
10042fe6:	071b      	lsls	r3, r3, #28
10042fe8:	d502      	bpl.n	10042ff0 <_vfiprintf_r+0x38>
10042fea:	693b      	ldr	r3, [r7, #16]
10042fec:	2b00      	cmp	r3, #0
10042fee:	d113      	bne.n	10043018 <_vfiprintf_r+0x60>
10042ff0:	0039      	movs	r1, r7
10042ff2:	9803      	ldr	r0, [sp, #12]
10042ff4:	f7ff fdfe 	bl	10042bf4 <__swsetup_r>
10042ff8:	2800      	cmp	r0, #0
10042ffa:	d00d      	beq.n	10043018 <_vfiprintf_r+0x60>
10042ffc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
10042ffe:	07db      	lsls	r3, r3, #31
10043000:	d503      	bpl.n	1004300a <_vfiprintf_r+0x52>
10043002:	2001      	movs	r0, #1
10043004:	4240      	negs	r0, r0
10043006:	b021      	add	sp, #132	@ 0x84
10043008:	bdf0      	pop	{r4, r5, r6, r7, pc}
1004300a:	89bb      	ldrh	r3, [r7, #12]
1004300c:	059b      	lsls	r3, r3, #22
1004300e:	d4f8      	bmi.n	10043002 <_vfiprintf_r+0x4a>
10043010:	6db8      	ldr	r0, [r7, #88]	@ 0x58
10043012:	f7ff feab 	bl	10042d6c <__retarget_lock_release_recursive>
10043016:	e7f4      	b.n	10043002 <_vfiprintf_r+0x4a>
10043018:	2300      	movs	r3, #0
1004301a:	ac08      	add	r4, sp, #32
1004301c:	6163      	str	r3, [r4, #20]
1004301e:	3320      	adds	r3, #32
10043020:	7663      	strb	r3, [r4, #25]
10043022:	3310      	adds	r3, #16
10043024:	76a3      	strb	r3, [r4, #26]
10043026:	9607      	str	r6, [sp, #28]
10043028:	002e      	movs	r6, r5
1004302a:	7833      	ldrb	r3, [r6, #0]
1004302c:	2b00      	cmp	r3, #0
1004302e:	d001      	beq.n	10043034 <_vfiprintf_r+0x7c>
10043030:	2b25      	cmp	r3, #37	@ 0x25
10043032:	d148      	bne.n	100430c6 <_vfiprintf_r+0x10e>
10043034:	1b73      	subs	r3, r6, r5
10043036:	9305      	str	r3, [sp, #20]
10043038:	42ae      	cmp	r6, r5
1004303a:	d00b      	beq.n	10043054 <_vfiprintf_r+0x9c>
1004303c:	002a      	movs	r2, r5
1004303e:	0039      	movs	r1, r7
10043040:	9803      	ldr	r0, [sp, #12]
10043042:	f7ff ffa6 	bl	10042f92 <__sfputs_r>
10043046:	3001      	adds	r0, #1
10043048:	d100      	bne.n	1004304c <_vfiprintf_r+0x94>
1004304a:	e0ae      	b.n	100431aa <_vfiprintf_r+0x1f2>
1004304c:	6963      	ldr	r3, [r4, #20]
1004304e:	9a05      	ldr	r2, [sp, #20]
10043050:	189b      	adds	r3, r3, r2
10043052:	6163      	str	r3, [r4, #20]
10043054:	7833      	ldrb	r3, [r6, #0]
10043056:	2b00      	cmp	r3, #0
10043058:	d100      	bne.n	1004305c <_vfiprintf_r+0xa4>
1004305a:	e0a6      	b.n	100431aa <_vfiprintf_r+0x1f2>
1004305c:	2201      	movs	r2, #1
1004305e:	2300      	movs	r3, #0
10043060:	4252      	negs	r2, r2
10043062:	6062      	str	r2, [r4, #4]
10043064:	a904      	add	r1, sp, #16
10043066:	3254      	adds	r2, #84	@ 0x54
10043068:	1852      	adds	r2, r2, r1
1004306a:	1c75      	adds	r5, r6, #1
1004306c:	6023      	str	r3, [r4, #0]
1004306e:	60e3      	str	r3, [r4, #12]
10043070:	60a3      	str	r3, [r4, #8]
10043072:	7013      	strb	r3, [r2, #0]
10043074:	65a3      	str	r3, [r4, #88]	@ 0x58
10043076:	4b59      	ldr	r3, [pc, #356]	@ (100431dc <_vfiprintf_r+0x224>)
10043078:	2205      	movs	r2, #5
1004307a:	0018      	movs	r0, r3
1004307c:	7829      	ldrb	r1, [r5, #0]
1004307e:	9305      	str	r3, [sp, #20]
10043080:	f000 fb88 	bl	10043794 <memchr>
10043084:	1c6e      	adds	r6, r5, #1
10043086:	2800      	cmp	r0, #0
10043088:	d11f      	bne.n	100430ca <_vfiprintf_r+0x112>
1004308a:	6822      	ldr	r2, [r4, #0]
1004308c:	06d3      	lsls	r3, r2, #27
1004308e:	d504      	bpl.n	1004309a <_vfiprintf_r+0xe2>
10043090:	2353      	movs	r3, #83	@ 0x53
10043092:	a904      	add	r1, sp, #16
10043094:	185b      	adds	r3, r3, r1
10043096:	2120      	movs	r1, #32
10043098:	7019      	strb	r1, [r3, #0]
1004309a:	0713      	lsls	r3, r2, #28
1004309c:	d504      	bpl.n	100430a8 <_vfiprintf_r+0xf0>
1004309e:	2353      	movs	r3, #83	@ 0x53
100430a0:	a904      	add	r1, sp, #16
100430a2:	185b      	adds	r3, r3, r1
100430a4:	212b      	movs	r1, #43	@ 0x2b
100430a6:	7019      	strb	r1, [r3, #0]
100430a8:	782b      	ldrb	r3, [r5, #0]
100430aa:	2b2a      	cmp	r3, #42	@ 0x2a
100430ac:	d016      	beq.n	100430dc <_vfiprintf_r+0x124>
100430ae:	002e      	movs	r6, r5
100430b0:	2100      	movs	r1, #0
100430b2:	200a      	movs	r0, #10
100430b4:	68e3      	ldr	r3, [r4, #12]
100430b6:	7832      	ldrb	r2, [r6, #0]
100430b8:	1c75      	adds	r5, r6, #1
100430ba:	3a30      	subs	r2, #48	@ 0x30
100430bc:	2a09      	cmp	r2, #9
100430be:	d950      	bls.n	10043162 <_vfiprintf_r+0x1aa>
100430c0:	2900      	cmp	r1, #0
100430c2:	d111      	bne.n	100430e8 <_vfiprintf_r+0x130>
100430c4:	e017      	b.n	100430f6 <_vfiprintf_r+0x13e>
100430c6:	3601      	adds	r6, #1
100430c8:	e7af      	b.n	1004302a <_vfiprintf_r+0x72>
100430ca:	9b05      	ldr	r3, [sp, #20]
100430cc:	6822      	ldr	r2, [r4, #0]
100430ce:	1ac0      	subs	r0, r0, r3
100430d0:	2301      	movs	r3, #1
100430d2:	4083      	lsls	r3, r0
100430d4:	4313      	orrs	r3, r2
100430d6:	0035      	movs	r5, r6
100430d8:	6023      	str	r3, [r4, #0]
100430da:	e7cc      	b.n	10043076 <_vfiprintf_r+0xbe>
100430dc:	9b07      	ldr	r3, [sp, #28]
100430de:	1d19      	adds	r1, r3, #4
100430e0:	681b      	ldr	r3, [r3, #0]
100430e2:	9107      	str	r1, [sp, #28]
100430e4:	2b00      	cmp	r3, #0
100430e6:	db01      	blt.n	100430ec <_vfiprintf_r+0x134>
100430e8:	930b      	str	r3, [sp, #44]	@ 0x2c
100430ea:	e004      	b.n	100430f6 <_vfiprintf_r+0x13e>
100430ec:	425b      	negs	r3, r3
100430ee:	60e3      	str	r3, [r4, #12]
100430f0:	2302      	movs	r3, #2
100430f2:	4313      	orrs	r3, r2
100430f4:	6023      	str	r3, [r4, #0]
100430f6:	7833      	ldrb	r3, [r6, #0]
100430f8:	2b2e      	cmp	r3, #46	@ 0x2e
100430fa:	d10c      	bne.n	10043116 <_vfiprintf_r+0x15e>
100430fc:	7873      	ldrb	r3, [r6, #1]
100430fe:	2b2a      	cmp	r3, #42	@ 0x2a
10043100:	d134      	bne.n	1004316c <_vfiprintf_r+0x1b4>
10043102:	9b07      	ldr	r3, [sp, #28]
10043104:	3602      	adds	r6, #2
10043106:	1d1a      	adds	r2, r3, #4
10043108:	681b      	ldr	r3, [r3, #0]
1004310a:	9207      	str	r2, [sp, #28]
1004310c:	2b00      	cmp	r3, #0
1004310e:	da01      	bge.n	10043114 <_vfiprintf_r+0x15c>
10043110:	2301      	movs	r3, #1
10043112:	425b      	negs	r3, r3
10043114:	9309      	str	r3, [sp, #36]	@ 0x24
10043116:	4d32      	ldr	r5, [pc, #200]	@ (100431e0 <_vfiprintf_r+0x228>)
10043118:	2203      	movs	r2, #3
1004311a:	0028      	movs	r0, r5
1004311c:	7831      	ldrb	r1, [r6, #0]
1004311e:	f000 fb39 	bl	10043794 <memchr>
10043122:	2800      	cmp	r0, #0
10043124:	d006      	beq.n	10043134 <_vfiprintf_r+0x17c>
10043126:	2340      	movs	r3, #64	@ 0x40
10043128:	1b40      	subs	r0, r0, r5
1004312a:	4083      	lsls	r3, r0
1004312c:	6822      	ldr	r2, [r4, #0]
1004312e:	3601      	adds	r6, #1
10043130:	4313      	orrs	r3, r2
10043132:	6023      	str	r3, [r4, #0]
10043134:	7831      	ldrb	r1, [r6, #0]
10043136:	2206      	movs	r2, #6
10043138:	482a      	ldr	r0, [pc, #168]	@ (100431e4 <_vfiprintf_r+0x22c>)
1004313a:	1c75      	adds	r5, r6, #1
1004313c:	7621      	strb	r1, [r4, #24]
1004313e:	f000 fb29 	bl	10043794 <memchr>
10043142:	2800      	cmp	r0, #0
10043144:	d040      	beq.n	100431c8 <_vfiprintf_r+0x210>
10043146:	4b28      	ldr	r3, [pc, #160]	@ (100431e8 <_vfiprintf_r+0x230>)
10043148:	2b00      	cmp	r3, #0
1004314a:	d122      	bne.n	10043192 <_vfiprintf_r+0x1da>
1004314c:	2207      	movs	r2, #7
1004314e:	9b07      	ldr	r3, [sp, #28]
10043150:	3307      	adds	r3, #7
10043152:	4393      	bics	r3, r2
10043154:	3308      	adds	r3, #8
10043156:	9307      	str	r3, [sp, #28]
10043158:	6963      	ldr	r3, [r4, #20]
1004315a:	9a04      	ldr	r2, [sp, #16]
1004315c:	189b      	adds	r3, r3, r2
1004315e:	6163      	str	r3, [r4, #20]
10043160:	e762      	b.n	10043028 <_vfiprintf_r+0x70>
10043162:	4343      	muls	r3, r0
10043164:	002e      	movs	r6, r5
10043166:	2101      	movs	r1, #1
10043168:	189b      	adds	r3, r3, r2
1004316a:	e7a4      	b.n	100430b6 <_vfiprintf_r+0xfe>
1004316c:	2300      	movs	r3, #0
1004316e:	200a      	movs	r0, #10
10043170:	0019      	movs	r1, r3
10043172:	3601      	adds	r6, #1
10043174:	6063      	str	r3, [r4, #4]
10043176:	7832      	ldrb	r2, [r6, #0]
10043178:	1c75      	adds	r5, r6, #1
1004317a:	3a30      	subs	r2, #48	@ 0x30
1004317c:	2a09      	cmp	r2, #9
1004317e:	d903      	bls.n	10043188 <_vfiprintf_r+0x1d0>
10043180:	2b00      	cmp	r3, #0
10043182:	d0c8      	beq.n	10043116 <_vfiprintf_r+0x15e>
10043184:	9109      	str	r1, [sp, #36]	@ 0x24
10043186:	e7c6      	b.n	10043116 <_vfiprintf_r+0x15e>
10043188:	4341      	muls	r1, r0
1004318a:	002e      	movs	r6, r5
1004318c:	2301      	movs	r3, #1
1004318e:	1889      	adds	r1, r1, r2
10043190:	e7f1      	b.n	10043176 <_vfiprintf_r+0x1be>
10043192:	aa07      	add	r2, sp, #28
10043194:	9200      	str	r2, [sp, #0]
10043196:	0021      	movs	r1, r4
10043198:	003a      	movs	r2, r7
1004319a:	4b14      	ldr	r3, [pc, #80]	@ (100431ec <_vfiprintf_r+0x234>)
1004319c:	9803      	ldr	r0, [sp, #12]
1004319e:	e000      	b.n	100431a2 <_vfiprintf_r+0x1ea>
100431a0:	bf00      	nop
100431a2:	9004      	str	r0, [sp, #16]
100431a4:	9b04      	ldr	r3, [sp, #16]
100431a6:	3301      	adds	r3, #1
100431a8:	d1d6      	bne.n	10043158 <_vfiprintf_r+0x1a0>
100431aa:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
100431ac:	07db      	lsls	r3, r3, #31
100431ae:	d405      	bmi.n	100431bc <_vfiprintf_r+0x204>
100431b0:	89bb      	ldrh	r3, [r7, #12]
100431b2:	059b      	lsls	r3, r3, #22
100431b4:	d402      	bmi.n	100431bc <_vfiprintf_r+0x204>
100431b6:	6db8      	ldr	r0, [r7, #88]	@ 0x58
100431b8:	f7ff fdd8 	bl	10042d6c <__retarget_lock_release_recursive>
100431bc:	89bb      	ldrh	r3, [r7, #12]
100431be:	065b      	lsls	r3, r3, #25
100431c0:	d500      	bpl.n	100431c4 <_vfiprintf_r+0x20c>
100431c2:	e71e      	b.n	10043002 <_vfiprintf_r+0x4a>
100431c4:	980d      	ldr	r0, [sp, #52]	@ 0x34
100431c6:	e71e      	b.n	10043006 <_vfiprintf_r+0x4e>
100431c8:	aa07      	add	r2, sp, #28
100431ca:	9200      	str	r2, [sp, #0]
100431cc:	0021      	movs	r1, r4
100431ce:	003a      	movs	r2, r7
100431d0:	4b06      	ldr	r3, [pc, #24]	@ (100431ec <_vfiprintf_r+0x234>)
100431d2:	9803      	ldr	r0, [sp, #12]
100431d4:	f000 f87c 	bl	100432d0 <_printf_i>
100431d8:	e7e3      	b.n	100431a2 <_vfiprintf_r+0x1ea>
100431da:	46c0      	nop			@ (mov r8, r8)
100431dc:	10043878 	.word	0x10043878
100431e0:	1004387e 	.word	0x1004387e
100431e4:	10043882 	.word	0x10043882
100431e8:	00000000 	.word	0x00000000
100431ec:	10042f93 	.word	0x10042f93

100431f0 <_printf_common>:
100431f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100431f2:	0016      	movs	r6, r2
100431f4:	9301      	str	r3, [sp, #4]
100431f6:	688a      	ldr	r2, [r1, #8]
100431f8:	690b      	ldr	r3, [r1, #16]
100431fa:	000c      	movs	r4, r1
100431fc:	9000      	str	r0, [sp, #0]
100431fe:	4293      	cmp	r3, r2
10043200:	da00      	bge.n	10043204 <_printf_common+0x14>
10043202:	0013      	movs	r3, r2
10043204:	0022      	movs	r2, r4
10043206:	6033      	str	r3, [r6, #0]
10043208:	3243      	adds	r2, #67	@ 0x43
1004320a:	7812      	ldrb	r2, [r2, #0]
1004320c:	2a00      	cmp	r2, #0
1004320e:	d001      	beq.n	10043214 <_printf_common+0x24>
10043210:	3301      	adds	r3, #1
10043212:	6033      	str	r3, [r6, #0]
10043214:	6823      	ldr	r3, [r4, #0]
10043216:	069b      	lsls	r3, r3, #26
10043218:	d502      	bpl.n	10043220 <_printf_common+0x30>
1004321a:	6833      	ldr	r3, [r6, #0]
1004321c:	3302      	adds	r3, #2
1004321e:	6033      	str	r3, [r6, #0]
10043220:	6822      	ldr	r2, [r4, #0]
10043222:	2306      	movs	r3, #6
10043224:	0015      	movs	r5, r2
10043226:	401d      	ands	r5, r3
10043228:	421a      	tst	r2, r3
1004322a:	d027      	beq.n	1004327c <_printf_common+0x8c>
1004322c:	0023      	movs	r3, r4
1004322e:	3343      	adds	r3, #67	@ 0x43
10043230:	781b      	ldrb	r3, [r3, #0]
10043232:	1e5a      	subs	r2, r3, #1
10043234:	4193      	sbcs	r3, r2
10043236:	6822      	ldr	r2, [r4, #0]
10043238:	0692      	lsls	r2, r2, #26
1004323a:	d430      	bmi.n	1004329e <_printf_common+0xae>
1004323c:	0022      	movs	r2, r4
1004323e:	9901      	ldr	r1, [sp, #4]
10043240:	9800      	ldr	r0, [sp, #0]
10043242:	9d08      	ldr	r5, [sp, #32]
10043244:	3243      	adds	r2, #67	@ 0x43
10043246:	47a8      	blx	r5
10043248:	3001      	adds	r0, #1
1004324a:	d025      	beq.n	10043298 <_printf_common+0xa8>
1004324c:	2206      	movs	r2, #6
1004324e:	6823      	ldr	r3, [r4, #0]
10043250:	2500      	movs	r5, #0
10043252:	4013      	ands	r3, r2
10043254:	2b04      	cmp	r3, #4
10043256:	d105      	bne.n	10043264 <_printf_common+0x74>
10043258:	6833      	ldr	r3, [r6, #0]
1004325a:	68e5      	ldr	r5, [r4, #12]
1004325c:	1aed      	subs	r5, r5, r3
1004325e:	43eb      	mvns	r3, r5
10043260:	17db      	asrs	r3, r3, #31
10043262:	401d      	ands	r5, r3
10043264:	68a3      	ldr	r3, [r4, #8]
10043266:	6922      	ldr	r2, [r4, #16]
10043268:	4293      	cmp	r3, r2
1004326a:	dd01      	ble.n	10043270 <_printf_common+0x80>
1004326c:	1a9b      	subs	r3, r3, r2
1004326e:	18ed      	adds	r5, r5, r3
10043270:	2600      	movs	r6, #0
10043272:	42b5      	cmp	r5, r6
10043274:	d120      	bne.n	100432b8 <_printf_common+0xc8>
10043276:	2000      	movs	r0, #0
10043278:	e010      	b.n	1004329c <_printf_common+0xac>
1004327a:	3501      	adds	r5, #1
1004327c:	68e3      	ldr	r3, [r4, #12]
1004327e:	6832      	ldr	r2, [r6, #0]
10043280:	1a9b      	subs	r3, r3, r2
10043282:	42ab      	cmp	r3, r5
10043284:	ddd2      	ble.n	1004322c <_printf_common+0x3c>
10043286:	0022      	movs	r2, r4
10043288:	2301      	movs	r3, #1
1004328a:	9901      	ldr	r1, [sp, #4]
1004328c:	9800      	ldr	r0, [sp, #0]
1004328e:	9f08      	ldr	r7, [sp, #32]
10043290:	3219      	adds	r2, #25
10043292:	47b8      	blx	r7
10043294:	3001      	adds	r0, #1
10043296:	d1f0      	bne.n	1004327a <_printf_common+0x8a>
10043298:	2001      	movs	r0, #1
1004329a:	4240      	negs	r0, r0
1004329c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
1004329e:	2030      	movs	r0, #48	@ 0x30
100432a0:	18e1      	adds	r1, r4, r3
100432a2:	3143      	adds	r1, #67	@ 0x43
100432a4:	7008      	strb	r0, [r1, #0]
100432a6:	0021      	movs	r1, r4
100432a8:	1c5a      	adds	r2, r3, #1
100432aa:	3145      	adds	r1, #69	@ 0x45
100432ac:	7809      	ldrb	r1, [r1, #0]
100432ae:	18a2      	adds	r2, r4, r2
100432b0:	3243      	adds	r2, #67	@ 0x43
100432b2:	3302      	adds	r3, #2
100432b4:	7011      	strb	r1, [r2, #0]
100432b6:	e7c1      	b.n	1004323c <_printf_common+0x4c>
100432b8:	0022      	movs	r2, r4
100432ba:	2301      	movs	r3, #1
100432bc:	9901      	ldr	r1, [sp, #4]
100432be:	9800      	ldr	r0, [sp, #0]
100432c0:	9f08      	ldr	r7, [sp, #32]
100432c2:	321a      	adds	r2, #26
100432c4:	47b8      	blx	r7
100432c6:	3001      	adds	r0, #1
100432c8:	d0e6      	beq.n	10043298 <_printf_common+0xa8>
100432ca:	3601      	adds	r6, #1
100432cc:	e7d1      	b.n	10043272 <_printf_common+0x82>
	...

100432d0 <_printf_i>:
100432d0:	b5f0      	push	{r4, r5, r6, r7, lr}
100432d2:	b08b      	sub	sp, #44	@ 0x2c
100432d4:	9206      	str	r2, [sp, #24]
100432d6:	000a      	movs	r2, r1
100432d8:	3243      	adds	r2, #67	@ 0x43
100432da:	9307      	str	r3, [sp, #28]
100432dc:	9005      	str	r0, [sp, #20]
100432de:	9203      	str	r2, [sp, #12]
100432e0:	7e0a      	ldrb	r2, [r1, #24]
100432e2:	000c      	movs	r4, r1
100432e4:	9b10      	ldr	r3, [sp, #64]	@ 0x40
100432e6:	2a78      	cmp	r2, #120	@ 0x78
100432e8:	d809      	bhi.n	100432fe <_printf_i+0x2e>
100432ea:	2a62      	cmp	r2, #98	@ 0x62
100432ec:	d80b      	bhi.n	10043306 <_printf_i+0x36>
100432ee:	2a00      	cmp	r2, #0
100432f0:	d100      	bne.n	100432f4 <_printf_i+0x24>
100432f2:	e0bc      	b.n	1004346e <_printf_i+0x19e>
100432f4:	497b      	ldr	r1, [pc, #492]	@ (100434e4 <_printf_i+0x214>)
100432f6:	9104      	str	r1, [sp, #16]
100432f8:	2a58      	cmp	r2, #88	@ 0x58
100432fa:	d100      	bne.n	100432fe <_printf_i+0x2e>
100432fc:	e090      	b.n	10043420 <_printf_i+0x150>
100432fe:	0025      	movs	r5, r4
10043300:	3542      	adds	r5, #66	@ 0x42
10043302:	702a      	strb	r2, [r5, #0]
10043304:	e022      	b.n	1004334c <_printf_i+0x7c>
10043306:	0010      	movs	r0, r2
10043308:	3863      	subs	r0, #99	@ 0x63
1004330a:	2815      	cmp	r0, #21
1004330c:	d8f7      	bhi.n	100432fe <_printf_i+0x2e>
1004330e:	f7fc fed7 	bl	100400c0 <__gnu_thumb1_case_shi>
10043312:	0016      	.short	0x0016
10043314:	fff6001f 	.word	0xfff6001f
10043318:	fff6fff6 	.word	0xfff6fff6
1004331c:	001ffff6 	.word	0x001ffff6
10043320:	fff6fff6 	.word	0xfff6fff6
10043324:	fff6fff6 	.word	0xfff6fff6
10043328:	003600a1 	.word	0x003600a1
1004332c:	fff60080 	.word	0xfff60080
10043330:	00b2fff6 	.word	0x00b2fff6
10043334:	0036fff6 	.word	0x0036fff6
10043338:	fff6fff6 	.word	0xfff6fff6
1004333c:	0084      	.short	0x0084
1004333e:	0025      	movs	r5, r4
10043340:	681a      	ldr	r2, [r3, #0]
10043342:	3542      	adds	r5, #66	@ 0x42
10043344:	1d11      	adds	r1, r2, #4
10043346:	6019      	str	r1, [r3, #0]
10043348:	6813      	ldr	r3, [r2, #0]
1004334a:	702b      	strb	r3, [r5, #0]
1004334c:	2301      	movs	r3, #1
1004334e:	e0a0      	b.n	10043492 <_printf_i+0x1c2>
10043350:	6818      	ldr	r0, [r3, #0]
10043352:	6809      	ldr	r1, [r1, #0]
10043354:	1d02      	adds	r2, r0, #4
10043356:	060d      	lsls	r5, r1, #24
10043358:	d50b      	bpl.n	10043372 <_printf_i+0xa2>
1004335a:	6806      	ldr	r6, [r0, #0]
1004335c:	601a      	str	r2, [r3, #0]
1004335e:	2e00      	cmp	r6, #0
10043360:	da03      	bge.n	1004336a <_printf_i+0x9a>
10043362:	232d      	movs	r3, #45	@ 0x2d
10043364:	9a03      	ldr	r2, [sp, #12]
10043366:	4276      	negs	r6, r6
10043368:	7013      	strb	r3, [r2, #0]
1004336a:	4b5e      	ldr	r3, [pc, #376]	@ (100434e4 <_printf_i+0x214>)
1004336c:	270a      	movs	r7, #10
1004336e:	9304      	str	r3, [sp, #16]
10043370:	e018      	b.n	100433a4 <_printf_i+0xd4>
10043372:	6806      	ldr	r6, [r0, #0]
10043374:	601a      	str	r2, [r3, #0]
10043376:	0649      	lsls	r1, r1, #25
10043378:	d5f1      	bpl.n	1004335e <_printf_i+0x8e>
1004337a:	b236      	sxth	r6, r6
1004337c:	e7ef      	b.n	1004335e <_printf_i+0x8e>
1004337e:	6808      	ldr	r0, [r1, #0]
10043380:	6819      	ldr	r1, [r3, #0]
10043382:	c940      	ldmia	r1!, {r6}
10043384:	0605      	lsls	r5, r0, #24
10043386:	d402      	bmi.n	1004338e <_printf_i+0xbe>
10043388:	0640      	lsls	r0, r0, #25
1004338a:	d500      	bpl.n	1004338e <_printf_i+0xbe>
1004338c:	b2b6      	uxth	r6, r6
1004338e:	6019      	str	r1, [r3, #0]
10043390:	4b54      	ldr	r3, [pc, #336]	@ (100434e4 <_printf_i+0x214>)
10043392:	270a      	movs	r7, #10
10043394:	9304      	str	r3, [sp, #16]
10043396:	2a6f      	cmp	r2, #111	@ 0x6f
10043398:	d100      	bne.n	1004339c <_printf_i+0xcc>
1004339a:	3f02      	subs	r7, #2
1004339c:	0023      	movs	r3, r4
1004339e:	2200      	movs	r2, #0
100433a0:	3343      	adds	r3, #67	@ 0x43
100433a2:	701a      	strb	r2, [r3, #0]
100433a4:	6863      	ldr	r3, [r4, #4]
100433a6:	60a3      	str	r3, [r4, #8]
100433a8:	2b00      	cmp	r3, #0
100433aa:	db03      	blt.n	100433b4 <_printf_i+0xe4>
100433ac:	2104      	movs	r1, #4
100433ae:	6822      	ldr	r2, [r4, #0]
100433b0:	438a      	bics	r2, r1
100433b2:	6022      	str	r2, [r4, #0]
100433b4:	2e00      	cmp	r6, #0
100433b6:	d102      	bne.n	100433be <_printf_i+0xee>
100433b8:	9d03      	ldr	r5, [sp, #12]
100433ba:	2b00      	cmp	r3, #0
100433bc:	d00c      	beq.n	100433d8 <_printf_i+0x108>
100433be:	9d03      	ldr	r5, [sp, #12]
100433c0:	0030      	movs	r0, r6
100433c2:	0039      	movs	r1, r7
100433c4:	f7fc ff0c 	bl	100401e0 <__aeabi_uidivmod>
100433c8:	9b04      	ldr	r3, [sp, #16]
100433ca:	3d01      	subs	r5, #1
100433cc:	5c5b      	ldrb	r3, [r3, r1]
100433ce:	702b      	strb	r3, [r5, #0]
100433d0:	0033      	movs	r3, r6
100433d2:	0006      	movs	r6, r0
100433d4:	429f      	cmp	r7, r3
100433d6:	d9f3      	bls.n	100433c0 <_printf_i+0xf0>
100433d8:	2f08      	cmp	r7, #8
100433da:	d109      	bne.n	100433f0 <_printf_i+0x120>
100433dc:	6823      	ldr	r3, [r4, #0]
100433de:	07db      	lsls	r3, r3, #31
100433e0:	d506      	bpl.n	100433f0 <_printf_i+0x120>
100433e2:	6862      	ldr	r2, [r4, #4]
100433e4:	6923      	ldr	r3, [r4, #16]
100433e6:	429a      	cmp	r2, r3
100433e8:	dc02      	bgt.n	100433f0 <_printf_i+0x120>
100433ea:	2330      	movs	r3, #48	@ 0x30
100433ec:	3d01      	subs	r5, #1
100433ee:	702b      	strb	r3, [r5, #0]
100433f0:	9b03      	ldr	r3, [sp, #12]
100433f2:	1b5b      	subs	r3, r3, r5
100433f4:	6123      	str	r3, [r4, #16]
100433f6:	9b07      	ldr	r3, [sp, #28]
100433f8:	0021      	movs	r1, r4
100433fa:	9300      	str	r3, [sp, #0]
100433fc:	9805      	ldr	r0, [sp, #20]
100433fe:	9b06      	ldr	r3, [sp, #24]
10043400:	aa09      	add	r2, sp, #36	@ 0x24
10043402:	f7ff fef5 	bl	100431f0 <_printf_common>
10043406:	3001      	adds	r0, #1
10043408:	d148      	bne.n	1004349c <_printf_i+0x1cc>
1004340a:	2001      	movs	r0, #1
1004340c:	4240      	negs	r0, r0
1004340e:	b00b      	add	sp, #44	@ 0x2c
10043410:	bdf0      	pop	{r4, r5, r6, r7, pc}
10043412:	2220      	movs	r2, #32
10043414:	6809      	ldr	r1, [r1, #0]
10043416:	430a      	orrs	r2, r1
10043418:	6022      	str	r2, [r4, #0]
1004341a:	2278      	movs	r2, #120	@ 0x78
1004341c:	4932      	ldr	r1, [pc, #200]	@ (100434e8 <_printf_i+0x218>)
1004341e:	9104      	str	r1, [sp, #16]
10043420:	0021      	movs	r1, r4
10043422:	3145      	adds	r1, #69	@ 0x45
10043424:	700a      	strb	r2, [r1, #0]
10043426:	6819      	ldr	r1, [r3, #0]
10043428:	6822      	ldr	r2, [r4, #0]
1004342a:	c940      	ldmia	r1!, {r6}
1004342c:	0610      	lsls	r0, r2, #24
1004342e:	d402      	bmi.n	10043436 <_printf_i+0x166>
10043430:	0650      	lsls	r0, r2, #25
10043432:	d500      	bpl.n	10043436 <_printf_i+0x166>
10043434:	b2b6      	uxth	r6, r6
10043436:	6019      	str	r1, [r3, #0]
10043438:	07d3      	lsls	r3, r2, #31
1004343a:	d502      	bpl.n	10043442 <_printf_i+0x172>
1004343c:	2320      	movs	r3, #32
1004343e:	4313      	orrs	r3, r2
10043440:	6023      	str	r3, [r4, #0]
10043442:	2e00      	cmp	r6, #0
10043444:	d001      	beq.n	1004344a <_printf_i+0x17a>
10043446:	2710      	movs	r7, #16
10043448:	e7a8      	b.n	1004339c <_printf_i+0xcc>
1004344a:	2220      	movs	r2, #32
1004344c:	6823      	ldr	r3, [r4, #0]
1004344e:	4393      	bics	r3, r2
10043450:	6023      	str	r3, [r4, #0]
10043452:	e7f8      	b.n	10043446 <_printf_i+0x176>
10043454:	681a      	ldr	r2, [r3, #0]
10043456:	680d      	ldr	r5, [r1, #0]
10043458:	1d10      	adds	r0, r2, #4
1004345a:	6949      	ldr	r1, [r1, #20]
1004345c:	6018      	str	r0, [r3, #0]
1004345e:	6813      	ldr	r3, [r2, #0]
10043460:	062e      	lsls	r6, r5, #24
10043462:	d501      	bpl.n	10043468 <_printf_i+0x198>
10043464:	6019      	str	r1, [r3, #0]
10043466:	e002      	b.n	1004346e <_printf_i+0x19e>
10043468:	066d      	lsls	r5, r5, #25
1004346a:	d5fb      	bpl.n	10043464 <_printf_i+0x194>
1004346c:	8019      	strh	r1, [r3, #0]
1004346e:	2300      	movs	r3, #0
10043470:	9d03      	ldr	r5, [sp, #12]
10043472:	6123      	str	r3, [r4, #16]
10043474:	e7bf      	b.n	100433f6 <_printf_i+0x126>
10043476:	681a      	ldr	r2, [r3, #0]
10043478:	1d11      	adds	r1, r2, #4
1004347a:	6019      	str	r1, [r3, #0]
1004347c:	6815      	ldr	r5, [r2, #0]
1004347e:	2100      	movs	r1, #0
10043480:	0028      	movs	r0, r5
10043482:	6862      	ldr	r2, [r4, #4]
10043484:	f000 f986 	bl	10043794 <memchr>
10043488:	2800      	cmp	r0, #0
1004348a:	d001      	beq.n	10043490 <_printf_i+0x1c0>
1004348c:	1b40      	subs	r0, r0, r5
1004348e:	6060      	str	r0, [r4, #4]
10043490:	6863      	ldr	r3, [r4, #4]
10043492:	6123      	str	r3, [r4, #16]
10043494:	2300      	movs	r3, #0
10043496:	9a03      	ldr	r2, [sp, #12]
10043498:	7013      	strb	r3, [r2, #0]
1004349a:	e7ac      	b.n	100433f6 <_printf_i+0x126>
1004349c:	002a      	movs	r2, r5
1004349e:	6923      	ldr	r3, [r4, #16]
100434a0:	9906      	ldr	r1, [sp, #24]
100434a2:	9805      	ldr	r0, [sp, #20]
100434a4:	9d07      	ldr	r5, [sp, #28]
100434a6:	47a8      	blx	r5
100434a8:	3001      	adds	r0, #1
100434aa:	d0ae      	beq.n	1004340a <_printf_i+0x13a>
100434ac:	6823      	ldr	r3, [r4, #0]
100434ae:	079b      	lsls	r3, r3, #30
100434b0:	d415      	bmi.n	100434de <_printf_i+0x20e>
100434b2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
100434b4:	68e0      	ldr	r0, [r4, #12]
100434b6:	4298      	cmp	r0, r3
100434b8:	daa9      	bge.n	1004340e <_printf_i+0x13e>
100434ba:	0018      	movs	r0, r3
100434bc:	e7a7      	b.n	1004340e <_printf_i+0x13e>
100434be:	0022      	movs	r2, r4
100434c0:	2301      	movs	r3, #1
100434c2:	9906      	ldr	r1, [sp, #24]
100434c4:	9805      	ldr	r0, [sp, #20]
100434c6:	9e07      	ldr	r6, [sp, #28]
100434c8:	3219      	adds	r2, #25
100434ca:	47b0      	blx	r6
100434cc:	3001      	adds	r0, #1
100434ce:	d09c      	beq.n	1004340a <_printf_i+0x13a>
100434d0:	3501      	adds	r5, #1
100434d2:	68e3      	ldr	r3, [r4, #12]
100434d4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
100434d6:	1a9b      	subs	r3, r3, r2
100434d8:	42ab      	cmp	r3, r5
100434da:	dcf0      	bgt.n	100434be <_printf_i+0x1ee>
100434dc:	e7e9      	b.n	100434b2 <_printf_i+0x1e2>
100434de:	2500      	movs	r5, #0
100434e0:	e7f7      	b.n	100434d2 <_printf_i+0x202>
100434e2:	46c0      	nop			@ (mov r8, r8)
100434e4:	10043889 	.word	0x10043889
100434e8:	1004389a 	.word	0x1004389a

100434ec <__sflush_r>:
100434ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
100434ee:	220c      	movs	r2, #12
100434f0:	5e8b      	ldrsh	r3, [r1, r2]
100434f2:	0005      	movs	r5, r0
100434f4:	000c      	movs	r4, r1
100434f6:	071a      	lsls	r2, r3, #28
100434f8:	d456      	bmi.n	100435a8 <__sflush_r+0xbc>
100434fa:	684a      	ldr	r2, [r1, #4]
100434fc:	2a00      	cmp	r2, #0
100434fe:	dc02      	bgt.n	10043506 <__sflush_r+0x1a>
10043500:	6c0a      	ldr	r2, [r1, #64]	@ 0x40
10043502:	2a00      	cmp	r2, #0
10043504:	dd4e      	ble.n	100435a4 <__sflush_r+0xb8>
10043506:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
10043508:	2f00      	cmp	r7, #0
1004350a:	d04b      	beq.n	100435a4 <__sflush_r+0xb8>
1004350c:	2200      	movs	r2, #0
1004350e:	2080      	movs	r0, #128	@ 0x80
10043510:	682e      	ldr	r6, [r5, #0]
10043512:	602a      	str	r2, [r5, #0]
10043514:	001a      	movs	r2, r3
10043516:	0140      	lsls	r0, r0, #5
10043518:	6a21      	ldr	r1, [r4, #32]
1004351a:	4002      	ands	r2, r0
1004351c:	4203      	tst	r3, r0
1004351e:	d033      	beq.n	10043588 <__sflush_r+0x9c>
10043520:	6d62      	ldr	r2, [r4, #84]	@ 0x54
10043522:	89a3      	ldrh	r3, [r4, #12]
10043524:	075b      	lsls	r3, r3, #29
10043526:	d506      	bpl.n	10043536 <__sflush_r+0x4a>
10043528:	6863      	ldr	r3, [r4, #4]
1004352a:	1ad2      	subs	r2, r2, r3
1004352c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
1004352e:	2b00      	cmp	r3, #0
10043530:	d001      	beq.n	10043536 <__sflush_r+0x4a>
10043532:	6c23      	ldr	r3, [r4, #64]	@ 0x40
10043534:	1ad2      	subs	r2, r2, r3
10043536:	2300      	movs	r3, #0
10043538:	0028      	movs	r0, r5
1004353a:	6ae7      	ldr	r7, [r4, #44]	@ 0x2c
1004353c:	6a21      	ldr	r1, [r4, #32]
1004353e:	47b8      	blx	r7
10043540:	89a2      	ldrh	r2, [r4, #12]
10043542:	1c43      	adds	r3, r0, #1
10043544:	d106      	bne.n	10043554 <__sflush_r+0x68>
10043546:	6829      	ldr	r1, [r5, #0]
10043548:	291d      	cmp	r1, #29
1004354a:	d846      	bhi.n	100435da <__sflush_r+0xee>
1004354c:	4b29      	ldr	r3, [pc, #164]	@ (100435f4 <__sflush_r+0x108>)
1004354e:	410b      	asrs	r3, r1
10043550:	07db      	lsls	r3, r3, #31
10043552:	d442      	bmi.n	100435da <__sflush_r+0xee>
10043554:	2300      	movs	r3, #0
10043556:	6063      	str	r3, [r4, #4]
10043558:	6923      	ldr	r3, [r4, #16]
1004355a:	6023      	str	r3, [r4, #0]
1004355c:	04d2      	lsls	r2, r2, #19
1004355e:	d505      	bpl.n	1004356c <__sflush_r+0x80>
10043560:	1c43      	adds	r3, r0, #1
10043562:	d102      	bne.n	1004356a <__sflush_r+0x7e>
10043564:	682b      	ldr	r3, [r5, #0]
10043566:	2b00      	cmp	r3, #0
10043568:	d100      	bne.n	1004356c <__sflush_r+0x80>
1004356a:	6560      	str	r0, [r4, #84]	@ 0x54
1004356c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
1004356e:	602e      	str	r6, [r5, #0]
10043570:	2900      	cmp	r1, #0
10043572:	d017      	beq.n	100435a4 <__sflush_r+0xb8>
10043574:	0023      	movs	r3, r4
10043576:	3344      	adds	r3, #68	@ 0x44
10043578:	4299      	cmp	r1, r3
1004357a:	d002      	beq.n	10043582 <__sflush_r+0x96>
1004357c:	0028      	movs	r0, r5
1004357e:	f7ff fbf7 	bl	10042d70 <_free_r>
10043582:	2300      	movs	r3, #0
10043584:	6363      	str	r3, [r4, #52]	@ 0x34
10043586:	e00d      	b.n	100435a4 <__sflush_r+0xb8>
10043588:	2301      	movs	r3, #1
1004358a:	0028      	movs	r0, r5
1004358c:	47b8      	blx	r7
1004358e:	0002      	movs	r2, r0
10043590:	1c43      	adds	r3, r0, #1
10043592:	d1c6      	bne.n	10043522 <__sflush_r+0x36>
10043594:	682b      	ldr	r3, [r5, #0]
10043596:	2b00      	cmp	r3, #0
10043598:	d0c3      	beq.n	10043522 <__sflush_r+0x36>
1004359a:	2b1d      	cmp	r3, #29
1004359c:	d001      	beq.n	100435a2 <__sflush_r+0xb6>
1004359e:	2b16      	cmp	r3, #22
100435a0:	d11a      	bne.n	100435d8 <__sflush_r+0xec>
100435a2:	602e      	str	r6, [r5, #0]
100435a4:	2000      	movs	r0, #0
100435a6:	e01e      	b.n	100435e6 <__sflush_r+0xfa>
100435a8:	690e      	ldr	r6, [r1, #16]
100435aa:	2e00      	cmp	r6, #0
100435ac:	d0fa      	beq.n	100435a4 <__sflush_r+0xb8>
100435ae:	680f      	ldr	r7, [r1, #0]
100435b0:	600e      	str	r6, [r1, #0]
100435b2:	1bba      	subs	r2, r7, r6
100435b4:	9201      	str	r2, [sp, #4]
100435b6:	2200      	movs	r2, #0
100435b8:	079b      	lsls	r3, r3, #30
100435ba:	d100      	bne.n	100435be <__sflush_r+0xd2>
100435bc:	694a      	ldr	r2, [r1, #20]
100435be:	60a2      	str	r2, [r4, #8]
100435c0:	9b01      	ldr	r3, [sp, #4]
100435c2:	2b00      	cmp	r3, #0
100435c4:	ddee      	ble.n	100435a4 <__sflush_r+0xb8>
100435c6:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
100435c8:	0032      	movs	r2, r6
100435ca:	001f      	movs	r7, r3
100435cc:	0028      	movs	r0, r5
100435ce:	9b01      	ldr	r3, [sp, #4]
100435d0:	6a21      	ldr	r1, [r4, #32]
100435d2:	47b8      	blx	r7
100435d4:	2800      	cmp	r0, #0
100435d6:	dc07      	bgt.n	100435e8 <__sflush_r+0xfc>
100435d8:	89a2      	ldrh	r2, [r4, #12]
100435da:	2340      	movs	r3, #64	@ 0x40
100435dc:	2001      	movs	r0, #1
100435de:	4313      	orrs	r3, r2
100435e0:	b21b      	sxth	r3, r3
100435e2:	81a3      	strh	r3, [r4, #12]
100435e4:	4240      	negs	r0, r0
100435e6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
100435e8:	9b01      	ldr	r3, [sp, #4]
100435ea:	1836      	adds	r6, r6, r0
100435ec:	1a1b      	subs	r3, r3, r0
100435ee:	9301      	str	r3, [sp, #4]
100435f0:	e7e6      	b.n	100435c0 <__sflush_r+0xd4>
100435f2:	46c0      	nop			@ (mov r8, r8)
100435f4:	dfbffffe 	.word	0xdfbffffe

100435f8 <_fflush_r>:
100435f8:	690b      	ldr	r3, [r1, #16]
100435fa:	b570      	push	{r4, r5, r6, lr}
100435fc:	0005      	movs	r5, r0
100435fe:	000c      	movs	r4, r1
10043600:	2b00      	cmp	r3, #0
10043602:	d102      	bne.n	1004360a <_fflush_r+0x12>
10043604:	2500      	movs	r5, #0
10043606:	0028      	movs	r0, r5
10043608:	bd70      	pop	{r4, r5, r6, pc}
1004360a:	2800      	cmp	r0, #0
1004360c:	d004      	beq.n	10043618 <_fflush_r+0x20>
1004360e:	6a03      	ldr	r3, [r0, #32]
10043610:	2b00      	cmp	r3, #0
10043612:	d101      	bne.n	10043618 <_fflush_r+0x20>
10043614:	f7ff f9bc 	bl	10042990 <__sinit>
10043618:	220c      	movs	r2, #12
1004361a:	5ea3      	ldrsh	r3, [r4, r2]
1004361c:	2b00      	cmp	r3, #0
1004361e:	d0f1      	beq.n	10043604 <_fflush_r+0xc>
10043620:	6e62      	ldr	r2, [r4, #100]	@ 0x64
10043622:	07d2      	lsls	r2, r2, #31
10043624:	d404      	bmi.n	10043630 <_fflush_r+0x38>
10043626:	059b      	lsls	r3, r3, #22
10043628:	d402      	bmi.n	10043630 <_fflush_r+0x38>
1004362a:	6da0      	ldr	r0, [r4, #88]	@ 0x58
1004362c:	f7ff fb9d 	bl	10042d6a <__retarget_lock_acquire_recursive>
10043630:	0028      	movs	r0, r5
10043632:	0021      	movs	r1, r4
10043634:	f7ff ff5a 	bl	100434ec <__sflush_r>
10043638:	6e63      	ldr	r3, [r4, #100]	@ 0x64
1004363a:	0005      	movs	r5, r0
1004363c:	07db      	lsls	r3, r3, #31
1004363e:	d4e2      	bmi.n	10043606 <_fflush_r+0xe>
10043640:	89a3      	ldrh	r3, [r4, #12]
10043642:	059b      	lsls	r3, r3, #22
10043644:	d4df      	bmi.n	10043606 <_fflush_r+0xe>
10043646:	6da0      	ldr	r0, [r4, #88]	@ 0x58
10043648:	f7ff fb90 	bl	10042d6c <__retarget_lock_release_recursive>
1004364c:	e7db      	b.n	10043606 <_fflush_r+0xe>
	...

10043650 <__swhatbuf_r>:
10043650:	b570      	push	{r4, r5, r6, lr}
10043652:	000e      	movs	r6, r1
10043654:	001d      	movs	r5, r3
10043656:	230e      	movs	r3, #14
10043658:	5ec9      	ldrsh	r1, [r1, r3]
1004365a:	0014      	movs	r4, r2
1004365c:	b096      	sub	sp, #88	@ 0x58
1004365e:	2900      	cmp	r1, #0
10043660:	da0c      	bge.n	1004367c <__swhatbuf_r+0x2c>
10043662:	89b2      	ldrh	r2, [r6, #12]
10043664:	2380      	movs	r3, #128	@ 0x80
10043666:	0011      	movs	r1, r2
10043668:	4019      	ands	r1, r3
1004366a:	421a      	tst	r2, r3
1004366c:	d114      	bne.n	10043698 <__swhatbuf_r+0x48>
1004366e:	2380      	movs	r3, #128	@ 0x80
10043670:	00db      	lsls	r3, r3, #3
10043672:	2000      	movs	r0, #0
10043674:	6029      	str	r1, [r5, #0]
10043676:	6023      	str	r3, [r4, #0]
10043678:	b016      	add	sp, #88	@ 0x58
1004367a:	bd70      	pop	{r4, r5, r6, pc}
1004367c:	466a      	mov	r2, sp
1004367e:	f000 f853 	bl	10043728 <_fstat_r>
10043682:	2800      	cmp	r0, #0
10043684:	dbed      	blt.n	10043662 <__swhatbuf_r+0x12>
10043686:	23f0      	movs	r3, #240	@ 0xf0
10043688:	9901      	ldr	r1, [sp, #4]
1004368a:	021b      	lsls	r3, r3, #8
1004368c:	4019      	ands	r1, r3
1004368e:	4b04      	ldr	r3, [pc, #16]	@ (100436a0 <__swhatbuf_r+0x50>)
10043690:	18c9      	adds	r1, r1, r3
10043692:	424b      	negs	r3, r1
10043694:	4159      	adcs	r1, r3
10043696:	e7ea      	b.n	1004366e <__swhatbuf_r+0x1e>
10043698:	2100      	movs	r1, #0
1004369a:	2340      	movs	r3, #64	@ 0x40
1004369c:	e7e9      	b.n	10043672 <__swhatbuf_r+0x22>
1004369e:	46c0      	nop			@ (mov r8, r8)
100436a0:	ffffe000 	.word	0xffffe000

100436a4 <__smakebuf_r>:
100436a4:	b5f0      	push	{r4, r5, r6, r7, lr}
100436a6:	2602      	movs	r6, #2
100436a8:	898b      	ldrh	r3, [r1, #12]
100436aa:	0005      	movs	r5, r0
100436ac:	000c      	movs	r4, r1
100436ae:	b085      	sub	sp, #20
100436b0:	4233      	tst	r3, r6
100436b2:	d007      	beq.n	100436c4 <__smakebuf_r+0x20>
100436b4:	0023      	movs	r3, r4
100436b6:	3347      	adds	r3, #71	@ 0x47
100436b8:	6023      	str	r3, [r4, #0]
100436ba:	6123      	str	r3, [r4, #16]
100436bc:	2301      	movs	r3, #1
100436be:	6163      	str	r3, [r4, #20]
100436c0:	b005      	add	sp, #20
100436c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
100436c4:	ab03      	add	r3, sp, #12
100436c6:	aa02      	add	r2, sp, #8
100436c8:	f7ff ffc2 	bl	10043650 <__swhatbuf_r>
100436cc:	9f02      	ldr	r7, [sp, #8]
100436ce:	9001      	str	r0, [sp, #4]
100436d0:	0039      	movs	r1, r7
100436d2:	0028      	movs	r0, r5
100436d4:	f7ff fbb8 	bl	10042e48 <_malloc_r>
100436d8:	2800      	cmp	r0, #0
100436da:	d108      	bne.n	100436ee <__smakebuf_r+0x4a>
100436dc:	220c      	movs	r2, #12
100436de:	5ea3      	ldrsh	r3, [r4, r2]
100436e0:	059a      	lsls	r2, r3, #22
100436e2:	d4ed      	bmi.n	100436c0 <__smakebuf_r+0x1c>
100436e4:	2203      	movs	r2, #3
100436e6:	4393      	bics	r3, r2
100436e8:	431e      	orrs	r6, r3
100436ea:	81a6      	strh	r6, [r4, #12]
100436ec:	e7e2      	b.n	100436b4 <__smakebuf_r+0x10>
100436ee:	2380      	movs	r3, #128	@ 0x80
100436f0:	89a2      	ldrh	r2, [r4, #12]
100436f2:	6020      	str	r0, [r4, #0]
100436f4:	4313      	orrs	r3, r2
100436f6:	81a3      	strh	r3, [r4, #12]
100436f8:	9b03      	ldr	r3, [sp, #12]
100436fa:	6120      	str	r0, [r4, #16]
100436fc:	6167      	str	r7, [r4, #20]
100436fe:	2b00      	cmp	r3, #0
10043700:	d00c      	beq.n	1004371c <__smakebuf_r+0x78>
10043702:	0028      	movs	r0, r5
10043704:	230e      	movs	r3, #14
10043706:	5ee1      	ldrsh	r1, [r4, r3]
10043708:	f000 f820 	bl	1004374c <_isatty_r>
1004370c:	2800      	cmp	r0, #0
1004370e:	d005      	beq.n	1004371c <__smakebuf_r+0x78>
10043710:	2303      	movs	r3, #3
10043712:	89a2      	ldrh	r2, [r4, #12]
10043714:	439a      	bics	r2, r3
10043716:	3b02      	subs	r3, #2
10043718:	4313      	orrs	r3, r2
1004371a:	81a3      	strh	r3, [r4, #12]
1004371c:	89a3      	ldrh	r3, [r4, #12]
1004371e:	9a01      	ldr	r2, [sp, #4]
10043720:	4313      	orrs	r3, r2
10043722:	81a3      	strh	r3, [r4, #12]
10043724:	e7cc      	b.n	100436c0 <__smakebuf_r+0x1c>
	...

10043728 <_fstat_r>:
10043728:	2300      	movs	r3, #0
1004372a:	b570      	push	{r4, r5, r6, lr}
1004372c:	4d06      	ldr	r5, [pc, #24]	@ (10043748 <_fstat_r+0x20>)
1004372e:	0004      	movs	r4, r0
10043730:	0008      	movs	r0, r1
10043732:	0011      	movs	r1, r2
10043734:	602b      	str	r3, [r5, #0]
10043736:	f7fd f888 	bl	1004084a <_fstat>
1004373a:	1c43      	adds	r3, r0, #1
1004373c:	d103      	bne.n	10043746 <_fstat_r+0x1e>
1004373e:	682b      	ldr	r3, [r5, #0]
10043740:	2b00      	cmp	r3, #0
10043742:	d000      	beq.n	10043746 <_fstat_r+0x1e>
10043744:	6023      	str	r3, [r4, #0]
10043746:	bd70      	pop	{r4, r5, r6, pc}
10043748:	200002ac 	.word	0x200002ac

1004374c <_isatty_r>:
1004374c:	2300      	movs	r3, #0
1004374e:	b570      	push	{r4, r5, r6, lr}
10043750:	4d06      	ldr	r5, [pc, #24]	@ (1004376c <_isatty_r+0x20>)
10043752:	0004      	movs	r4, r0
10043754:	0008      	movs	r0, r1
10043756:	602b      	str	r3, [r5, #0]
10043758:	f7fd f885 	bl	10040866 <_isatty>
1004375c:	1c43      	adds	r3, r0, #1
1004375e:	d103      	bne.n	10043768 <_isatty_r+0x1c>
10043760:	682b      	ldr	r3, [r5, #0]
10043762:	2b00      	cmp	r3, #0
10043764:	d000      	beq.n	10043768 <_isatty_r+0x1c>
10043766:	6023      	str	r3, [r4, #0]
10043768:	bd70      	pop	{r4, r5, r6, pc}
1004376a:	46c0      	nop			@ (mov r8, r8)
1004376c:	200002ac 	.word	0x200002ac

10043770 <_sbrk_r>:
10043770:	2300      	movs	r3, #0
10043772:	b570      	push	{r4, r5, r6, lr}
10043774:	4d06      	ldr	r5, [pc, #24]	@ (10043790 <_sbrk_r+0x20>)
10043776:	0004      	movs	r4, r0
10043778:	0008      	movs	r0, r1
1004377a:	602b      	str	r3, [r5, #0]
1004377c:	f7fd f888 	bl	10040890 <_sbrk>
10043780:	1c43      	adds	r3, r0, #1
10043782:	d103      	bne.n	1004378c <_sbrk_r+0x1c>
10043784:	682b      	ldr	r3, [r5, #0]
10043786:	2b00      	cmp	r3, #0
10043788:	d000      	beq.n	1004378c <_sbrk_r+0x1c>
1004378a:	6023      	str	r3, [r4, #0]
1004378c:	bd70      	pop	{r4, r5, r6, pc}
1004378e:	46c0      	nop			@ (mov r8, r8)
10043790:	200002ac 	.word	0x200002ac

10043794 <memchr>:
10043794:	b2c9      	uxtb	r1, r1
10043796:	1882      	adds	r2, r0, r2
10043798:	4290      	cmp	r0, r2
1004379a:	d101      	bne.n	100437a0 <memchr+0xc>
1004379c:	2000      	movs	r0, #0
1004379e:	4770      	bx	lr
100437a0:	7803      	ldrb	r3, [r0, #0]
100437a2:	428b      	cmp	r3, r1
100437a4:	d0fb      	beq.n	1004379e <memchr+0xa>
100437a6:	3001      	adds	r0, #1
100437a8:	e7f6      	b.n	10043798 <memchr+0x4>
	...

Disassembly of section .init:

100437ac <_init>:
100437ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100437ae:	46c0      	nop			@ (mov r8, r8)

Disassembly of section .fini:

100437b0 <_fini>:
100437b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100437b2:	46c0      	nop			@ (mov r8, r8)
