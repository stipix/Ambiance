
WildlifeSource.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .intvec       000000c0  10040000  10040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002444  100400c0  100400c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  10042504  10042504  00003504  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  10042508  10042508  00003508  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000000ac  1004250c  1004250c  0000350c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM          00000008  100425b8  100425b8  000035b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         00000020  20000158  100425c0  00004158  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ram_preamble 0000002c  20000004  20000004  00005004  2**2
                  ALLOC
  8 .bss.blueRAM  00000000  200000c0  200000c0  00000000  2**0
                  ALLOC
  9 .bss          00000098  200000c0  200000c0  00005004  2**2
                  ALLOC
 10 .noinit       00000000  20000178  100425e0  00000000  2**0
                  ALLOC
 11 .ota_region_end 00000000  100425e0  100425e0  00004178  2**0
                  CONTENTS
 12 .heap         00000000  20000178  20000178  00004178  2**0
                  CONTENTS
 13 .stack        00000c00  20005400  20005400  00004400  2**0
                  ALLOC
 14 .rom_info     00000000  10000000  10000000  00004178  2**0
                  CONTENTS
 15 .ARM.attributes 00000028  00000000  00000000  00004178  2**0
                  CONTENTS, READONLY
 16 .debug_info   0000b3ba  00000000  00000000  000041a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00001dc8  00000000  00000000  0000f55a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 000009e0  00000000  00000000  00011328  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00000786  00000000  00000000  00011d08  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  00017802  00000000  00000000  0001248e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0000b720  00000000  00000000  00029c90  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    0009e806  00000000  00000000  000353b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  000d3bb6  2**0
                  CONTENTS, READONLY
 24 .debug_frame  00002244  00000000  00000000  000d3bfc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 0000007c  00000000  00000000  000d5e40  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

100400c0 <__udivsi3>:
100400c0:	2200      	movs	r2, #0
100400c2:	0843      	lsrs	r3, r0, #1
100400c4:	428b      	cmp	r3, r1
100400c6:	d374      	bcc.n	100401b2 <__udivsi3+0xf2>
100400c8:	0903      	lsrs	r3, r0, #4
100400ca:	428b      	cmp	r3, r1
100400cc:	d35f      	bcc.n	1004018e <__udivsi3+0xce>
100400ce:	0a03      	lsrs	r3, r0, #8
100400d0:	428b      	cmp	r3, r1
100400d2:	d344      	bcc.n	1004015e <__udivsi3+0x9e>
100400d4:	0b03      	lsrs	r3, r0, #12
100400d6:	428b      	cmp	r3, r1
100400d8:	d328      	bcc.n	1004012c <__udivsi3+0x6c>
100400da:	0c03      	lsrs	r3, r0, #16
100400dc:	428b      	cmp	r3, r1
100400de:	d30d      	bcc.n	100400fc <__udivsi3+0x3c>
100400e0:	22ff      	movs	r2, #255	@ 0xff
100400e2:	0209      	lsls	r1, r1, #8
100400e4:	ba12      	rev	r2, r2
100400e6:	0c03      	lsrs	r3, r0, #16
100400e8:	428b      	cmp	r3, r1
100400ea:	d302      	bcc.n	100400f2 <__udivsi3+0x32>
100400ec:	1212      	asrs	r2, r2, #8
100400ee:	0209      	lsls	r1, r1, #8
100400f0:	d065      	beq.n	100401be <__udivsi3+0xfe>
100400f2:	0b03      	lsrs	r3, r0, #12
100400f4:	428b      	cmp	r3, r1
100400f6:	d319      	bcc.n	1004012c <__udivsi3+0x6c>
100400f8:	e000      	b.n	100400fc <__udivsi3+0x3c>
100400fa:	0a09      	lsrs	r1, r1, #8
100400fc:	0bc3      	lsrs	r3, r0, #15
100400fe:	428b      	cmp	r3, r1
10040100:	d301      	bcc.n	10040106 <__udivsi3+0x46>
10040102:	03cb      	lsls	r3, r1, #15
10040104:	1ac0      	subs	r0, r0, r3
10040106:	4152      	adcs	r2, r2
10040108:	0b83      	lsrs	r3, r0, #14
1004010a:	428b      	cmp	r3, r1
1004010c:	d301      	bcc.n	10040112 <__udivsi3+0x52>
1004010e:	038b      	lsls	r3, r1, #14
10040110:	1ac0      	subs	r0, r0, r3
10040112:	4152      	adcs	r2, r2
10040114:	0b43      	lsrs	r3, r0, #13
10040116:	428b      	cmp	r3, r1
10040118:	d301      	bcc.n	1004011e <__udivsi3+0x5e>
1004011a:	034b      	lsls	r3, r1, #13
1004011c:	1ac0      	subs	r0, r0, r3
1004011e:	4152      	adcs	r2, r2
10040120:	0b03      	lsrs	r3, r0, #12
10040122:	428b      	cmp	r3, r1
10040124:	d301      	bcc.n	1004012a <__udivsi3+0x6a>
10040126:	030b      	lsls	r3, r1, #12
10040128:	1ac0      	subs	r0, r0, r3
1004012a:	4152      	adcs	r2, r2
1004012c:	0ac3      	lsrs	r3, r0, #11
1004012e:	428b      	cmp	r3, r1
10040130:	d301      	bcc.n	10040136 <__udivsi3+0x76>
10040132:	02cb      	lsls	r3, r1, #11
10040134:	1ac0      	subs	r0, r0, r3
10040136:	4152      	adcs	r2, r2
10040138:	0a83      	lsrs	r3, r0, #10
1004013a:	428b      	cmp	r3, r1
1004013c:	d301      	bcc.n	10040142 <__udivsi3+0x82>
1004013e:	028b      	lsls	r3, r1, #10
10040140:	1ac0      	subs	r0, r0, r3
10040142:	4152      	adcs	r2, r2
10040144:	0a43      	lsrs	r3, r0, #9
10040146:	428b      	cmp	r3, r1
10040148:	d301      	bcc.n	1004014e <__udivsi3+0x8e>
1004014a:	024b      	lsls	r3, r1, #9
1004014c:	1ac0      	subs	r0, r0, r3
1004014e:	4152      	adcs	r2, r2
10040150:	0a03      	lsrs	r3, r0, #8
10040152:	428b      	cmp	r3, r1
10040154:	d301      	bcc.n	1004015a <__udivsi3+0x9a>
10040156:	020b      	lsls	r3, r1, #8
10040158:	1ac0      	subs	r0, r0, r3
1004015a:	4152      	adcs	r2, r2
1004015c:	d2cd      	bcs.n	100400fa <__udivsi3+0x3a>
1004015e:	09c3      	lsrs	r3, r0, #7
10040160:	428b      	cmp	r3, r1
10040162:	d301      	bcc.n	10040168 <__udivsi3+0xa8>
10040164:	01cb      	lsls	r3, r1, #7
10040166:	1ac0      	subs	r0, r0, r3
10040168:	4152      	adcs	r2, r2
1004016a:	0983      	lsrs	r3, r0, #6
1004016c:	428b      	cmp	r3, r1
1004016e:	d301      	bcc.n	10040174 <__udivsi3+0xb4>
10040170:	018b      	lsls	r3, r1, #6
10040172:	1ac0      	subs	r0, r0, r3
10040174:	4152      	adcs	r2, r2
10040176:	0943      	lsrs	r3, r0, #5
10040178:	428b      	cmp	r3, r1
1004017a:	d301      	bcc.n	10040180 <__udivsi3+0xc0>
1004017c:	014b      	lsls	r3, r1, #5
1004017e:	1ac0      	subs	r0, r0, r3
10040180:	4152      	adcs	r2, r2
10040182:	0903      	lsrs	r3, r0, #4
10040184:	428b      	cmp	r3, r1
10040186:	d301      	bcc.n	1004018c <__udivsi3+0xcc>
10040188:	010b      	lsls	r3, r1, #4
1004018a:	1ac0      	subs	r0, r0, r3
1004018c:	4152      	adcs	r2, r2
1004018e:	08c3      	lsrs	r3, r0, #3
10040190:	428b      	cmp	r3, r1
10040192:	d301      	bcc.n	10040198 <__udivsi3+0xd8>
10040194:	00cb      	lsls	r3, r1, #3
10040196:	1ac0      	subs	r0, r0, r3
10040198:	4152      	adcs	r2, r2
1004019a:	0883      	lsrs	r3, r0, #2
1004019c:	428b      	cmp	r3, r1
1004019e:	d301      	bcc.n	100401a4 <__udivsi3+0xe4>
100401a0:	008b      	lsls	r3, r1, #2
100401a2:	1ac0      	subs	r0, r0, r3
100401a4:	4152      	adcs	r2, r2
100401a6:	0843      	lsrs	r3, r0, #1
100401a8:	428b      	cmp	r3, r1
100401aa:	d301      	bcc.n	100401b0 <__udivsi3+0xf0>
100401ac:	004b      	lsls	r3, r1, #1
100401ae:	1ac0      	subs	r0, r0, r3
100401b0:	4152      	adcs	r2, r2
100401b2:	1a41      	subs	r1, r0, r1
100401b4:	d200      	bcs.n	100401b8 <__udivsi3+0xf8>
100401b6:	4601      	mov	r1, r0
100401b8:	4152      	adcs	r2, r2
100401ba:	4610      	mov	r0, r2
100401bc:	4770      	bx	lr
100401be:	e7ff      	b.n	100401c0 <__udivsi3+0x100>
100401c0:	b501      	push	{r0, lr}
100401c2:	2000      	movs	r0, #0
100401c4:	f000 f8f0 	bl	100403a8 <__aeabi_idiv0>
100401c8:	bd02      	pop	{r1, pc}
100401ca:	46c0      	nop			@ (mov r8, r8)

100401cc <__aeabi_uidivmod>:
100401cc:	2900      	cmp	r1, #0
100401ce:	d0f7      	beq.n	100401c0 <__udivsi3+0x100>
100401d0:	e776      	b.n	100400c0 <__udivsi3>
100401d2:	4770      	bx	lr

100401d4 <__divsi3>:
100401d4:	4603      	mov	r3, r0
100401d6:	430b      	orrs	r3, r1
100401d8:	d47f      	bmi.n	100402da <__divsi3+0x106>
100401da:	2200      	movs	r2, #0
100401dc:	0843      	lsrs	r3, r0, #1
100401de:	428b      	cmp	r3, r1
100401e0:	d374      	bcc.n	100402cc <__divsi3+0xf8>
100401e2:	0903      	lsrs	r3, r0, #4
100401e4:	428b      	cmp	r3, r1
100401e6:	d35f      	bcc.n	100402a8 <__divsi3+0xd4>
100401e8:	0a03      	lsrs	r3, r0, #8
100401ea:	428b      	cmp	r3, r1
100401ec:	d344      	bcc.n	10040278 <__divsi3+0xa4>
100401ee:	0b03      	lsrs	r3, r0, #12
100401f0:	428b      	cmp	r3, r1
100401f2:	d328      	bcc.n	10040246 <__divsi3+0x72>
100401f4:	0c03      	lsrs	r3, r0, #16
100401f6:	428b      	cmp	r3, r1
100401f8:	d30d      	bcc.n	10040216 <__divsi3+0x42>
100401fa:	22ff      	movs	r2, #255	@ 0xff
100401fc:	0209      	lsls	r1, r1, #8
100401fe:	ba12      	rev	r2, r2
10040200:	0c03      	lsrs	r3, r0, #16
10040202:	428b      	cmp	r3, r1
10040204:	d302      	bcc.n	1004020c <__divsi3+0x38>
10040206:	1212      	asrs	r2, r2, #8
10040208:	0209      	lsls	r1, r1, #8
1004020a:	d065      	beq.n	100402d8 <__divsi3+0x104>
1004020c:	0b03      	lsrs	r3, r0, #12
1004020e:	428b      	cmp	r3, r1
10040210:	d319      	bcc.n	10040246 <__divsi3+0x72>
10040212:	e000      	b.n	10040216 <__divsi3+0x42>
10040214:	0a09      	lsrs	r1, r1, #8
10040216:	0bc3      	lsrs	r3, r0, #15
10040218:	428b      	cmp	r3, r1
1004021a:	d301      	bcc.n	10040220 <__divsi3+0x4c>
1004021c:	03cb      	lsls	r3, r1, #15
1004021e:	1ac0      	subs	r0, r0, r3
10040220:	4152      	adcs	r2, r2
10040222:	0b83      	lsrs	r3, r0, #14
10040224:	428b      	cmp	r3, r1
10040226:	d301      	bcc.n	1004022c <__divsi3+0x58>
10040228:	038b      	lsls	r3, r1, #14
1004022a:	1ac0      	subs	r0, r0, r3
1004022c:	4152      	adcs	r2, r2
1004022e:	0b43      	lsrs	r3, r0, #13
10040230:	428b      	cmp	r3, r1
10040232:	d301      	bcc.n	10040238 <__divsi3+0x64>
10040234:	034b      	lsls	r3, r1, #13
10040236:	1ac0      	subs	r0, r0, r3
10040238:	4152      	adcs	r2, r2
1004023a:	0b03      	lsrs	r3, r0, #12
1004023c:	428b      	cmp	r3, r1
1004023e:	d301      	bcc.n	10040244 <__divsi3+0x70>
10040240:	030b      	lsls	r3, r1, #12
10040242:	1ac0      	subs	r0, r0, r3
10040244:	4152      	adcs	r2, r2
10040246:	0ac3      	lsrs	r3, r0, #11
10040248:	428b      	cmp	r3, r1
1004024a:	d301      	bcc.n	10040250 <__divsi3+0x7c>
1004024c:	02cb      	lsls	r3, r1, #11
1004024e:	1ac0      	subs	r0, r0, r3
10040250:	4152      	adcs	r2, r2
10040252:	0a83      	lsrs	r3, r0, #10
10040254:	428b      	cmp	r3, r1
10040256:	d301      	bcc.n	1004025c <__divsi3+0x88>
10040258:	028b      	lsls	r3, r1, #10
1004025a:	1ac0      	subs	r0, r0, r3
1004025c:	4152      	adcs	r2, r2
1004025e:	0a43      	lsrs	r3, r0, #9
10040260:	428b      	cmp	r3, r1
10040262:	d301      	bcc.n	10040268 <__divsi3+0x94>
10040264:	024b      	lsls	r3, r1, #9
10040266:	1ac0      	subs	r0, r0, r3
10040268:	4152      	adcs	r2, r2
1004026a:	0a03      	lsrs	r3, r0, #8
1004026c:	428b      	cmp	r3, r1
1004026e:	d301      	bcc.n	10040274 <__divsi3+0xa0>
10040270:	020b      	lsls	r3, r1, #8
10040272:	1ac0      	subs	r0, r0, r3
10040274:	4152      	adcs	r2, r2
10040276:	d2cd      	bcs.n	10040214 <__divsi3+0x40>
10040278:	09c3      	lsrs	r3, r0, #7
1004027a:	428b      	cmp	r3, r1
1004027c:	d301      	bcc.n	10040282 <__divsi3+0xae>
1004027e:	01cb      	lsls	r3, r1, #7
10040280:	1ac0      	subs	r0, r0, r3
10040282:	4152      	adcs	r2, r2
10040284:	0983      	lsrs	r3, r0, #6
10040286:	428b      	cmp	r3, r1
10040288:	d301      	bcc.n	1004028e <__divsi3+0xba>
1004028a:	018b      	lsls	r3, r1, #6
1004028c:	1ac0      	subs	r0, r0, r3
1004028e:	4152      	adcs	r2, r2
10040290:	0943      	lsrs	r3, r0, #5
10040292:	428b      	cmp	r3, r1
10040294:	d301      	bcc.n	1004029a <__divsi3+0xc6>
10040296:	014b      	lsls	r3, r1, #5
10040298:	1ac0      	subs	r0, r0, r3
1004029a:	4152      	adcs	r2, r2
1004029c:	0903      	lsrs	r3, r0, #4
1004029e:	428b      	cmp	r3, r1
100402a0:	d301      	bcc.n	100402a6 <__divsi3+0xd2>
100402a2:	010b      	lsls	r3, r1, #4
100402a4:	1ac0      	subs	r0, r0, r3
100402a6:	4152      	adcs	r2, r2
100402a8:	08c3      	lsrs	r3, r0, #3
100402aa:	428b      	cmp	r3, r1
100402ac:	d301      	bcc.n	100402b2 <__divsi3+0xde>
100402ae:	00cb      	lsls	r3, r1, #3
100402b0:	1ac0      	subs	r0, r0, r3
100402b2:	4152      	adcs	r2, r2
100402b4:	0883      	lsrs	r3, r0, #2
100402b6:	428b      	cmp	r3, r1
100402b8:	d301      	bcc.n	100402be <__divsi3+0xea>
100402ba:	008b      	lsls	r3, r1, #2
100402bc:	1ac0      	subs	r0, r0, r3
100402be:	4152      	adcs	r2, r2
100402c0:	0843      	lsrs	r3, r0, #1
100402c2:	428b      	cmp	r3, r1
100402c4:	d301      	bcc.n	100402ca <__divsi3+0xf6>
100402c6:	004b      	lsls	r3, r1, #1
100402c8:	1ac0      	subs	r0, r0, r3
100402ca:	4152      	adcs	r2, r2
100402cc:	1a41      	subs	r1, r0, r1
100402ce:	d200      	bcs.n	100402d2 <__divsi3+0xfe>
100402d0:	4601      	mov	r1, r0
100402d2:	4152      	adcs	r2, r2
100402d4:	4610      	mov	r0, r2
100402d6:	4770      	bx	lr
100402d8:	e05d      	b.n	10040396 <__divsi3+0x1c2>
100402da:	0fca      	lsrs	r2, r1, #31
100402dc:	d000      	beq.n	100402e0 <__divsi3+0x10c>
100402de:	4249      	negs	r1, r1
100402e0:	1003      	asrs	r3, r0, #32
100402e2:	d300      	bcc.n	100402e6 <__divsi3+0x112>
100402e4:	4240      	negs	r0, r0
100402e6:	4053      	eors	r3, r2
100402e8:	2200      	movs	r2, #0
100402ea:	469c      	mov	ip, r3
100402ec:	0903      	lsrs	r3, r0, #4
100402ee:	428b      	cmp	r3, r1
100402f0:	d32d      	bcc.n	1004034e <__divsi3+0x17a>
100402f2:	0a03      	lsrs	r3, r0, #8
100402f4:	428b      	cmp	r3, r1
100402f6:	d312      	bcc.n	1004031e <__divsi3+0x14a>
100402f8:	22fc      	movs	r2, #252	@ 0xfc
100402fa:	0189      	lsls	r1, r1, #6
100402fc:	ba12      	rev	r2, r2
100402fe:	0a03      	lsrs	r3, r0, #8
10040300:	428b      	cmp	r3, r1
10040302:	d30c      	bcc.n	1004031e <__divsi3+0x14a>
10040304:	0189      	lsls	r1, r1, #6
10040306:	1192      	asrs	r2, r2, #6
10040308:	428b      	cmp	r3, r1
1004030a:	d308      	bcc.n	1004031e <__divsi3+0x14a>
1004030c:	0189      	lsls	r1, r1, #6
1004030e:	1192      	asrs	r2, r2, #6
10040310:	428b      	cmp	r3, r1
10040312:	d304      	bcc.n	1004031e <__divsi3+0x14a>
10040314:	0189      	lsls	r1, r1, #6
10040316:	d03a      	beq.n	1004038e <__divsi3+0x1ba>
10040318:	1192      	asrs	r2, r2, #6
1004031a:	e000      	b.n	1004031e <__divsi3+0x14a>
1004031c:	0989      	lsrs	r1, r1, #6
1004031e:	09c3      	lsrs	r3, r0, #7
10040320:	428b      	cmp	r3, r1
10040322:	d301      	bcc.n	10040328 <__divsi3+0x154>
10040324:	01cb      	lsls	r3, r1, #7
10040326:	1ac0      	subs	r0, r0, r3
10040328:	4152      	adcs	r2, r2
1004032a:	0983      	lsrs	r3, r0, #6
1004032c:	428b      	cmp	r3, r1
1004032e:	d301      	bcc.n	10040334 <__divsi3+0x160>
10040330:	018b      	lsls	r3, r1, #6
10040332:	1ac0      	subs	r0, r0, r3
10040334:	4152      	adcs	r2, r2
10040336:	0943      	lsrs	r3, r0, #5
10040338:	428b      	cmp	r3, r1
1004033a:	d301      	bcc.n	10040340 <__divsi3+0x16c>
1004033c:	014b      	lsls	r3, r1, #5
1004033e:	1ac0      	subs	r0, r0, r3
10040340:	4152      	adcs	r2, r2
10040342:	0903      	lsrs	r3, r0, #4
10040344:	428b      	cmp	r3, r1
10040346:	d301      	bcc.n	1004034c <__divsi3+0x178>
10040348:	010b      	lsls	r3, r1, #4
1004034a:	1ac0      	subs	r0, r0, r3
1004034c:	4152      	adcs	r2, r2
1004034e:	08c3      	lsrs	r3, r0, #3
10040350:	428b      	cmp	r3, r1
10040352:	d301      	bcc.n	10040358 <__divsi3+0x184>
10040354:	00cb      	lsls	r3, r1, #3
10040356:	1ac0      	subs	r0, r0, r3
10040358:	4152      	adcs	r2, r2
1004035a:	0883      	lsrs	r3, r0, #2
1004035c:	428b      	cmp	r3, r1
1004035e:	d301      	bcc.n	10040364 <__divsi3+0x190>
10040360:	008b      	lsls	r3, r1, #2
10040362:	1ac0      	subs	r0, r0, r3
10040364:	4152      	adcs	r2, r2
10040366:	d2d9      	bcs.n	1004031c <__divsi3+0x148>
10040368:	0843      	lsrs	r3, r0, #1
1004036a:	428b      	cmp	r3, r1
1004036c:	d301      	bcc.n	10040372 <__divsi3+0x19e>
1004036e:	004b      	lsls	r3, r1, #1
10040370:	1ac0      	subs	r0, r0, r3
10040372:	4152      	adcs	r2, r2
10040374:	1a41      	subs	r1, r0, r1
10040376:	d200      	bcs.n	1004037a <__divsi3+0x1a6>
10040378:	4601      	mov	r1, r0
1004037a:	4663      	mov	r3, ip
1004037c:	4152      	adcs	r2, r2
1004037e:	105b      	asrs	r3, r3, #1
10040380:	4610      	mov	r0, r2
10040382:	d301      	bcc.n	10040388 <__divsi3+0x1b4>
10040384:	4240      	negs	r0, r0
10040386:	2b00      	cmp	r3, #0
10040388:	d500      	bpl.n	1004038c <__divsi3+0x1b8>
1004038a:	4249      	negs	r1, r1
1004038c:	4770      	bx	lr
1004038e:	4663      	mov	r3, ip
10040390:	105b      	asrs	r3, r3, #1
10040392:	d300      	bcc.n	10040396 <__divsi3+0x1c2>
10040394:	4240      	negs	r0, r0
10040396:	b501      	push	{r0, lr}
10040398:	2000      	movs	r0, #0
1004039a:	f000 f805 	bl	100403a8 <__aeabi_idiv0>
1004039e:	bd02      	pop	{r1, pc}

100403a0 <__aeabi_idivmod>:
100403a0:	2900      	cmp	r1, #0
100403a2:	d0f8      	beq.n	10040396 <__divsi3+0x1c2>
100403a4:	e716      	b.n	100401d4 <__divsi3>
100403a6:	4770      	bx	lr

100403a8 <__aeabi_idiv0>:
100403a8:	4770      	bx	lr
100403aa:	46c0      	nop			@ (mov r8, r8)

100403ac <__aeabi_uldivmod>:
100403ac:	2b00      	cmp	r3, #0
100403ae:	d111      	bne.n	100403d4 <__aeabi_uldivmod+0x28>
100403b0:	2a00      	cmp	r2, #0
100403b2:	d10f      	bne.n	100403d4 <__aeabi_uldivmod+0x28>
100403b4:	2900      	cmp	r1, #0
100403b6:	d100      	bne.n	100403ba <__aeabi_uldivmod+0xe>
100403b8:	2800      	cmp	r0, #0
100403ba:	d002      	beq.n	100403c2 <__aeabi_uldivmod+0x16>
100403bc:	2100      	movs	r1, #0
100403be:	43c9      	mvns	r1, r1
100403c0:	0008      	movs	r0, r1
100403c2:	b407      	push	{r0, r1, r2}
100403c4:	4802      	ldr	r0, [pc, #8]	@ (100403d0 <__aeabi_uldivmod+0x24>)
100403c6:	a102      	add	r1, pc, #8	@ (adr r1, 100403d0 <__aeabi_uldivmod+0x24>)
100403c8:	1840      	adds	r0, r0, r1
100403ca:	9002      	str	r0, [sp, #8]
100403cc:	bd03      	pop	{r0, r1, pc}
100403ce:	46c0      	nop			@ (mov r8, r8)
100403d0:	ffffffd9 	.word	0xffffffd9
100403d4:	b403      	push	{r0, r1}
100403d6:	4668      	mov	r0, sp
100403d8:	b501      	push	{r0, lr}
100403da:	9802      	ldr	r0, [sp, #8]
100403dc:	f000 f806 	bl	100403ec <__udivmoddi4>
100403e0:	9b01      	ldr	r3, [sp, #4]
100403e2:	469e      	mov	lr, r3
100403e4:	b002      	add	sp, #8
100403e6:	bc0c      	pop	{r2, r3}
100403e8:	4770      	bx	lr
100403ea:	46c0      	nop			@ (mov r8, r8)

100403ec <__udivmoddi4>:
100403ec:	b5f0      	push	{r4, r5, r6, r7, lr}
100403ee:	4657      	mov	r7, sl
100403f0:	464e      	mov	r6, r9
100403f2:	4645      	mov	r5, r8
100403f4:	46de      	mov	lr, fp
100403f6:	b5e0      	push	{r5, r6, r7, lr}
100403f8:	0004      	movs	r4, r0
100403fa:	000d      	movs	r5, r1
100403fc:	4692      	mov	sl, r2
100403fe:	4699      	mov	r9, r3
10040400:	b083      	sub	sp, #12
10040402:	428b      	cmp	r3, r1
10040404:	d830      	bhi.n	10040468 <__udivmoddi4+0x7c>
10040406:	d02d      	beq.n	10040464 <__udivmoddi4+0x78>
10040408:	4649      	mov	r1, r9
1004040a:	4650      	mov	r0, sl
1004040c:	f000 f8ba 	bl	10040584 <__clzdi2>
10040410:	0029      	movs	r1, r5
10040412:	0006      	movs	r6, r0
10040414:	0020      	movs	r0, r4
10040416:	f000 f8b5 	bl	10040584 <__clzdi2>
1004041a:	1a33      	subs	r3, r6, r0
1004041c:	4698      	mov	r8, r3
1004041e:	3b20      	subs	r3, #32
10040420:	d434      	bmi.n	1004048c <__udivmoddi4+0xa0>
10040422:	469b      	mov	fp, r3
10040424:	4653      	mov	r3, sl
10040426:	465a      	mov	r2, fp
10040428:	4093      	lsls	r3, r2
1004042a:	4642      	mov	r2, r8
1004042c:	001f      	movs	r7, r3
1004042e:	4653      	mov	r3, sl
10040430:	4093      	lsls	r3, r2
10040432:	001e      	movs	r6, r3
10040434:	42af      	cmp	r7, r5
10040436:	d83b      	bhi.n	100404b0 <__udivmoddi4+0xc4>
10040438:	42af      	cmp	r7, r5
1004043a:	d100      	bne.n	1004043e <__udivmoddi4+0x52>
1004043c:	e079      	b.n	10040532 <__udivmoddi4+0x146>
1004043e:	465b      	mov	r3, fp
10040440:	1ba4      	subs	r4, r4, r6
10040442:	41bd      	sbcs	r5, r7
10040444:	2b00      	cmp	r3, #0
10040446:	da00      	bge.n	1004044a <__udivmoddi4+0x5e>
10040448:	e076      	b.n	10040538 <__udivmoddi4+0x14c>
1004044a:	2200      	movs	r2, #0
1004044c:	2300      	movs	r3, #0
1004044e:	9200      	str	r2, [sp, #0]
10040450:	9301      	str	r3, [sp, #4]
10040452:	2301      	movs	r3, #1
10040454:	465a      	mov	r2, fp
10040456:	4093      	lsls	r3, r2
10040458:	9301      	str	r3, [sp, #4]
1004045a:	2301      	movs	r3, #1
1004045c:	4642      	mov	r2, r8
1004045e:	4093      	lsls	r3, r2
10040460:	9300      	str	r3, [sp, #0]
10040462:	e029      	b.n	100404b8 <__udivmoddi4+0xcc>
10040464:	4282      	cmp	r2, r0
10040466:	d9cf      	bls.n	10040408 <__udivmoddi4+0x1c>
10040468:	2200      	movs	r2, #0
1004046a:	2300      	movs	r3, #0
1004046c:	9200      	str	r2, [sp, #0]
1004046e:	9301      	str	r3, [sp, #4]
10040470:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
10040472:	2b00      	cmp	r3, #0
10040474:	d001      	beq.n	1004047a <__udivmoddi4+0x8e>
10040476:	601c      	str	r4, [r3, #0]
10040478:	605d      	str	r5, [r3, #4]
1004047a:	9800      	ldr	r0, [sp, #0]
1004047c:	9901      	ldr	r1, [sp, #4]
1004047e:	b003      	add	sp, #12
10040480:	bcf0      	pop	{r4, r5, r6, r7}
10040482:	46bb      	mov	fp, r7
10040484:	46b2      	mov	sl, r6
10040486:	46a9      	mov	r9, r5
10040488:	46a0      	mov	r8, r4
1004048a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1004048c:	4642      	mov	r2, r8
1004048e:	469b      	mov	fp, r3
10040490:	2320      	movs	r3, #32
10040492:	1a9b      	subs	r3, r3, r2
10040494:	4652      	mov	r2, sl
10040496:	40da      	lsrs	r2, r3
10040498:	4641      	mov	r1, r8
1004049a:	0013      	movs	r3, r2
1004049c:	464a      	mov	r2, r9
1004049e:	408a      	lsls	r2, r1
100404a0:	0017      	movs	r7, r2
100404a2:	4642      	mov	r2, r8
100404a4:	431f      	orrs	r7, r3
100404a6:	4653      	mov	r3, sl
100404a8:	4093      	lsls	r3, r2
100404aa:	001e      	movs	r6, r3
100404ac:	42af      	cmp	r7, r5
100404ae:	d9c3      	bls.n	10040438 <__udivmoddi4+0x4c>
100404b0:	2200      	movs	r2, #0
100404b2:	2300      	movs	r3, #0
100404b4:	9200      	str	r2, [sp, #0]
100404b6:	9301      	str	r3, [sp, #4]
100404b8:	4643      	mov	r3, r8
100404ba:	2b00      	cmp	r3, #0
100404bc:	d0d8      	beq.n	10040470 <__udivmoddi4+0x84>
100404be:	07fb      	lsls	r3, r7, #31
100404c0:	0872      	lsrs	r2, r6, #1
100404c2:	431a      	orrs	r2, r3
100404c4:	4646      	mov	r6, r8
100404c6:	087b      	lsrs	r3, r7, #1
100404c8:	e00e      	b.n	100404e8 <__udivmoddi4+0xfc>
100404ca:	42ab      	cmp	r3, r5
100404cc:	d101      	bne.n	100404d2 <__udivmoddi4+0xe6>
100404ce:	42a2      	cmp	r2, r4
100404d0:	d80c      	bhi.n	100404ec <__udivmoddi4+0x100>
100404d2:	1aa4      	subs	r4, r4, r2
100404d4:	419d      	sbcs	r5, r3
100404d6:	2001      	movs	r0, #1
100404d8:	1924      	adds	r4, r4, r4
100404da:	416d      	adcs	r5, r5
100404dc:	2100      	movs	r1, #0
100404de:	3e01      	subs	r6, #1
100404e0:	1824      	adds	r4, r4, r0
100404e2:	414d      	adcs	r5, r1
100404e4:	2e00      	cmp	r6, #0
100404e6:	d006      	beq.n	100404f6 <__udivmoddi4+0x10a>
100404e8:	42ab      	cmp	r3, r5
100404ea:	d9ee      	bls.n	100404ca <__udivmoddi4+0xde>
100404ec:	3e01      	subs	r6, #1
100404ee:	1924      	adds	r4, r4, r4
100404f0:	416d      	adcs	r5, r5
100404f2:	2e00      	cmp	r6, #0
100404f4:	d1f8      	bne.n	100404e8 <__udivmoddi4+0xfc>
100404f6:	9800      	ldr	r0, [sp, #0]
100404f8:	9901      	ldr	r1, [sp, #4]
100404fa:	465b      	mov	r3, fp
100404fc:	1900      	adds	r0, r0, r4
100404fe:	4169      	adcs	r1, r5
10040500:	2b00      	cmp	r3, #0
10040502:	db24      	blt.n	1004054e <__udivmoddi4+0x162>
10040504:	002b      	movs	r3, r5
10040506:	465a      	mov	r2, fp
10040508:	4644      	mov	r4, r8
1004050a:	40d3      	lsrs	r3, r2
1004050c:	002a      	movs	r2, r5
1004050e:	40e2      	lsrs	r2, r4
10040510:	001c      	movs	r4, r3
10040512:	465b      	mov	r3, fp
10040514:	0015      	movs	r5, r2
10040516:	2b00      	cmp	r3, #0
10040518:	db2a      	blt.n	10040570 <__udivmoddi4+0x184>
1004051a:	0026      	movs	r6, r4
1004051c:	409e      	lsls	r6, r3
1004051e:	0033      	movs	r3, r6
10040520:	0026      	movs	r6, r4
10040522:	4647      	mov	r7, r8
10040524:	40be      	lsls	r6, r7
10040526:	0032      	movs	r2, r6
10040528:	1a80      	subs	r0, r0, r2
1004052a:	4199      	sbcs	r1, r3
1004052c:	9000      	str	r0, [sp, #0]
1004052e:	9101      	str	r1, [sp, #4]
10040530:	e79e      	b.n	10040470 <__udivmoddi4+0x84>
10040532:	42a3      	cmp	r3, r4
10040534:	d8bc      	bhi.n	100404b0 <__udivmoddi4+0xc4>
10040536:	e782      	b.n	1004043e <__udivmoddi4+0x52>
10040538:	4642      	mov	r2, r8
1004053a:	2320      	movs	r3, #32
1004053c:	2100      	movs	r1, #0
1004053e:	1a9b      	subs	r3, r3, r2
10040540:	2200      	movs	r2, #0
10040542:	9100      	str	r1, [sp, #0]
10040544:	9201      	str	r2, [sp, #4]
10040546:	2201      	movs	r2, #1
10040548:	40da      	lsrs	r2, r3
1004054a:	9201      	str	r2, [sp, #4]
1004054c:	e785      	b.n	1004045a <__udivmoddi4+0x6e>
1004054e:	4642      	mov	r2, r8
10040550:	2320      	movs	r3, #32
10040552:	1a9b      	subs	r3, r3, r2
10040554:	002a      	movs	r2, r5
10040556:	4646      	mov	r6, r8
10040558:	409a      	lsls	r2, r3
1004055a:	0023      	movs	r3, r4
1004055c:	40f3      	lsrs	r3, r6
1004055e:	4644      	mov	r4, r8
10040560:	4313      	orrs	r3, r2
10040562:	002a      	movs	r2, r5
10040564:	40e2      	lsrs	r2, r4
10040566:	001c      	movs	r4, r3
10040568:	465b      	mov	r3, fp
1004056a:	0015      	movs	r5, r2
1004056c:	2b00      	cmp	r3, #0
1004056e:	dad4      	bge.n	1004051a <__udivmoddi4+0x12e>
10040570:	4642      	mov	r2, r8
10040572:	002f      	movs	r7, r5
10040574:	2320      	movs	r3, #32
10040576:	0026      	movs	r6, r4
10040578:	4097      	lsls	r7, r2
1004057a:	1a9b      	subs	r3, r3, r2
1004057c:	40de      	lsrs	r6, r3
1004057e:	003b      	movs	r3, r7
10040580:	4333      	orrs	r3, r6
10040582:	e7cd      	b.n	10040520 <__udivmoddi4+0x134>

10040584 <__clzdi2>:
10040584:	b510      	push	{r4, lr}
10040586:	2900      	cmp	r1, #0
10040588:	d103      	bne.n	10040592 <__clzdi2+0xe>
1004058a:	f000 f807 	bl	1004059c <__clzsi2>
1004058e:	3020      	adds	r0, #32
10040590:	e002      	b.n	10040598 <__clzdi2+0x14>
10040592:	0008      	movs	r0, r1
10040594:	f000 f802 	bl	1004059c <__clzsi2>
10040598:	bd10      	pop	{r4, pc}
1004059a:	46c0      	nop			@ (mov r8, r8)

1004059c <__clzsi2>:
1004059c:	211c      	movs	r1, #28
1004059e:	2301      	movs	r3, #1
100405a0:	041b      	lsls	r3, r3, #16
100405a2:	4298      	cmp	r0, r3
100405a4:	d301      	bcc.n	100405aa <__clzsi2+0xe>
100405a6:	0c00      	lsrs	r0, r0, #16
100405a8:	3910      	subs	r1, #16
100405aa:	0a1b      	lsrs	r3, r3, #8
100405ac:	4298      	cmp	r0, r3
100405ae:	d301      	bcc.n	100405b4 <__clzsi2+0x18>
100405b0:	0a00      	lsrs	r0, r0, #8
100405b2:	3908      	subs	r1, #8
100405b4:	091b      	lsrs	r3, r3, #4
100405b6:	4298      	cmp	r0, r3
100405b8:	d301      	bcc.n	100405be <__clzsi2+0x22>
100405ba:	0900      	lsrs	r0, r0, #4
100405bc:	3904      	subs	r1, #4
100405be:	a202      	add	r2, pc, #8	@ (adr r2, 100405c8 <__clzsi2+0x2c>)
100405c0:	5c10      	ldrb	r0, [r2, r0]
100405c2:	1840      	adds	r0, r0, r1
100405c4:	4770      	bx	lr
100405c6:	46c0      	nop			@ (mov r8, r8)
100405c8:	02020304 	.word	0x02020304
100405cc:	01010101 	.word	0x01010101
	...

100405d8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
int SystemClock_Config(void)
{
100405d8:	b580      	push	{r7, lr}
100405da:	b082      	sub	sp, #8
100405dc:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
100405de:	003b      	movs	r3, r7
100405e0:	0018      	movs	r0, r3
100405e2:	2308      	movs	r3, #8
100405e4:	001a      	movs	r2, r3
100405e6:	2100      	movs	r1, #0
100405e8:	f001 ff84 	bl	100424f4 <memset>

  /** Configure the SYSCLKSource and SYSCLKDivider
  */
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
100405ec:	003b      	movs	r3, r7
100405ee:	2202      	movs	r2, #2
100405f0:	601a      	str	r2, [r3, #0]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_RC64MPLL_DIV1;
100405f2:	003b      	movs	r3, r7
100405f4:	2200      	movs	r2, #0
100405f6:	605a      	str	r2, [r3, #4]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_WAIT_STATES_1) != HAL_OK)
100405f8:	003b      	movs	r3, r7
100405fa:	2110      	movs	r1, #16
100405fc:	0018      	movs	r0, r3
100405fe:	f001 f839 	bl	10041674 <HAL_RCC_ClockConfig>
10040602:	1e03      	subs	r3, r0, #0
10040604:	d001      	beq.n	1004060a <SystemClock_Config+0x32>
  {
	  return INIT_ERROR;
10040606:	2300      	movs	r3, #0
10040608:	e000      	b.n	1004060c <SystemClock_Config+0x34>
  }
  return INIT_OK;
1004060a:	2301      	movs	r3, #1
}
1004060c:	0018      	movs	r0, r3
1004060e:	46bd      	mov	sp, r7
10040610:	b002      	add	sp, #8
10040612:	bd80      	pop	{r7, pc}

10040614 <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
int PeriphCommonClock_Config(void)
{
10040614:	b580      	push	{r7, lr}
10040616:	b086      	sub	sp, #24
10040618:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
1004061a:	003b      	movs	r3, r7
1004061c:	0018      	movs	r0, r3
1004061e:	2318      	movs	r3, #24
10040620:	001a      	movs	r2, r3
10040622:	2100      	movs	r1, #0
10040624:	f001 ff66 	bl	100424f4 <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS;
10040628:	003b      	movs	r3, r7
1004062a:	2202      	movs	r2, #2
1004062c:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLK_DIV4;
1004062e:	003b      	movs	r3, r7
10040630:	2280      	movs	r2, #128	@ 0x80
10040632:	0152      	lsls	r2, r2, #5
10040634:	615a      	str	r2, [r3, #20]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
10040636:	003b      	movs	r3, r7
10040638:	0018      	movs	r0, r3
1004063a:	f001 f9b1 	bl	100419a0 <HAL_RCCEx_PeriphCLKConfig>
1004063e:	1e03      	subs	r3, r0, #0
10040640:	d001      	beq.n	10040646 <PeriphCommonClock_Config+0x32>
  {
	  return INIT_ERROR;
10040642:	2300      	movs	r3, #0
10040644:	e000      	b.n	10040648 <PeriphCommonClock_Config+0x34>
  }
  return INIT_OK;
10040646:	2301      	movs	r3, #1
}
10040648:	0018      	movs	r0, r3
1004064a:	46bd      	mov	sp, r7
1004064c:	b006      	add	sp, #24
1004064e:	bd80      	pop	{r7, pc}

10040650 <BOARD_Init>:


//Initializes the board
int BOARD_Init(void){
10040650:	b580      	push	{r7, lr}
10040652:	b082      	sub	sp, #8
10040654:	af00      	add	r7, sp, #0
	int errorFlag = INIT_OK;
10040656:	2301      	movs	r3, #1
10040658:	607b      	str	r3, [r7, #4]
	if(PeriphCommonClock_Config() == INIT_ERROR){
1004065a:	f7ff ffdb 	bl	10040614 <PeriphCommonClock_Config>
1004065e:	1e03      	subs	r3, r0, #0
10040660:	d101      	bne.n	10040666 <BOARD_Init+0x16>
		errorFlag = INIT_ERROR;
10040662:	2300      	movs	r3, #0
10040664:	607b      	str	r3, [r7, #4]
	}
	if(SystemClock_Config() == INIT_ERROR){
10040666:	f7ff ffb7 	bl	100405d8 <SystemClock_Config>
1004066a:	1e03      	subs	r3, r0, #0
1004066c:	d101      	bne.n	10040672 <BOARD_Init+0x22>
		errorFlag = INIT_ERROR;
1004066e:	2300      	movs	r3, #0
10040670:	607b      	str	r3, [r7, #4]
	}
	return errorFlag;
10040672:	687b      	ldr	r3, [r7, #4]
}
10040674:	0018      	movs	r0, r3
10040676:	46bd      	mov	sp, r7
10040678:	b002      	add	sp, #8
1004067a:	bd80      	pop	{r7, pc}

1004067c <BOARD_CrashHandler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void BOARD_CrashHandler(void)
{
1004067c:	b580      	push	{r7, lr}
1004067e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10040680:	b672      	cpsid	i
}
10040682:	46c0      	nop			@ (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
10040684:	46c0      	nop			@ (mov r8, r8)
10040686:	e7fd      	b.n	10040684 <BOARD_CrashHandler+0x8>

10040688 <LL_LPUART_IsActiveFlag_TXE_TXFNF>:
  * @rmtoll ISR          TXE_TXFNF     LL_LPUART_IsActiveFlag_TXE_TXFNF
  * @param  LPUARTx LPUART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_LPUART_IsActiveFlag_TXE_TXFNF(const USART_TypeDef *LPUARTx)
{
10040688:	b580      	push	{r7, lr}
1004068a:	b082      	sub	sp, #8
1004068c:	af00      	add	r7, sp, #0
1004068e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(LPUARTx->ISR, USART_ISR_TXE_TXFNF) == (USART_ISR_TXE_TXFNF)) ? 1UL : 0UL);
10040690:	687b      	ldr	r3, [r7, #4]
10040692:	69db      	ldr	r3, [r3, #28]
10040694:	2280      	movs	r2, #128	@ 0x80
10040696:	4013      	ands	r3, r2
10040698:	2b80      	cmp	r3, #128	@ 0x80
1004069a:	d101      	bne.n	100406a0 <LL_LPUART_IsActiveFlag_TXE_TXFNF+0x18>
1004069c:	2301      	movs	r3, #1
1004069e:	e000      	b.n	100406a2 <LL_LPUART_IsActiveFlag_TXE_TXFNF+0x1a>
100406a0:	2300      	movs	r3, #0
}
100406a2:	0018      	movs	r0, r3
100406a4:	46bd      	mov	sp, r7
100406a6:	b002      	add	sp, #8
100406a8:	bd80      	pop	{r7, pc}
	...

100406ac <MX_LPUART1_UART_Init>:
  * @brief LPUART1 Initialization Function
  * @param None
  * @retval None
  */
static int MX_LPUART1_UART_Init(void)
{
100406ac:	b580      	push	{r7, lr}
100406ae:	af00      	add	r7, sp, #0
  /* USER CODE END LPUART1_Init 0 */

  /* USER CODE BEGIN LPUART1_Init 1 */

  /* USER CODE END LPUART1_Init 1 */
  hlpuart1.Instance = LPUART1;
100406b0:	4b1e      	ldr	r3, [pc, #120]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406b2:	4a1f      	ldr	r2, [pc, #124]	@ (10040730 <MX_LPUART1_UART_Init+0x84>)
100406b4:	601a      	str	r2, [r3, #0]
  hlpuart1.Init.BaudRate = 9600;
100406b6:	4b1d      	ldr	r3, [pc, #116]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406b8:	2296      	movs	r2, #150	@ 0x96
100406ba:	0192      	lsls	r2, r2, #6
100406bc:	605a      	str	r2, [r3, #4]
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
100406be:	4b1b      	ldr	r3, [pc, #108]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406c0:	2200      	movs	r2, #0
100406c2:	609a      	str	r2, [r3, #8]
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
100406c4:	4b19      	ldr	r3, [pc, #100]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406c6:	2200      	movs	r2, #0
100406c8:	60da      	str	r2, [r3, #12]
  hlpuart1.Init.Parity = UART_PARITY_NONE;
100406ca:	4b18      	ldr	r3, [pc, #96]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406cc:	2200      	movs	r2, #0
100406ce:	611a      	str	r2, [r3, #16]
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
100406d0:	4b16      	ldr	r3, [pc, #88]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406d2:	220c      	movs	r2, #12
100406d4:	615a      	str	r2, [r3, #20]
  hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
100406d6:	4b15      	ldr	r3, [pc, #84]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406d8:	2200      	movs	r2, #0
100406da:	619a      	str	r2, [r3, #24]
  hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
100406dc:	4b13      	ldr	r3, [pc, #76]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406de:	2200      	movs	r2, #0
100406e0:	621a      	str	r2, [r3, #32]
  hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
100406e2:	4b12      	ldr	r3, [pc, #72]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406e4:	2200      	movs	r2, #0
100406e6:	625a      	str	r2, [r3, #36]	@ 0x24
  hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
100406e8:	4b10      	ldr	r3, [pc, #64]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406ea:	2200      	movs	r2, #0
100406ec:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
100406ee:	4b0f      	ldr	r3, [pc, #60]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
100406f0:	0018      	movs	r0, r3
100406f2:	f001 fa2d 	bl	10041b50 <HAL_UART_Init>
100406f6:	1e03      	subs	r3, r0, #0
100406f8:	d001      	beq.n	100406fe <MX_LPUART1_UART_Init+0x52>
  {
    return INIT_ERROR;
100406fa:	2300      	movs	r3, #0
100406fc:	e012      	b.n	10040724 <MX_LPUART1_UART_Init+0x78>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
100406fe:	4b0b      	ldr	r3, [pc, #44]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
10040700:	2100      	movs	r1, #0
10040702:	0018      	movs	r0, r3
10040704:	f001 fe16 	bl	10042334 <HAL_UARTEx_SetTxFifoThreshold>
10040708:	1e03      	subs	r3, r0, #0
1004070a:	d001      	beq.n	10040710 <MX_LPUART1_UART_Init+0x64>
  {
	  return INIT_ERROR;
1004070c:	2300      	movs	r3, #0
1004070e:	e009      	b.n	10040724 <MX_LPUART1_UART_Init+0x78>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
10040710:	4b06      	ldr	r3, [pc, #24]	@ (1004072c <MX_LPUART1_UART_Init+0x80>)
10040712:	2100      	movs	r1, #0
10040714:	0018      	movs	r0, r3
10040716:	f001 fe4d 	bl	100423b4 <HAL_UARTEx_SetRxFifoThreshold>
1004071a:	1e03      	subs	r3, r0, #0
1004071c:	d001      	beq.n	10040722 <MX_LPUART1_UART_Init+0x76>
  {
	  return INIT_ERROR;
1004071e:	2300      	movs	r3, #0
10040720:	e000      	b.n	10040724 <MX_LPUART1_UART_Init+0x78>
  }
  return INIT_OK;
10040722:	2301      	movs	r3, #1

}
10040724:	0018      	movs	r0, r3
10040726:	46bd      	mov	sp, r7
10040728:	bd80      	pop	{r7, pc}
1004072a:	46c0      	nop			@ (mov r8, r8)
1004072c:	200000c0 	.word	0x200000c0
10040730:	41005000 	.word	0x41005000

10040734 <UART_Init>:

int UART_Init(void){
10040734:	b580      	push	{r7, lr}
10040736:	af00      	add	r7, sp, #0
	return MX_LPUART1_UART_Init();
10040738:	f7ff ffb8 	bl	100406ac <MX_LPUART1_UART_Init>
1004073c:	0003      	movs	r3, r0
}
1004073e:	0018      	movs	r0, r3
10040740:	46bd      	mov	sp, r7
10040742:	bd80      	pop	{r7, pc}

10040744 <UART_WriteTx>:
		return 0;
	}

}

void UART_WriteTx(char input){
10040744:	b580      	push	{r7, lr}
10040746:	b082      	sub	sp, #8
10040748:	af00      	add	r7, sp, #0
1004074a:	0002      	movs	r2, r0
1004074c:	1dfb      	adds	r3, r7, #7
1004074e:	701a      	strb	r2, [r3, #0]
	if (LL_LPUART_IsActiveFlag_TXE_TXFNF(LPUART1)){
10040750:	4b06      	ldr	r3, [pc, #24]	@ (1004076c <UART_WriteTx+0x28>)
10040752:	0018      	movs	r0, r3
10040754:	f7ff ff98 	bl	10040688 <LL_LPUART_IsActiveFlag_TXE_TXFNF>
10040758:	1e03      	subs	r3, r0, #0
1004075a:	d003      	beq.n	10040764 <UART_WriteTx+0x20>
		LL_LPUART_WriteReg(LPUART1, TDR, input);
1004075c:	4b03      	ldr	r3, [pc, #12]	@ (1004076c <UART_WriteTx+0x28>)
1004075e:	1dfa      	adds	r2, r7, #7
10040760:	7812      	ldrb	r2, [r2, #0]
10040762:	629a      	str	r2, [r3, #40]	@ 0x28
	}
}
10040764:	46c0      	nop			@ (mov r8, r8)
10040766:	46bd      	mov	sp, r7
10040768:	b002      	add	sp, #8
1004076a:	bd80      	pop	{r7, pc}
1004076c:	41005000 	.word	0x41005000

10040770 <main>:
#ifdef UARTTESTHARNESS
#include "BOARD.h"
#include "stm32wb0x_nucleo.h"


int main(){
10040770:	b580      	push	{r7, lr}
10040772:	b082      	sub	sp, #8
10040774:	af00      	add	r7, sp, #0
	HAL_Init();
10040776:	f000 fb95 	bl	10040ea4 <HAL_Init>
	BOARD_Init();
1004077a:	f7ff ff69 	bl	10040650 <BOARD_Init>
	BSP_LED_Init(LED_BLUE);
1004077e:	2000      	movs	r0, #0
10040780:	f000 fafe 	bl	10040d80 <BSP_LED_Init>
	UART_Init();
10040784:	f7ff ffd6 	bl	10040734 <UART_Init>
	while (1){
		char Rx = 'H';
10040788:	1dfb      	adds	r3, r7, #7
1004078a:	2248      	movs	r2, #72	@ 0x48
1004078c:	701a      	strb	r2, [r3, #0]
		if(Rx){
1004078e:	1dfb      	adds	r3, r7, #7
10040790:	781b      	ldrb	r3, [r3, #0]
10040792:	2b00      	cmp	r3, #0
10040794:	d004      	beq.n	100407a0 <main+0x30>
			UART_WriteTx(Rx);
10040796:	1dfb      	adds	r3, r7, #7
10040798:	781b      	ldrb	r3, [r3, #0]
1004079a:	0018      	movs	r0, r3
1004079c:	f7ff ffd2 	bl	10040744 <UART_WriteTx>
		}

	    BSP_LED_Toggle(LED_BLUE);
100407a0:	2000      	movs	r0, #0
100407a2:	f000 fb63 	bl	10040e6c <BSP_LED_Toggle>

		HAL_Delay(500);
100407a6:	23fa      	movs	r3, #250	@ 0xfa
100407a8:	005b      	lsls	r3, r3, #1
100407aa:	0018      	movs	r0, r3
100407ac:	f000 fc00 	bl	10040fb0 <HAL_Delay>
	while (1){
100407b0:	e7ea      	b.n	10040788 <main+0x18>
	...

100407b4 <LL_PWR_SetNoPullB>:
  *         @arg @ref LL_PWR_GPIO_BIT_15
  *         (*) available only oon STM32WB06 and STM32WB07 devices
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetNoPullB(uint32_t GPIONumber)
{
100407b4:	b580      	push	{r7, lr}
100407b6:	b082      	sub	sp, #8
100407b8:	af00      	add	r7, sp, #0
100407ba:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRB, GPIONumber);
100407bc:	4b08      	ldr	r3, [pc, #32]	@ (100407e0 <LL_PWR_SetNoPullB+0x2c>)
100407be:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
100407c0:	687b      	ldr	r3, [r7, #4]
100407c2:	43d9      	mvns	r1, r3
100407c4:	4b06      	ldr	r3, [pc, #24]	@ (100407e0 <LL_PWR_SetNoPullB+0x2c>)
100407c6:	400a      	ands	r2, r1
100407c8:	629a      	str	r2, [r3, #40]	@ 0x28
  CLEAR_BIT(PWR->PDCRB, GPIONumber);
100407ca:	4b05      	ldr	r3, [pc, #20]	@ (100407e0 <LL_PWR_SetNoPullB+0x2c>)
100407cc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
100407ce:	687b      	ldr	r3, [r7, #4]
100407d0:	43d9      	mvns	r1, r3
100407d2:	4b03      	ldr	r3, [pc, #12]	@ (100407e0 <LL_PWR_SetNoPullB+0x2c>)
100407d4:	400a      	ands	r2, r1
100407d6:	62da      	str	r2, [r3, #44]	@ 0x2c
}
100407d8:	46c0      	nop			@ (mov r8, r8)
100407da:	46bd      	mov	sp, r7
100407dc:	b002      	add	sp, #8
100407de:	bd80      	pop	{r7, pc}
100407e0:	48500000 	.word	0x48500000

100407e4 <LL_AHB1_GRP1_EnableClock>:
  * @arg LL_AHB1_GRP1_PERIPH_RNG
  * @retval None
  * @note   LL_AHB1_GRP1_PERIPH_PKA
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
100407e4:	b580      	push	{r7, lr}
100407e6:	b084      	sub	sp, #16
100407e8:	af00      	add	r7, sp, #0
100407ea:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
100407ec:	4b07      	ldr	r3, [pc, #28]	@ (1004080c <LL_AHB1_GRP1_EnableClock+0x28>)
100407ee:	6d19      	ldr	r1, [r3, #80]	@ 0x50
100407f0:	4b06      	ldr	r3, [pc, #24]	@ (1004080c <LL_AHB1_GRP1_EnableClock+0x28>)
100407f2:	687a      	ldr	r2, [r7, #4]
100407f4:	430a      	orrs	r2, r1
100407f6:	651a      	str	r2, [r3, #80]	@ 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
100407f8:	4b04      	ldr	r3, [pc, #16]	@ (1004080c <LL_AHB1_GRP1_EnableClock+0x28>)
100407fa:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
100407fc:	687a      	ldr	r2, [r7, #4]
100407fe:	4013      	ands	r3, r2
10040800:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040802:	68fb      	ldr	r3, [r7, #12]
}
10040804:	46c0      	nop			@ (mov r8, r8)
10040806:	46bd      	mov	sp, r7
10040808:	b004      	add	sp, #16
1004080a:	bd80      	pop	{r7, pc}
1004080c:	48400000 	.word	0x48400000

10040810 <LL_APB0_GRP1_EnableClock>:
  * @retval None
  * @note   LL_APB0_GRP1_PERIPH_TIM1 is valid only for STM32WB06 and STM32WB07
  * @note   LL_APB0_GRP1_PERIPH_TIM2, LL_APB0_GRP1_PERIPH_TIM16 and LL_APB0_GRP1_PERIPH_TIM17 are valid for STM32WB05 and STM32WB09
  */
__STATIC_INLINE void LL_APB0_GRP1_EnableClock(uint32_t Periphs)
{
10040810:	b580      	push	{r7, lr}
10040812:	b084      	sub	sp, #16
10040814:	af00      	add	r7, sp, #0
10040816:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB0ENR, Periphs);
10040818:	4b07      	ldr	r3, [pc, #28]	@ (10040838 <LL_APB0_GRP1_EnableClock+0x28>)
1004081a:	6d59      	ldr	r1, [r3, #84]	@ 0x54
1004081c:	4b06      	ldr	r3, [pc, #24]	@ (10040838 <LL_APB0_GRP1_EnableClock+0x28>)
1004081e:	687a      	ldr	r2, [r7, #4]
10040820:	430a      	orrs	r2, r1
10040822:	655a      	str	r2, [r3, #84]	@ 0x54
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040824:	4b04      	ldr	r3, [pc, #16]	@ (10040838 <LL_APB0_GRP1_EnableClock+0x28>)
10040826:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
10040828:	687a      	ldr	r2, [r7, #4]
1004082a:	4013      	ands	r3, r2
1004082c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
1004082e:	68fb      	ldr	r3, [r7, #12]
}
10040830:	46c0      	nop			@ (mov r8, r8)
10040832:	46bd      	mov	sp, r7
10040834:	b004      	add	sp, #16
10040836:	bd80      	pop	{r7, pc}
10040838:	48400000 	.word	0x48400000

1004083c <LL_APB1_GRP1_EnableClock>:
  * @arg LL_APB1_GRP1_PERIPH_I2C2
  * @retval None
  * @note   LL_APB1_GRP1_PERIPH_SPI1, LL_APB1_GRP1_PERIPH_SPI2 and LL_APB1_GRP1_PERIPH_I2C2 are valid for STM32WB06 and STM32WB07
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
1004083c:	b580      	push	{r7, lr}
1004083e:	b084      	sub	sp, #16
10040840:	af00      	add	r7, sp, #0
10040842:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
10040844:	4b07      	ldr	r3, [pc, #28]	@ (10040864 <LL_APB1_GRP1_EnableClock+0x28>)
10040846:	6d99      	ldr	r1, [r3, #88]	@ 0x58
10040848:	4b06      	ldr	r3, [pc, #24]	@ (10040864 <LL_APB1_GRP1_EnableClock+0x28>)
1004084a:	687a      	ldr	r2, [r7, #4]
1004084c:	430a      	orrs	r2, r1
1004084e:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
10040850:	4b04      	ldr	r3, [pc, #16]	@ (10040864 <LL_APB1_GRP1_EnableClock+0x28>)
10040852:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
10040854:	687a      	ldr	r2, [r7, #4]
10040856:	4013      	ands	r3, r2
10040858:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
1004085a:	68fb      	ldr	r3, [r7, #12]
}
1004085c:	46c0      	nop			@ (mov r8, r8)
1004085e:	46bd      	mov	sp, r7
10040860:	b004      	add	sp, #16
10040862:	bd80      	pop	{r7, pc}
10040864:	48400000 	.word	0x48400000

10040868 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
10040868:	b580      	push	{r7, lr}
1004086a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */
//
  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
1004086c:	2380      	movs	r3, #128	@ 0x80
1004086e:	005b      	lsls	r3, r3, #1
10040870:	0018      	movs	r0, r3
10040872:	f7ff ffcd 	bl	10040810 <LL_APB0_GRP1_EnableClock>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */
//
  /* USER CODE END MspInit 1 */
}
10040876:	46c0      	nop			@ (mov r8, r8)
10040878:	46bd      	mov	sp, r7
1004087a:	bd80      	pop	{r7, pc}

1004087c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
1004087c:	b590      	push	{r4, r7, lr}
1004087e:	b08f      	sub	sp, #60	@ 0x3c
10040880:	af00      	add	r7, sp, #0
10040882:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
10040884:	2324      	movs	r3, #36	@ 0x24
10040886:	18fb      	adds	r3, r7, r3
10040888:	0018      	movs	r0, r3
1004088a:	2314      	movs	r3, #20
1004088c:	001a      	movs	r2, r3
1004088e:	2100      	movs	r1, #0
10040890:	f001 fe30 	bl	100424f4 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
10040894:	240c      	movs	r4, #12
10040896:	193b      	adds	r3, r7, r4
10040898:	0018      	movs	r0, r3
1004089a:	2318      	movs	r3, #24
1004089c:	001a      	movs	r2, r3
1004089e:	2100      	movs	r1, #0
100408a0:	f001 fe28 	bl	100424f4 <memset>
  if(huart->Instance==LPUART1)
100408a4:	687b      	ldr	r3, [r7, #4]
100408a6:	681b      	ldr	r3, [r3, #0]
100408a8:	4a25      	ldr	r2, [pc, #148]	@ (10040940 <HAL_UART_MspInit+0xc4>)
100408aa:	4293      	cmp	r3, r2
100408ac:	d144      	bne.n	10040938 <HAL_UART_MspInit+0xbc>
//
  /* USER CODE END LPUART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
100408ae:	193b      	adds	r3, r7, r4
100408b0:	2210      	movs	r2, #16
100408b2:	601a      	str	r2, [r3, #0]
    PeriphClkInitStruct.LPUART1ClockSelection = RCC_LPUART1_CLKSOURCE_16M;
100408b4:	193b      	adds	r3, r7, r4
100408b6:	2200      	movs	r2, #0
100408b8:	60da      	str	r2, [r3, #12]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
100408ba:	193b      	adds	r3, r7, r4
100408bc:	0018      	movs	r0, r3
100408be:	f001 f86f 	bl	100419a0 <HAL_RCCEx_PeriphCLKConfig>
100408c2:	1e03      	subs	r3, r0, #0
100408c4:	d001      	beq.n	100408ca <HAL_UART_MspInit+0x4e>
    {
      BOARD_CrashHandler();
100408c6:	f7ff fed9 	bl	1004067c <BOARD_CrashHandler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_LPUART1_CLK_ENABLE();
100408ca:	2380      	movs	r3, #128	@ 0x80
100408cc:	005b      	lsls	r3, r3, #1
100408ce:	0018      	movs	r0, r3
100408d0:	f7ff ffb4 	bl	1004083c <LL_APB1_GRP1_EnableClock>

    __HAL_RCC_GPIOB_CLK_ENABLE();
100408d4:	2008      	movs	r0, #8
100408d6:	f7ff ff85 	bl	100407e4 <LL_AHB1_GRP1_EnableClock>
    /**LPUART1 GPIO Configuration
    PB3     ------> LPUART1_TX
    PB7     ------> LPUART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3;
100408da:	2424      	movs	r4, #36	@ 0x24
100408dc:	193b      	adds	r3, r7, r4
100408de:	2208      	movs	r2, #8
100408e0:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
100408e2:	193b      	adds	r3, r7, r4
100408e4:	2202      	movs	r2, #2
100408e6:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
100408e8:	193b      	adds	r3, r7, r4
100408ea:	2200      	movs	r2, #0
100408ec:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
100408ee:	193b      	adds	r3, r7, r4
100408f0:	2200      	movs	r2, #0
100408f2:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF1_LPUART1;
100408f4:	193b      	adds	r3, r7, r4
100408f6:	2201      	movs	r2, #1
100408f8:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
100408fa:	193b      	adds	r3, r7, r4
100408fc:	4a11      	ldr	r2, [pc, #68]	@ (10040944 <HAL_UART_MspInit+0xc8>)
100408fe:	0019      	movs	r1, r3
10040900:	0010      	movs	r0, r2
10040902:	f000 fc2d 	bl	10041160 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
10040906:	0021      	movs	r1, r4
10040908:	187b      	adds	r3, r7, r1
1004090a:	2280      	movs	r2, #128	@ 0x80
1004090c:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
1004090e:	187b      	adds	r3, r7, r1
10040910:	2202      	movs	r2, #2
10040912:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
10040914:	187b      	adds	r3, r7, r1
10040916:	2200      	movs	r2, #0
10040918:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
1004091a:	187b      	adds	r3, r7, r1
1004091c:	2200      	movs	r2, #0
1004091e:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF3_LPUART1;
10040920:	187b      	adds	r3, r7, r1
10040922:	2203      	movs	r2, #3
10040924:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
10040926:	187b      	adds	r3, r7, r1
10040928:	4a06      	ldr	r2, [pc, #24]	@ (10040944 <HAL_UART_MspInit+0xc8>)
1004092a:	0019      	movs	r1, r3
1004092c:	0010      	movs	r0, r2
1004092e:	f000 fc17 	bl	10041160 <HAL_GPIO_Init>

    LL_PWR_SetNoPullB(LL_PWR_GPIO_BIT_3|LL_PWR_GPIO_BIT_7);
10040932:	2088      	movs	r0, #136	@ 0x88
10040934:	f7ff ff3e 	bl	100407b4 <LL_PWR_SetNoPullB>
//
  /* USER CODE END LPUART1_MspInit 1 */

  }

}
10040938:	46c0      	nop			@ (mov r8, r8)
1004093a:	46bd      	mov	sp, r7
1004093c:	b00f      	add	sp, #60	@ 0x3c
1004093e:	bd90      	pop	{r4, r7, pc}
10040940:	41005000 	.word	0x41005000
10040944:	48100000 	.word	0x48100000

10040948 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
10040948:	b580      	push	{r7, lr}
1004094a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
1004094c:	46c0      	nop			@ (mov r8, r8)
1004094e:	e7fd      	b.n	1004094c <NMI_Handler+0x4>

10040950 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
10040950:	b580      	push	{r7, lr}
10040952:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
10040954:	46c0      	nop			@ (mov r8, r8)
10040956:	e7fd      	b.n	10040954 <HardFault_Handler+0x4>

10040958 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
10040958:	b580      	push	{r7, lr}
1004095a:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
1004095c:	46c0      	nop			@ (mov r8, r8)
1004095e:	46bd      	mov	sp, r7
10040960:	bd80      	pop	{r7, pc}

10040962 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
10040962:	b580      	push	{r7, lr}
10040964:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
10040966:	46c0      	nop			@ (mov r8, r8)
10040968:	46bd      	mov	sp, r7
1004096a:	bd80      	pop	{r7, pc}

1004096c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
1004096c:	b580      	push	{r7, lr}
1004096e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
10040970:	f000 faf8 	bl	10040f64 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
10040974:	46c0      	nop			@ (mov r8, r8)
10040976:	46bd      	mov	sp, r7
10040978:	bd80      	pop	{r7, pc}
	...

1004097c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
1004097c:	b590      	push	{r4, r7, lr}
1004097e:	b083      	sub	sp, #12
10040980:	af00      	add	r7, sp, #0
10040982:	0002      	movs	r2, r0
10040984:	6039      	str	r1, [r7, #0]
10040986:	1dfb      	adds	r3, r7, #7
10040988:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
1004098a:	1dfb      	adds	r3, r7, #7
1004098c:	781b      	ldrb	r3, [r3, #0]
1004098e:	2b7f      	cmp	r3, #127	@ 0x7f
10040990:	d828      	bhi.n	100409e4 <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040992:	4a2f      	ldr	r2, [pc, #188]	@ (10040a50 <__NVIC_SetPriority+0xd4>)
10040994:	1dfb      	adds	r3, r7, #7
10040996:	781b      	ldrb	r3, [r3, #0]
10040998:	b25b      	sxtb	r3, r3
1004099a:	089b      	lsrs	r3, r3, #2
1004099c:	33c0      	adds	r3, #192	@ 0xc0
1004099e:	009b      	lsls	r3, r3, #2
100409a0:	589b      	ldr	r3, [r3, r2]
100409a2:	1dfa      	adds	r2, r7, #7
100409a4:	7812      	ldrb	r2, [r2, #0]
100409a6:	0011      	movs	r1, r2
100409a8:	2203      	movs	r2, #3
100409aa:	400a      	ands	r2, r1
100409ac:	00d2      	lsls	r2, r2, #3
100409ae:	21ff      	movs	r1, #255	@ 0xff
100409b0:	4091      	lsls	r1, r2
100409b2:	000a      	movs	r2, r1
100409b4:	43d2      	mvns	r2, r2
100409b6:	401a      	ands	r2, r3
100409b8:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100409ba:	683b      	ldr	r3, [r7, #0]
100409bc:	019b      	lsls	r3, r3, #6
100409be:	22ff      	movs	r2, #255	@ 0xff
100409c0:	401a      	ands	r2, r3
100409c2:	1dfb      	adds	r3, r7, #7
100409c4:	781b      	ldrb	r3, [r3, #0]
100409c6:	0018      	movs	r0, r3
100409c8:	2303      	movs	r3, #3
100409ca:	4003      	ands	r3, r0
100409cc:	00db      	lsls	r3, r3, #3
100409ce:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100409d0:	481f      	ldr	r0, [pc, #124]	@ (10040a50 <__NVIC_SetPriority+0xd4>)
100409d2:	1dfb      	adds	r3, r7, #7
100409d4:	781b      	ldrb	r3, [r3, #0]
100409d6:	b25b      	sxtb	r3, r3
100409d8:	089b      	lsrs	r3, r3, #2
100409da:	430a      	orrs	r2, r1
100409dc:	33c0      	adds	r3, #192	@ 0xc0
100409de:	009b      	lsls	r3, r3, #2
100409e0:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
100409e2:	e031      	b.n	10040a48 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100409e4:	4a1b      	ldr	r2, [pc, #108]	@ (10040a54 <__NVIC_SetPriority+0xd8>)
100409e6:	1dfb      	adds	r3, r7, #7
100409e8:	781b      	ldrb	r3, [r3, #0]
100409ea:	0019      	movs	r1, r3
100409ec:	230f      	movs	r3, #15
100409ee:	400b      	ands	r3, r1
100409f0:	3b08      	subs	r3, #8
100409f2:	089b      	lsrs	r3, r3, #2
100409f4:	3306      	adds	r3, #6
100409f6:	009b      	lsls	r3, r3, #2
100409f8:	18d3      	adds	r3, r2, r3
100409fa:	3304      	adds	r3, #4
100409fc:	681b      	ldr	r3, [r3, #0]
100409fe:	1dfa      	adds	r2, r7, #7
10040a00:	7812      	ldrb	r2, [r2, #0]
10040a02:	0011      	movs	r1, r2
10040a04:	2203      	movs	r2, #3
10040a06:	400a      	ands	r2, r1
10040a08:	00d2      	lsls	r2, r2, #3
10040a0a:	21ff      	movs	r1, #255	@ 0xff
10040a0c:	4091      	lsls	r1, r2
10040a0e:	000a      	movs	r2, r1
10040a10:	43d2      	mvns	r2, r2
10040a12:	401a      	ands	r2, r3
10040a14:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10040a16:	683b      	ldr	r3, [r7, #0]
10040a18:	019b      	lsls	r3, r3, #6
10040a1a:	22ff      	movs	r2, #255	@ 0xff
10040a1c:	401a      	ands	r2, r3
10040a1e:	1dfb      	adds	r3, r7, #7
10040a20:	781b      	ldrb	r3, [r3, #0]
10040a22:	0018      	movs	r0, r3
10040a24:	2303      	movs	r3, #3
10040a26:	4003      	ands	r3, r0
10040a28:	00db      	lsls	r3, r3, #3
10040a2a:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10040a2c:	4809      	ldr	r0, [pc, #36]	@ (10040a54 <__NVIC_SetPriority+0xd8>)
10040a2e:	1dfb      	adds	r3, r7, #7
10040a30:	781b      	ldrb	r3, [r3, #0]
10040a32:	001c      	movs	r4, r3
10040a34:	230f      	movs	r3, #15
10040a36:	4023      	ands	r3, r4
10040a38:	3b08      	subs	r3, #8
10040a3a:	089b      	lsrs	r3, r3, #2
10040a3c:	430a      	orrs	r2, r1
10040a3e:	3306      	adds	r3, #6
10040a40:	009b      	lsls	r3, r3, #2
10040a42:	18c3      	adds	r3, r0, r3
10040a44:	3304      	adds	r3, #4
10040a46:	601a      	str	r2, [r3, #0]
}
10040a48:	46c0      	nop			@ (mov r8, r8)
10040a4a:	46bd      	mov	sp, r7
10040a4c:	b003      	add	sp, #12
10040a4e:	bd90      	pop	{r4, r7, pc}
10040a50:	e000e100 	.word	0xe000e100
10040a54:	e000ed00 	.word	0xe000ed00

10040a58 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
10040a58:	b580      	push	{r7, lr}
10040a5a:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
10040a5c:	f3bf 8f4f 	dsb	sy
}
10040a60:	46c0      	nop			@ (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
10040a62:	4b04      	ldr	r3, [pc, #16]	@ (10040a74 <__NVIC_SystemReset+0x1c>)
10040a64:	4a04      	ldr	r2, [pc, #16]	@ (10040a78 <__NVIC_SystemReset+0x20>)
10040a66:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
10040a68:	f3bf 8f4f 	dsb	sy
}
10040a6c:	46c0      	nop			@ (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
10040a6e:	46c0      	nop			@ (mov r8, r8)
10040a70:	e7fd      	b.n	10040a6e <__NVIC_SystemReset+0x16>
10040a72:	46c0      	nop			@ (mov r8, r8)
10040a74:	e000ed00 	.word	0xe000ed00
10040a78:	05fa0004 	.word	0x05fa0004

10040a7c <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
10040a7c:	b590      	push	{r4, r7, lr}
10040a7e:	b087      	sub	sp, #28
10040a80:	af00      	add	r7, sp, #0
  uint32_t lsiBw;
#endif
  uint8_t i;
  
  /* If the reset reason is a wakeup from power save restore the context */
  if ((RCC->CSR == 0) && ((PWR->SR1 != 0)||(PWR->SR3 != 0))) {
10040a82:	4a5e      	ldr	r2, [pc, #376]	@ (10040bfc <SystemInit+0x180>)
10040a84:	2394      	movs	r3, #148	@ 0x94
10040a86:	58d3      	ldr	r3, [r2, r3]
10040a88:	2b00      	cmp	r3, #0
10040a8a:	d10e      	bne.n	10040aaa <SystemInit+0x2e>
10040a8c:	4b5c      	ldr	r3, [pc, #368]	@ (10040c00 <SystemInit+0x184>)
10040a8e:	691b      	ldr	r3, [r3, #16]
10040a90:	2b00      	cmp	r3, #0
10040a92:	d103      	bne.n	10040a9c <SystemInit+0x20>
10040a94:	4b5a      	ldr	r3, [pc, #360]	@ (10040c00 <SystemInit+0x184>)
10040a96:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
10040a98:	2b00      	cmp	r3, #0
10040a9a:	d006      	beq.n	10040aaa <SystemInit+0x2e>
    RAM_VR.WakeupFromSleepFlag = 1; /* A wakeup from power save occurred */
10040a9c:	4b59      	ldr	r3, [pc, #356]	@ (10040c04 <SystemInit+0x188>)
10040a9e:	2201      	movs	r2, #1
10040aa0:	609a      	str	r2, [r3, #8]
    CPUcontextRestore();            /* Restore the context */
10040aa2:	f000 f8f5 	bl	10040c90 <CPUcontextRestore>
    /* if the context restore worked properly, we should never return here */
    while(1) { 
      NVIC_SystemReset(); 
10040aa6:	f7ff ffd7 	bl	10040a58 <__NVIC_SystemReset>

  /* Configure the Vector Table location */
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation */
#else
  SCB->VTOR = (uint32_t) (__vector_table);
10040aaa:	4b57      	ldr	r3, [pc, #348]	@ (10040c08 <SystemInit+0x18c>)
10040aac:	4a57      	ldr	r2, [pc, #348]	@ (10040c0c <SystemInit+0x190>)
10040aae:	609a      	str	r2, [r3, #8]
#endif /* USER_VECT_TAB_ADDRESS */

  /* Store in RAM the AppBase information */
  RAM_VR.AppBase = (uint32_t) SCB->VTOR;
10040ab0:	4b55      	ldr	r3, [pc, #340]	@ (10040c08 <SystemInit+0x18c>)
10040ab2:	689a      	ldr	r2, [r3, #8]
10040ab4:	4b53      	ldr	r3, [pc, #332]	@ (10040c04 <SystemInit+0x188>)
10040ab6:	611a      	str	r2, [r3, #16]

  /* Enable all the RAM banks in retention during power save */
#if defined(PWR_CR2_RAMRET1)
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET1);
10040ab8:	4b51      	ldr	r3, [pc, #324]	@ (10040c00 <SystemInit+0x184>)
10040aba:	685a      	ldr	r2, [r3, #4]
10040abc:	4b50      	ldr	r3, [pc, #320]	@ (10040c00 <SystemInit+0x184>)
10040abe:	2120      	movs	r1, #32
10040ac0:	430a      	orrs	r2, r1
10040ac2:	605a      	str	r2, [r3, #4]
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET3);
#endif /* PWR_CR2_RAMRET3 */

  /* Disable the GPIO retention in power save configuration */
#if defined(PWR_CR2_GPIORET)
  CLEAR_BIT(PWR->CR2, PWR_CR2_GPIORET);
10040ac4:	4b4e      	ldr	r3, [pc, #312]	@ (10040c00 <SystemInit+0x184>)
10040ac6:	685a      	ldr	r2, [r3, #4]
10040ac8:	4b4d      	ldr	r3, [pc, #308]	@ (10040c00 <SystemInit+0x184>)
10040aca:	4951      	ldr	r1, [pc, #324]	@ (10040c10 <SystemInit+0x194>)
10040acc:	400a      	ands	r2, r1
10040ace:	605a      	str	r2, [r3, #4]
#endif /* PWR_CR2_GPIORET */
   
  /* SMPS setup */
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_BYPAPSS))
  {
    while(READ_BIT(PWR->SR2, PWR_SR2_SMPSRDY) != PWR_SR2_SMPSRDY); // Wait until SMPS is ready
10040ad0:	46c0      	nop			@ (mov r8, r8)
10040ad2:	4b4b      	ldr	r3, [pc, #300]	@ (10040c00 <SystemInit+0x184>)
10040ad4:	695b      	ldr	r3, [r3, #20]
10040ad6:	2204      	movs	r2, #4
10040ad8:	4013      	ands	r3, r2
10040ada:	2b04      	cmp	r3, #4
10040adc:	d1f9      	bne.n	10040ad2 <SystemInit+0x56>
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSBOMSEL, (CFG_HW_SMPS_BOM<<PWR_CR5_SMPSBOMSEL_Pos)); // Configure the SMPS BOM
10040ade:	4b48      	ldr	r3, [pc, #288]	@ (10040c00 <SystemInit+0x184>)
10040ae0:	69db      	ldr	r3, [r3, #28]
10040ae2:	2230      	movs	r2, #48	@ 0x30
10040ae4:	4393      	bics	r3, r2
10040ae6:	001a      	movs	r2, r3
10040ae8:	4b45      	ldr	r3, [pc, #276]	@ (10040c00 <SystemInit+0x184>)
10040aea:	2120      	movs	r1, #32
10040aec:	430a      	orrs	r2, r1
10040aee:	61da      	str	r2, [r3, #28]
  }
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_OFF))
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_NOSMPS, (CFG_HW_SMPS<<PWR_CR5_NOSMPS_Pos)); // SMPS ON/OFF Configuration
10040af0:	4b43      	ldr	r3, [pc, #268]	@ (10040c00 <SystemInit+0x184>)
10040af2:	69da      	ldr	r2, [r3, #28]
10040af4:	4b42      	ldr	r3, [pc, #264]	@ (10040c00 <SystemInit+0x184>)
10040af6:	4947      	ldr	r1, [pc, #284]	@ (10040c14 <SystemInit+0x198>)
10040af8:	400a      	ands	r2, r1
10040afa:	61da      	str	r2, [r3, #28]
  }
  else
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSFBYP, (1<<PWR_CR5_SMPSFBYP_Pos)); // SMPS BYPASS Configuration
  }
  MODIFY_REG(PWR->CR5, PWR_CR5_SMPSLPOPEN, (CFG_HW_SMPS_LOW_POWER<<PWR_CR5_SMPSLPOPEN_Pos)); // SMPS configuration during power save
10040afc:	4b40      	ldr	r3, [pc, #256]	@ (10040c00 <SystemInit+0x184>)
10040afe:	69da      	ldr	r2, [r3, #28]
10040b00:	4b3f      	ldr	r3, [pc, #252]	@ (10040c00 <SystemInit+0x184>)
10040b02:	2180      	movs	r1, #128	@ 0x80
10040b04:	0049      	lsls	r1, r1, #1
10040b06:	430a      	orrs	r2, r1
10040b08:	61da      	str	r2, [r3, #28]
  
  /* If Trimming values from engineering in flash locations are not present load default values */
  if (*(volatile uint32_t*)VALIDITY_LOCATION != VALIDITY_TAG)
10040b0a:	4b43      	ldr	r3, [pc, #268]	@ (10040c18 <SystemInit+0x19c>)
10040b0c:	681b      	ldr	r3, [r3, #0]
10040b0e:	4a43      	ldr	r2, [pc, #268]	@ (10040c1c <SystemInit+0x1a0>)
10040b10:	4293      	cmp	r3, r2
10040b12:	d055      	beq.n	10040bc0 <SystemInit+0x144>

    /* Set Low Speed Internal oscillator LPMU trimming value. */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_LSI_LPMU, ((lsiLpmu << PWR_ENGTRIM_TRIM_LSI_LPMU_Pos) & PWR_ENGTRIM_TRIM_LSI_LPMU));
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMLSILPMUEN);
#else
    hsiCalib       = 0x1F;
10040b14:	231f      	movs	r3, #31
10040b16:	613b      	str	r3, [r7, #16]
    lsiBw          = 8;
10040b18:	2308      	movs	r3, #8
10040b1a:	60fb      	str	r3, [r7, #12]
    mainRegulator  = 0x0A;
10040b1c:	230a      	movs	r3, #10
10040b1e:	60bb      	str	r3, [r7, #8]
    smpsOutVoltage = 0x03;
10040b20:	2303      	movs	r3, #3
10040b22:	607b      	str	r3, [r7, #4]

    /* Low speed internal RC trimming value set by software */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSISWBW, lsiBw << RCC_CSSWCR_LSISWBW_Pos);
10040b24:	4b35      	ldr	r3, [pc, #212]	@ (10040bfc <SystemInit+0x180>)
10040b26:	68db      	ldr	r3, [r3, #12]
10040b28:	221e      	movs	r2, #30
10040b2a:	4393      	bics	r3, r2
10040b2c:	0019      	movs	r1, r3
10040b2e:	68fb      	ldr	r3, [r7, #12]
10040b30:	005a      	lsls	r2, r3, #1
10040b32:	4b32      	ldr	r3, [pc, #200]	@ (10040bfc <SystemInit+0x180>)
10040b34:	430a      	orrs	r2, r1
10040b36:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_LSISWTRIMEN);
10040b38:	4b30      	ldr	r3, [pc, #192]	@ (10040bfc <SystemInit+0x180>)
10040b3a:	68da      	ldr	r2, [r3, #12]
10040b3c:	4b2f      	ldr	r3, [pc, #188]	@ (10040bfc <SystemInit+0x180>)
10040b3e:	2101      	movs	r1, #1
10040b40:	430a      	orrs	r2, r1
10040b42:	60da      	str	r2, [r3, #12]
#endif
    
    /* Set HSI Calibration Trimming value */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_HSITRIMSW, hsiCalib << RCC_CSSWCR_HSITRIMSW_Pos);
10040b44:	4b2d      	ldr	r3, [pc, #180]	@ (10040bfc <SystemInit+0x180>)
10040b46:	68db      	ldr	r3, [r3, #12]
10040b48:	4a35      	ldr	r2, [pc, #212]	@ (10040c20 <SystemInit+0x1a4>)
10040b4a:	4013      	ands	r3, r2
10040b4c:	0019      	movs	r1, r3
10040b4e:	693b      	ldr	r3, [r7, #16]
10040b50:	061a      	lsls	r2, r3, #24
10040b52:	4b2a      	ldr	r3, [pc, #168]	@ (10040bfc <SystemInit+0x180>)
10040b54:	430a      	orrs	r2, r1
10040b56:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_HSISWTRIMEN);
10040b58:	4b28      	ldr	r3, [pc, #160]	@ (10040bfc <SystemInit+0x180>)
10040b5a:	68da      	ldr	r2, [r3, #12]
10040b5c:	4b27      	ldr	r3, [pc, #156]	@ (10040bfc <SystemInit+0x180>)
10040b5e:	2180      	movs	r1, #128	@ 0x80
10040b60:	0409      	lsls	r1, r1, #16
10040b62:	430a      	orrs	r2, r1
10040b64:	60da      	str	r2, [r3, #12]
              
    /* Set Main Regulator voltage Trimming value */ 
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_MR, ((mainRegulator << PWR_ENGTRIM_TRIM_MR_Pos) & PWR_ENGTRIM_TRIM_MR));
10040b66:	4a26      	ldr	r2, [pc, #152]	@ (10040c00 <SystemInit+0x184>)
10040b68:	2394      	movs	r3, #148	@ 0x94
10040b6a:	58d3      	ldr	r3, [r2, r3]
10040b6c:	4a2d      	ldr	r2, [pc, #180]	@ (10040c24 <SystemInit+0x1a8>)
10040b6e:	401a      	ands	r2, r3
10040b70:	68bb      	ldr	r3, [r7, #8]
10040b72:	0199      	lsls	r1, r3, #6
10040b74:	23f0      	movs	r3, #240	@ 0xf0
10040b76:	009b      	lsls	r3, r3, #2
10040b78:	400b      	ands	r3, r1
10040b7a:	4921      	ldr	r1, [pc, #132]	@ (10040c00 <SystemInit+0x184>)
10040b7c:	4313      	orrs	r3, r2
10040b7e:	2294      	movs	r2, #148	@ 0x94
10040b80:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMMREN);
10040b82:	4a1f      	ldr	r2, [pc, #124]	@ (10040c00 <SystemInit+0x184>)
10040b84:	2394      	movs	r3, #148	@ 0x94
10040b86:	58d3      	ldr	r3, [r2, r3]
10040b88:	491d      	ldr	r1, [pc, #116]	@ (10040c00 <SystemInit+0x184>)
10040b8a:	2220      	movs	r2, #32
10040b8c:	4313      	orrs	r3, r2
10040b8e:	2294      	movs	r2, #148	@ 0x94
10040b90:	508b      	str	r3, [r1, r2]

    /* Set SMPS output voltage Trimming value */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_SMPS_TRIM, ((smpsOutVoltage << PWR_ENGTRIM_SMPS_TRIM_Pos) & PWR_ENGTRIM_SMPS_TRIM));
10040b92:	4a1b      	ldr	r2, [pc, #108]	@ (10040c00 <SystemInit+0x184>)
10040b94:	2394      	movs	r3, #148	@ 0x94
10040b96:	58d3      	ldr	r3, [r2, r3]
10040b98:	4a23      	ldr	r2, [pc, #140]	@ (10040c28 <SystemInit+0x1ac>)
10040b9a:	401a      	ands	r2, r3
10040b9c:	687b      	ldr	r3, [r7, #4]
10040b9e:	02d9      	lsls	r1, r3, #11
10040ba0:	23e0      	movs	r3, #224	@ 0xe0
10040ba2:	019b      	lsls	r3, r3, #6
10040ba4:	400b      	ands	r3, r1
10040ba6:	4916      	ldr	r1, [pc, #88]	@ (10040c00 <SystemInit+0x184>)
10040ba8:	4313      	orrs	r3, r2
10040baa:	2294      	movs	r2, #148	@ 0x94
10040bac:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_SMPSTRIMEN);    
10040bae:	4a14      	ldr	r2, [pc, #80]	@ (10040c00 <SystemInit+0x184>)
10040bb0:	2394      	movs	r3, #148	@ 0x94
10040bb2:	58d3      	ldr	r3, [r2, r3]
10040bb4:	4912      	ldr	r1, [pc, #72]	@ (10040c00 <SystemInit+0x184>)
10040bb6:	2280      	movs	r2, #128	@ 0x80
10040bb8:	00d2      	lsls	r2, r2, #3
10040bba:	4313      	orrs	r3, r2
10040bbc:	2294      	movs	r2, #148	@ 0x94
10040bbe:	508b      	str	r3, [r1, r2]
  }

  /* Set all the interrupt with low priprity */
  for (i=0; i<32; i++)
10040bc0:	2317      	movs	r3, #23
10040bc2:	18fb      	adds	r3, r7, r3
10040bc4:	2200      	movs	r2, #0
10040bc6:	701a      	strb	r2, [r3, #0]
10040bc8:	e00d      	b.n	10040be6 <SystemInit+0x16a>
  {
    NVIC_SetPriority((IRQn_Type)i, IRQ_LOW_PRIORITY);
10040bca:	2417      	movs	r4, #23
10040bcc:	193b      	adds	r3, r7, r4
10040bce:	781b      	ldrb	r3, [r3, #0]
10040bd0:	b25b      	sxtb	r3, r3
10040bd2:	2103      	movs	r1, #3
10040bd4:	0018      	movs	r0, r3
10040bd6:	f7ff fed1 	bl	1004097c <__NVIC_SetPriority>
  for (i=0; i<32; i++)
10040bda:	0021      	movs	r1, r4
10040bdc:	187b      	adds	r3, r7, r1
10040bde:	781a      	ldrb	r2, [r3, #0]
10040be0:	187b      	adds	r3, r7, r1
10040be2:	3201      	adds	r2, #1
10040be4:	701a      	strb	r2, [r3, #0]
10040be6:	2317      	movs	r3, #23
10040be8:	18fb      	adds	r3, r7, r3
10040bea:	781b      	ldrb	r3, [r3, #0]
10040bec:	2b1f      	cmp	r3, #31
10040bee:	d9ec      	bls.n	10040bca <SystemInit+0x14e>
  __ASM volatile ("cpsie i" : : : "memory");
10040bf0:	b662      	cpsie	i
}
10040bf2:	46c0      	nop			@ (mov r8, r8)
  }
  
  /* Enable all the irqs */
  __enable_irq();
}
10040bf4:	46c0      	nop			@ (mov r8, r8)
10040bf6:	46bd      	mov	sp, r7
10040bf8:	b007      	add	sp, #28
10040bfa:	bd90      	pop	{r4, r7, pc}
10040bfc:	48400000 	.word	0x48400000
10040c00:	48500000 	.word	0x48500000
10040c04:	20000004 	.word	0x20000004
10040c08:	e000ed00 	.word	0xe000ed00
10040c0c:	10040000 	.word	0x10040000
10040c10:	fffffeff 	.word	0xfffffeff
10040c14:	fffffbff 	.word	0xfffffbff
10040c18:	10001ef8 	.word	0x10001ef8
10040c1c:	fcbceccc 	.word	0xfcbceccc
10040c20:	c0ffffff 	.word	0xc0ffffff
10040c24:	fffffc3f 	.word	0xfffffc3f
10040c28:	ffffc7ff 	.word	0xffffc7ff

10040c2c <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10040c2c:	b580      	push	{r7, lr}
10040c2e:	b082      	sub	sp, #8
10040c30:	af00      	add	r7, sp, #0
  uint8_t directHSE_enabled;
  uint8_t divPrescaler;

  /* Get SYSCLK source HSE or HSI+PLL64MHz */
  directHSE_enabled = (RCC->CFGR & RCC_CFGR_HSESEL) >> RCC_CFGR_HSESEL_Pos;
10040c32:	4b13      	ldr	r3, [pc, #76]	@ (10040c80 <SystemCoreClockUpdate+0x54>)
10040c34:	689b      	ldr	r3, [r3, #8]
10040c36:	085b      	lsrs	r3, r3, #1
10040c38:	b2da      	uxtb	r2, r3
10040c3a:	1dfb      	adds	r3, r7, #7
10040c3c:	2101      	movs	r1, #1
10040c3e:	400a      	ands	r2, r1
10040c40:	701a      	strb	r2, [r3, #0]
#if defined(STM32WB06) || defined(STM32WB07)
  /* Get the clock divider */
    divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV) >> RCC_CFGR_CLKSYSDIV_Pos;
#else
  /* Get the clock divider */
  divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV_STATUS) >> RCC_CFGR_CLKSYSDIV_STATUS_Pos;
10040c42:	4b0f      	ldr	r3, [pc, #60]	@ (10040c80 <SystemCoreClockUpdate+0x54>)
10040c44:	689b      	ldr	r3, [r3, #8]
10040c46:	0a1b      	lsrs	r3, r3, #8
10040c48:	b2da      	uxtb	r2, r3
10040c4a:	1dbb      	adds	r3, r7, #6
10040c4c:	2107      	movs	r1, #7
10040c4e:	400a      	ands	r2, r1
10040c50:	701a      	strb	r2, [r3, #0]
#endif

  if (directHSE_enabled)
10040c52:	1dfb      	adds	r3, r7, #7
10040c54:	781b      	ldrb	r3, [r3, #0]
10040c56:	2b00      	cmp	r3, #0
10040c58:	d007      	beq.n	10040c6a <SystemCoreClockUpdate+0x3e>
  {
    SystemCoreClock = HSE_VALUE >> (divPrescaler - 1U);
10040c5a:	1dbb      	adds	r3, r7, #6
10040c5c:	781b      	ldrb	r3, [r3, #0]
10040c5e:	3b01      	subs	r3, #1
10040c60:	4a08      	ldr	r2, [pc, #32]	@ (10040c84 <SystemCoreClockUpdate+0x58>)
10040c62:	40da      	lsrs	r2, r3
10040c64:	4b08      	ldr	r3, [pc, #32]	@ (10040c88 <SystemCoreClockUpdate+0x5c>)
10040c66:	601a      	str	r2, [r3, #0]
  }
  else
  {
    SystemCoreClock = HSI_VALUE >> divPrescaler;
  }  
}
10040c68:	e005      	b.n	10040c76 <SystemCoreClockUpdate+0x4a>
    SystemCoreClock = HSI_VALUE >> divPrescaler;
10040c6a:	1dbb      	adds	r3, r7, #6
10040c6c:	781b      	ldrb	r3, [r3, #0]
10040c6e:	4a07      	ldr	r2, [pc, #28]	@ (10040c8c <SystemCoreClockUpdate+0x60>)
10040c70:	40da      	lsrs	r2, r3
10040c72:	4b05      	ldr	r3, [pc, #20]	@ (10040c88 <SystemCoreClockUpdate+0x5c>)
10040c74:	601a      	str	r2, [r3, #0]
}
10040c76:	46c0      	nop			@ (mov r8, r8)
10040c78:	46bd      	mov	sp, r7
10040c7a:	b002      	add	sp, #8
10040c7c:	bd80      	pop	{r7, pc}
10040c7e:	46c0      	nop			@ (mov r8, r8)
10040c80:	48400000 	.word	0x48400000
10040c84:	01e84800 	.word	0x01e84800
10040c88:	20000158 	.word	0x20000158
10040c8c:	03d09000 	.word	0x03d09000

10040c90 <CPUcontextRestore>:
  *         by popping it from the stack 
  * @param  None
  * @retval None
  */
__WEAK void CPUcontextRestore(void)
{
10040c90:	b580      	push	{r7, lr}
10040c92:	af00      	add	r7, sp, #0
}
10040c94:	46c0      	nop			@ (mov r8, r8)
10040c96:	46bd      	mov	sp, r7
10040c98:	bd80      	pop	{r7, pc}
	...

10040c9c <Reset_Handler>:

	.section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
10040c9c:	4810      	ldr	r0, [pc, #64]	@ (10040ce0 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
10040c9e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
10040ca0:	f7ff feec 	bl	10040a7c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
10040ca4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
10040ca6:	e003      	b.n	10040cb0 <LoopCopyDataInit>

10040ca8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
10040ca8:	4b0e      	ldr	r3, [pc, #56]	@ (10040ce4 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
10040caa:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
10040cac:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
10040cae:	3104      	adds	r1, #4

10040cb0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
10040cb0:	480d      	ldr	r0, [pc, #52]	@ (10040ce8 <LoopForever+0xa>)
  ldr  r3, =_edata
10040cb2:	4b0e      	ldr	r3, [pc, #56]	@ (10040cec <LoopForever+0xe>)
  adds  r2, r0, r1
10040cb4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
10040cb6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
10040cb8:	d3f6      	bcc.n	10040ca8 <CopyDataInit>
  ldr  r2, =_sbss
10040cba:	4a0d      	ldr	r2, [pc, #52]	@ (10040cf0 <LoopForever+0x12>)
  b  LoopFillZerobss
10040cbc:	e002      	b.n	10040cc4 <LoopFillZerobss>

10040cbe <FillZerobss>:

/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
10040cbe:	2300      	movs	r3, #0
  str  r3, [r2]
10040cc0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
10040cc2:	3204      	adds	r2, #4

10040cc4 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
10040cc4:	4b0b      	ldr	r3, [pc, #44]	@ (10040cf4 <LoopForever+0x16>)
  cmp  r2, r3
10040cc6:	429a      	cmp	r2, r3
  bcc  FillZerobss
10040cc8:	d3f9      	bcc.n	10040cbe <FillZerobss>
  ldr  r2, =_sbssblue
10040cca:	4a0b      	ldr	r2, [pc, #44]	@ (10040cf8 <LoopForever+0x1a>)
  b  LoopFillZeroBlueRam
10040ccc:	e002      	b.n	10040cd4 <LoopFillZeroBlueRam>

10040cce <FillZerobssram>:


FillZerobssram:
  movs  r3, #0
10040cce:	2300      	movs	r3, #0
  str  r3, [r2]
10040cd0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
10040cd2:	3204      	adds	r2, #4

10040cd4 <LoopFillZeroBlueRam>:

LoopFillZeroBlueRam:
  ldr  r3, = _ebssblue
10040cd4:	4b09      	ldr	r3, [pc, #36]	@ (10040cfc <LoopForever+0x1e>)
  cmp  r2, r3
10040cd6:	429a      	cmp	r2, r3
  bcc  FillZerobssram
10040cd8:	d3f9      	bcc.n	10040cce <FillZerobssram>

/* Call the application's entry point.*/
  bl  main
10040cda:	f7ff fd49 	bl	10040770 <main>

10040cde <LoopForever>:

LoopForever:
    b LoopForever
10040cde:	e7fe      	b.n	10040cde <LoopForever>
   ldr   r0, =_estack
10040ce0:	20006000 	.word	0x20006000
  ldr  r3, =_sidata
10040ce4:	100425c0 	.word	0x100425c0
  ldr  r0, =_sdata
10040ce8:	20000158 	.word	0x20000158
  ldr  r3, =_edata
10040cec:	20000178 	.word	0x20000178
  ldr  r2, =_sbss
10040cf0:	200000c0 	.word	0x200000c0
  ldr  r3, = _ebss
10040cf4:	20000158 	.word	0x20000158
  ldr  r2, =_sbssblue
10040cf8:	200000c0 	.word	0x200000c0
  ldr  r3, = _ebssblue
10040cfc:	200000c0 	.word	0x200000c0

10040d00 <ADC_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
10040d00:	e7fe      	b.n	10040d00 <ADC_IRQHandler>
	...

10040d04 <LL_PWR_IsEnabledPUPDCfg>:
{
10040d04:	b580      	push	{r7, lr}
10040d06:	af00      	add	r7, sp, #0
  return ((READ_BIT(PWR->CR1, PWR_CR1_APC) == (PWR_CR1_APC)) ? 1UL : 0UL);
10040d08:	4b05      	ldr	r3, [pc, #20]	@ (10040d20 <LL_PWR_IsEnabledPUPDCfg+0x1c>)
10040d0a:	681b      	ldr	r3, [r3, #0]
10040d0c:	2210      	movs	r2, #16
10040d0e:	4013      	ands	r3, r2
10040d10:	2b10      	cmp	r3, #16
10040d12:	d101      	bne.n	10040d18 <LL_PWR_IsEnabledPUPDCfg+0x14>
10040d14:	2301      	movs	r3, #1
10040d16:	e000      	b.n	10040d1a <LL_PWR_IsEnabledPUPDCfg+0x16>
10040d18:	2300      	movs	r3, #0
}
10040d1a:	0018      	movs	r0, r3
10040d1c:	46bd      	mov	sp, r7
10040d1e:	bd80      	pop	{r7, pc}
10040d20:	48500000 	.word	0x48500000

10040d24 <LL_PWR_EnableGPIOPullUp>:
{
10040d24:	b580      	push	{r7, lr}
10040d26:	b082      	sub	sp, #8
10040d28:	af00      	add	r7, sp, #0
10040d2a:	6078      	str	r0, [r7, #4]
10040d2c:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(*((__IO uint32_t *)(GPIO + 4UL)), GPIONumber);
10040d2e:	687b      	ldr	r3, [r7, #4]
10040d30:	3304      	adds	r3, #4
10040d32:	681a      	ldr	r2, [r3, #0]
10040d34:	683b      	ldr	r3, [r7, #0]
10040d36:	43d9      	mvns	r1, r3
10040d38:	687b      	ldr	r3, [r7, #4]
10040d3a:	3304      	adds	r3, #4
10040d3c:	400a      	ands	r2, r1
10040d3e:	601a      	str	r2, [r3, #0]
  SET_BIT(*((__IO uint32_t *)GPIO), GPIONumber);
10040d40:	687b      	ldr	r3, [r7, #4]
10040d42:	6819      	ldr	r1, [r3, #0]
10040d44:	687b      	ldr	r3, [r7, #4]
10040d46:	683a      	ldr	r2, [r7, #0]
10040d48:	430a      	orrs	r2, r1
10040d4a:	601a      	str	r2, [r3, #0]
}
10040d4c:	46c0      	nop			@ (mov r8, r8)
10040d4e:	46bd      	mov	sp, r7
10040d50:	b002      	add	sp, #8
10040d52:	bd80      	pop	{r7, pc}

10040d54 <LL_AHB1_GRP1_EnableClock>:
{
10040d54:	b580      	push	{r7, lr}
10040d56:	b084      	sub	sp, #16
10040d58:	af00      	add	r7, sp, #0
10040d5a:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHBENR, Periphs);
10040d5c:	4b07      	ldr	r3, [pc, #28]	@ (10040d7c <LL_AHB1_GRP1_EnableClock+0x28>)
10040d5e:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040d60:	4b06      	ldr	r3, [pc, #24]	@ (10040d7c <LL_AHB1_GRP1_EnableClock+0x28>)
10040d62:	687a      	ldr	r2, [r7, #4]
10040d64:	430a      	orrs	r2, r1
10040d66:	651a      	str	r2, [r3, #80]	@ 0x50
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040d68:	4b04      	ldr	r3, [pc, #16]	@ (10040d7c <LL_AHB1_GRP1_EnableClock+0x28>)
10040d6a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040d6c:	687a      	ldr	r2, [r7, #4]
10040d6e:	4013      	ands	r3, r2
10040d70:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040d72:	68fb      	ldr	r3, [r7, #12]
}
10040d74:	46c0      	nop			@ (mov r8, r8)
10040d76:	46bd      	mov	sp, r7
10040d78:	b004      	add	sp, #16
10040d7a:	bd80      	pop	{r7, pc}
10040d7c:	48400000 	.word	0x48400000

10040d80 <BSP_LED_Init>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code.
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
10040d80:	b590      	push	{r4, r7, lr}
10040d82:	b089      	sub	sp, #36	@ 0x24
10040d84:	af00      	add	r7, sp, #0
10040d86:	0002      	movs	r2, r0
10040d88:	1dfb      	adds	r3, r7, #7
10040d8a:	701a      	strb	r2, [r3, #0]
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  if (Led == LD1)
10040d8c:	1dfb      	adds	r3, r7, #7
10040d8e:	781b      	ldrb	r3, [r3, #0]
10040d90:	2b00      	cmp	r3, #0
10040d92:	d103      	bne.n	10040d9c <BSP_LED_Init+0x1c>
  {
    LD1_GPIO_CLK_ENABLE();
10040d94:	2008      	movs	r0, #8
10040d96:	f7ff ffdd 	bl	10040d54 <LL_AHB1_GRP1_EnableClock>
10040d9a:	e00a      	b.n	10040db2 <BSP_LED_Init+0x32>
  }
  else if (Led == LD2)
10040d9c:	1dfb      	adds	r3, r7, #7
10040d9e:	781b      	ldrb	r3, [r3, #0]
10040da0:	2b01      	cmp	r3, #1
10040da2:	d103      	bne.n	10040dac <BSP_LED_Init+0x2c>
  {
    LD2_GPIO_CLK_ENABLE();
10040da4:	2008      	movs	r0, #8
10040da6:	f7ff ffd5 	bl	10040d54 <LL_AHB1_GRP1_EnableClock>
10040daa:	e002      	b.n	10040db2 <BSP_LED_Init+0x32>
  }
  else /* Led = LD3 */
  {
    LD3_GPIO_CLK_ENABLE();
10040dac:	2008      	movs	r0, #8
10040dae:	f7ff ffd1 	bl	10040d54 <LL_AHB1_GRP1_EnableClock>
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
10040db2:	1dfb      	adds	r3, r7, #7
10040db4:	781a      	ldrb	r2, [r3, #0]
10040db6:	4b28      	ldr	r3, [pc, #160]	@ (10040e58 <BSP_LED_Init+0xd8>)
10040db8:	0052      	lsls	r2, r2, #1
10040dba:	5ad3      	ldrh	r3, [r2, r3]
10040dbc:	001a      	movs	r2, r3
10040dbe:	240c      	movs	r4, #12
10040dc0:	193b      	adds	r3, r7, r4
10040dc2:	601a      	str	r2, [r3, #0]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
10040dc4:	193b      	adds	r3, r7, r4
10040dc6:	2201      	movs	r2, #1
10040dc8:	605a      	str	r2, [r3, #4]
  GPIO_Init.Pull  = GPIO_PULLUP;
10040dca:	193b      	adds	r3, r7, r4
10040dcc:	2201      	movs	r2, #1
10040dce:	609a      	str	r2, [r3, #8]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
10040dd0:	193b      	adds	r3, r7, r4
10040dd2:	2202      	movs	r2, #2
10040dd4:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
10040dd6:	1dfb      	adds	r3, r7, #7
10040dd8:	781a      	ldrb	r2, [r3, #0]
10040dda:	4b20      	ldr	r3, [pc, #128]	@ (10040e5c <BSP_LED_Init+0xdc>)
10040ddc:	0092      	lsls	r2, r2, #2
10040dde:	58d3      	ldr	r3, [r2, r3]
10040de0:	193a      	adds	r2, r7, r4
10040de2:	0011      	movs	r1, r2
10040de4:	0018      	movs	r0, r3
10040de6:	f000 f9bb 	bl	10041160 <HAL_GPIO_Init>

  if( LL_PWR_IsEnabledPUPDCfg() != 0)
10040dea:	f7ff ff8b 	bl	10040d04 <LL_PWR_IsEnabledPUPDCfg>
10040dee:	1e03      	subs	r3, r0, #0
10040df0:	d01f      	beq.n	10040e32 <BSP_LED_Init+0xb2>
  {
    if (LED_PORT[Led] == GPIOA)
10040df2:	1dfb      	adds	r3, r7, #7
10040df4:	781a      	ldrb	r2, [r3, #0]
10040df6:	4b19      	ldr	r3, [pc, #100]	@ (10040e5c <BSP_LED_Init+0xdc>)
10040df8:	0092      	lsls	r2, r2, #2
10040dfa:	58d2      	ldr	r2, [r2, r3]
10040dfc:	2390      	movs	r3, #144	@ 0x90
10040dfe:	05db      	lsls	r3, r3, #23
10040e00:	429a      	cmp	r2, r3
10040e02:	d106      	bne.n	10040e12 <BSP_LED_Init+0x92>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_A, GPIO_Init.Pin);
10040e04:	193b      	adds	r3, r7, r4
10040e06:	681b      	ldr	r3, [r3, #0]
10040e08:	4a15      	ldr	r2, [pc, #84]	@ (10040e60 <BSP_LED_Init+0xe0>)
10040e0a:	0019      	movs	r1, r3
10040e0c:	0010      	movs	r0, r2
10040e0e:	f7ff ff89 	bl	10040d24 <LL_PWR_EnableGPIOPullUp>
    }
     if (LED_PORT[Led] == GPIOB)
10040e12:	1dfb      	adds	r3, r7, #7
10040e14:	781a      	ldrb	r2, [r3, #0]
10040e16:	4b11      	ldr	r3, [pc, #68]	@ (10040e5c <BSP_LED_Init+0xdc>)
10040e18:	0092      	lsls	r2, r2, #2
10040e1a:	58d3      	ldr	r3, [r2, r3]
10040e1c:	4a11      	ldr	r2, [pc, #68]	@ (10040e64 <BSP_LED_Init+0xe4>)
10040e1e:	4293      	cmp	r3, r2
10040e20:	d107      	bne.n	10040e32 <BSP_LED_Init+0xb2>
    {
      LL_PWR_EnableGPIOPullUp( LL_PWR_GPIO_B, GPIO_Init.Pin);
10040e22:	230c      	movs	r3, #12
10040e24:	18fb      	adds	r3, r7, r3
10040e26:	681b      	ldr	r3, [r3, #0]
10040e28:	4a0f      	ldr	r2, [pc, #60]	@ (10040e68 <BSP_LED_Init+0xe8>)
10040e2a:	0019      	movs	r1, r3
10040e2c:	0010      	movs	r0, r2
10040e2e:	f7ff ff79 	bl	10040d24 <LL_PWR_EnableGPIOPullUp>
    }
  }

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
10040e32:	1dfb      	adds	r3, r7, #7
10040e34:	781a      	ldrb	r2, [r3, #0]
10040e36:	4b09      	ldr	r3, [pc, #36]	@ (10040e5c <BSP_LED_Init+0xdc>)
10040e38:	0092      	lsls	r2, r2, #2
10040e3a:	58d0      	ldr	r0, [r2, r3]
10040e3c:	1dfb      	adds	r3, r7, #7
10040e3e:	781a      	ldrb	r2, [r3, #0]
10040e40:	4b05      	ldr	r3, [pc, #20]	@ (10040e58 <BSP_LED_Init+0xd8>)
10040e42:	0052      	lsls	r2, r2, #1
10040e44:	5ad3      	ldrh	r3, [r2, r3]
10040e46:	2201      	movs	r2, #1
10040e48:	0019      	movs	r1, r3
10040e4a:	f000 fb32 	bl	100414b2 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
10040e4e:	2300      	movs	r3, #0
}
10040e50:	0018      	movs	r0, r3
10040e52:	46bd      	mov	sp, r7
10040e54:	b009      	add	sp, #36	@ 0x24
10040e56:	bd90      	pop	{r4, r7, pc}
10040e58:	2000015c 	.word	0x2000015c
10040e5c:	20000164 	.word	0x20000164
10040e60:	48500020 	.word	0x48500020
10040e64:	48100000 	.word	0x48100000
10040e68:	48500028 	.word	0x48500028

10040e6c <BSP_LED_Toggle>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code.
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
10040e6c:	b580      	push	{r7, lr}
10040e6e:	b082      	sub	sp, #8
10040e70:	af00      	add	r7, sp, #0
10040e72:	0002      	movs	r2, r0
10040e74:	1dfb      	adds	r3, r7, #7
10040e76:	701a      	strb	r2, [r3, #0]
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
10040e78:	1dfb      	adds	r3, r7, #7
10040e7a:	781a      	ldrb	r2, [r3, #0]
10040e7c:	4b07      	ldr	r3, [pc, #28]	@ (10040e9c <BSP_LED_Toggle+0x30>)
10040e7e:	0092      	lsls	r2, r2, #2
10040e80:	58d0      	ldr	r0, [r2, r3]
10040e82:	1dfb      	adds	r3, r7, #7
10040e84:	781a      	ldrb	r2, [r3, #0]
10040e86:	4b06      	ldr	r3, [pc, #24]	@ (10040ea0 <BSP_LED_Toggle+0x34>)
10040e88:	0052      	lsls	r2, r2, #1
10040e8a:	5ad3      	ldrh	r3, [r2, r3]
10040e8c:	0019      	movs	r1, r3
10040e8e:	f000 fb2d 	bl	100414ec <HAL_GPIO_TogglePin>
  return BSP_ERROR_NONE;
10040e92:	2300      	movs	r3, #0
}
10040e94:	0018      	movs	r0, r3
10040e96:	46bd      	mov	sp, r7
10040e98:	b002      	add	sp, #8
10040e9a:	bd80      	pop	{r7, pc}
10040e9c:	20000164 	.word	0x20000164
10040ea0:	2000015c 	.word	0x2000015c

10040ea4 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
10040ea4:	b580      	push	{r7, lr}
10040ea6:	b082      	sub	sp, #8
10040ea8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
10040eaa:	1dfb      	adds	r3, r7, #7
10040eac:	2200      	movs	r2, #0
10040eae:	701a      	strb	r2, [r3, #0]

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
10040eb0:	2003      	movs	r0, #3
10040eb2:	f000 f80f 	bl	10040ed4 <HAL_InitTick>
10040eb6:	1e03      	subs	r3, r0, #0
10040eb8:	d003      	beq.n	10040ec2 <HAL_Init+0x1e>
  {
    status = HAL_ERROR;
10040eba:	1dfb      	adds	r3, r7, #7
10040ebc:	2201      	movs	r2, #1
10040ebe:	701a      	strb	r2, [r3, #0]
10040ec0:	e001      	b.n	10040ec6 <HAL_Init+0x22>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
10040ec2:	f7ff fcd1 	bl	10040868 <HAL_MspInit>
  }

  /* Return function status */
  return status;
10040ec6:	1dfb      	adds	r3, r7, #7
10040ec8:	781b      	ldrb	r3, [r3, #0]
}
10040eca:	0018      	movs	r0, r3
10040ecc:	46bd      	mov	sp, r7
10040ece:	b002      	add	sp, #8
10040ed0:	bd80      	pop	{r7, pc}
	...

10040ed4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
10040ed4:	b590      	push	{r4, r7, lr}
10040ed6:	b085      	sub	sp, #20
10040ed8:	af00      	add	r7, sp, #0
10040eda:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
10040edc:	230f      	movs	r3, #15
10040ede:	18fb      	adds	r3, r7, r3
10040ee0:	2200      	movs	r2, #0
10040ee2:	701a      	strb	r2, [r3, #0]

  if (uwTickFreq != 0U)
10040ee4:	4b1d      	ldr	r3, [pc, #116]	@ (10040f5c <HAL_InitTick+0x88>)
10040ee6:	781b      	ldrb	r3, [r3, #0]
10040ee8:	2b00      	cmp	r3, #0
10040eea:	d02c      	beq.n	10040f46 <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetSysClockFreq() / (1000U / uwTickFreq)) == 0U)
10040eec:	f000 fc6e 	bl	100417cc <HAL_RCC_GetSysClockFreq>
10040ef0:	0004      	movs	r4, r0
10040ef2:	4b1a      	ldr	r3, [pc, #104]	@ (10040f5c <HAL_InitTick+0x88>)
10040ef4:	781b      	ldrb	r3, [r3, #0]
10040ef6:	0019      	movs	r1, r3
10040ef8:	23fa      	movs	r3, #250	@ 0xfa
10040efa:	0098      	lsls	r0, r3, #2
10040efc:	f7ff f8e0 	bl	100400c0 <__udivsi3>
10040f00:	0003      	movs	r3, r0
10040f02:	0019      	movs	r1, r3
10040f04:	0020      	movs	r0, r4
10040f06:	f7ff f8db 	bl	100400c0 <__udivsi3>
10040f0a:	0003      	movs	r3, r0
10040f0c:	0018      	movs	r0, r3
10040f0e:	f000 f91a 	bl	10041146 <HAL_SYSTICK_Config>
10040f12:	1e03      	subs	r3, r0, #0
10040f14:	d112      	bne.n	10040f3c <HAL_InitTick+0x68>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
10040f16:	687b      	ldr	r3, [r7, #4]
10040f18:	2b03      	cmp	r3, #3
10040f1a:	d80a      	bhi.n	10040f32 <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
10040f1c:	6879      	ldr	r1, [r7, #4]
10040f1e:	2301      	movs	r3, #1
10040f20:	425b      	negs	r3, r3
10040f22:	2200      	movs	r2, #0
10040f24:	0018      	movs	r0, r3
10040f26:	f000 f8f9 	bl	1004111c <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
10040f2a:	4b0d      	ldr	r3, [pc, #52]	@ (10040f60 <HAL_InitTick+0x8c>)
10040f2c:	687a      	ldr	r2, [r7, #4]
10040f2e:	601a      	str	r2, [r3, #0]
10040f30:	e00d      	b.n	10040f4e <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
10040f32:	230f      	movs	r3, #15
10040f34:	18fb      	adds	r3, r7, r3
10040f36:	2201      	movs	r2, #1
10040f38:	701a      	strb	r2, [r3, #0]
10040f3a:	e008      	b.n	10040f4e <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
10040f3c:	230f      	movs	r3, #15
10040f3e:	18fb      	adds	r3, r7, r3
10040f40:	2201      	movs	r2, #1
10040f42:	701a      	strb	r2, [r3, #0]
10040f44:	e003      	b.n	10040f4e <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
10040f46:	230f      	movs	r3, #15
10040f48:	18fb      	adds	r3, r7, r3
10040f4a:	2201      	movs	r2, #1
10040f4c:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
10040f4e:	230f      	movs	r3, #15
10040f50:	18fb      	adds	r3, r7, r3
10040f52:	781b      	ldrb	r3, [r3, #0]
}
10040f54:	0018      	movs	r0, r3
10040f56:	46bd      	mov	sp, r7
10040f58:	b005      	add	sp, #20
10040f5a:	bd90      	pop	{r4, r7, pc}
10040f5c:	20000174 	.word	0x20000174
10040f60:	20000170 	.word	0x20000170

10040f64 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
10040f64:	b580      	push	{r7, lr}
10040f66:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
10040f68:	4b05      	ldr	r3, [pc, #20]	@ (10040f80 <HAL_IncTick+0x1c>)
10040f6a:	781b      	ldrb	r3, [r3, #0]
10040f6c:	001a      	movs	r2, r3
10040f6e:	4b05      	ldr	r3, [pc, #20]	@ (10040f84 <HAL_IncTick+0x20>)
10040f70:	681b      	ldr	r3, [r3, #0]
10040f72:	18d2      	adds	r2, r2, r3
10040f74:	4b03      	ldr	r3, [pc, #12]	@ (10040f84 <HAL_IncTick+0x20>)
10040f76:	601a      	str	r2, [r3, #0]
}
10040f78:	46c0      	nop			@ (mov r8, r8)
10040f7a:	46bd      	mov	sp, r7
10040f7c:	bd80      	pop	{r7, pc}
10040f7e:	46c0      	nop			@ (mov r8, r8)
10040f80:	20000174 	.word	0x20000174
10040f84:	20000154 	.word	0x20000154

10040f88 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
10040f88:	b580      	push	{r7, lr}
10040f8a:	af00      	add	r7, sp, #0
  return uwTick;
10040f8c:	4b02      	ldr	r3, [pc, #8]	@ (10040f98 <HAL_GetTick+0x10>)
10040f8e:	681b      	ldr	r3, [r3, #0]
}
10040f90:	0018      	movs	r0, r3
10040f92:	46bd      	mov	sp, r7
10040f94:	bd80      	pop	{r7, pc}
10040f96:	46c0      	nop			@ (mov r8, r8)
10040f98:	20000154 	.word	0x20000154

10040f9c <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
10040f9c:	b580      	push	{r7, lr}
10040f9e:	af00      	add	r7, sp, #0
  return uwTickPrio;
10040fa0:	4b02      	ldr	r3, [pc, #8]	@ (10040fac <HAL_GetTickPrio+0x10>)
10040fa2:	681b      	ldr	r3, [r3, #0]
}
10040fa4:	0018      	movs	r0, r3
10040fa6:	46bd      	mov	sp, r7
10040fa8:	bd80      	pop	{r7, pc}
10040faa:	46c0      	nop			@ (mov r8, r8)
10040fac:	20000170 	.word	0x20000170

10040fb0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
10040fb0:	b580      	push	{r7, lr}
10040fb2:	b084      	sub	sp, #16
10040fb4:	af00      	add	r7, sp, #0
10040fb6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
10040fb8:	f7ff ffe6 	bl	10040f88 <HAL_GetTick>
10040fbc:	0003      	movs	r3, r0
10040fbe:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
10040fc0:	687b      	ldr	r3, [r7, #4]
10040fc2:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
10040fc4:	68fb      	ldr	r3, [r7, #12]
10040fc6:	3301      	adds	r3, #1
10040fc8:	d005      	beq.n	10040fd6 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
10040fca:	4b0a      	ldr	r3, [pc, #40]	@ (10040ff4 <HAL_Delay+0x44>)
10040fcc:	781b      	ldrb	r3, [r3, #0]
10040fce:	001a      	movs	r2, r3
10040fd0:	68fb      	ldr	r3, [r7, #12]
10040fd2:	189b      	adds	r3, r3, r2
10040fd4:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
10040fd6:	46c0      	nop			@ (mov r8, r8)
10040fd8:	f7ff ffd6 	bl	10040f88 <HAL_GetTick>
10040fdc:	0002      	movs	r2, r0
10040fde:	68bb      	ldr	r3, [r7, #8]
10040fe0:	1ad3      	subs	r3, r2, r3
10040fe2:	68fa      	ldr	r2, [r7, #12]
10040fe4:	429a      	cmp	r2, r3
10040fe6:	d8f7      	bhi.n	10040fd8 <HAL_Delay+0x28>
  {
  }
}
10040fe8:	46c0      	nop			@ (mov r8, r8)
10040fea:	46c0      	nop			@ (mov r8, r8)
10040fec:	46bd      	mov	sp, r7
10040fee:	b004      	add	sp, #16
10040ff0:	bd80      	pop	{r7, pc}
10040ff2:	46c0      	nop			@ (mov r8, r8)
10040ff4:	20000174 	.word	0x20000174

10040ff8 <__NVIC_SetPriority>:
{
10040ff8:	b590      	push	{r4, r7, lr}
10040ffa:	b083      	sub	sp, #12
10040ffc:	af00      	add	r7, sp, #0
10040ffe:	0002      	movs	r2, r0
10041000:	6039      	str	r1, [r7, #0]
10041002:	1dfb      	adds	r3, r7, #7
10041004:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041006:	1dfb      	adds	r3, r7, #7
10041008:	781b      	ldrb	r3, [r3, #0]
1004100a:	2b7f      	cmp	r3, #127	@ 0x7f
1004100c:	d828      	bhi.n	10041060 <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004100e:	4a2f      	ldr	r2, [pc, #188]	@ (100410cc <__NVIC_SetPriority+0xd4>)
10041010:	1dfb      	adds	r3, r7, #7
10041012:	781b      	ldrb	r3, [r3, #0]
10041014:	b25b      	sxtb	r3, r3
10041016:	089b      	lsrs	r3, r3, #2
10041018:	33c0      	adds	r3, #192	@ 0xc0
1004101a:	009b      	lsls	r3, r3, #2
1004101c:	589b      	ldr	r3, [r3, r2]
1004101e:	1dfa      	adds	r2, r7, #7
10041020:	7812      	ldrb	r2, [r2, #0]
10041022:	0011      	movs	r1, r2
10041024:	2203      	movs	r2, #3
10041026:	400a      	ands	r2, r1
10041028:	00d2      	lsls	r2, r2, #3
1004102a:	21ff      	movs	r1, #255	@ 0xff
1004102c:	4091      	lsls	r1, r2
1004102e:	000a      	movs	r2, r1
10041030:	43d2      	mvns	r2, r2
10041032:	401a      	ands	r2, r3
10041034:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041036:	683b      	ldr	r3, [r7, #0]
10041038:	019b      	lsls	r3, r3, #6
1004103a:	22ff      	movs	r2, #255	@ 0xff
1004103c:	401a      	ands	r2, r3
1004103e:	1dfb      	adds	r3, r7, #7
10041040:	781b      	ldrb	r3, [r3, #0]
10041042:	0018      	movs	r0, r3
10041044:	2303      	movs	r3, #3
10041046:	4003      	ands	r3, r0
10041048:	00db      	lsls	r3, r3, #3
1004104a:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004104c:	481f      	ldr	r0, [pc, #124]	@ (100410cc <__NVIC_SetPriority+0xd4>)
1004104e:	1dfb      	adds	r3, r7, #7
10041050:	781b      	ldrb	r3, [r3, #0]
10041052:	b25b      	sxtb	r3, r3
10041054:	089b      	lsrs	r3, r3, #2
10041056:	430a      	orrs	r2, r1
10041058:	33c0      	adds	r3, #192	@ 0xc0
1004105a:	009b      	lsls	r3, r3, #2
1004105c:	501a      	str	r2, [r3, r0]
}
1004105e:	e031      	b.n	100410c4 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041060:	4a1b      	ldr	r2, [pc, #108]	@ (100410d0 <__NVIC_SetPriority+0xd8>)
10041062:	1dfb      	adds	r3, r7, #7
10041064:	781b      	ldrb	r3, [r3, #0]
10041066:	0019      	movs	r1, r3
10041068:	230f      	movs	r3, #15
1004106a:	400b      	ands	r3, r1
1004106c:	3b08      	subs	r3, #8
1004106e:	089b      	lsrs	r3, r3, #2
10041070:	3306      	adds	r3, #6
10041072:	009b      	lsls	r3, r3, #2
10041074:	18d3      	adds	r3, r2, r3
10041076:	3304      	adds	r3, #4
10041078:	681b      	ldr	r3, [r3, #0]
1004107a:	1dfa      	adds	r2, r7, #7
1004107c:	7812      	ldrb	r2, [r2, #0]
1004107e:	0011      	movs	r1, r2
10041080:	2203      	movs	r2, #3
10041082:	400a      	ands	r2, r1
10041084:	00d2      	lsls	r2, r2, #3
10041086:	21ff      	movs	r1, #255	@ 0xff
10041088:	4091      	lsls	r1, r2
1004108a:	000a      	movs	r2, r1
1004108c:	43d2      	mvns	r2, r2
1004108e:	401a      	ands	r2, r3
10041090:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041092:	683b      	ldr	r3, [r7, #0]
10041094:	019b      	lsls	r3, r3, #6
10041096:	22ff      	movs	r2, #255	@ 0xff
10041098:	401a      	ands	r2, r3
1004109a:	1dfb      	adds	r3, r7, #7
1004109c:	781b      	ldrb	r3, [r3, #0]
1004109e:	0018      	movs	r0, r3
100410a0:	2303      	movs	r3, #3
100410a2:	4003      	ands	r3, r0
100410a4:	00db      	lsls	r3, r3, #3
100410a6:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100410a8:	4809      	ldr	r0, [pc, #36]	@ (100410d0 <__NVIC_SetPriority+0xd8>)
100410aa:	1dfb      	adds	r3, r7, #7
100410ac:	781b      	ldrb	r3, [r3, #0]
100410ae:	001c      	movs	r4, r3
100410b0:	230f      	movs	r3, #15
100410b2:	4023      	ands	r3, r4
100410b4:	3b08      	subs	r3, #8
100410b6:	089b      	lsrs	r3, r3, #2
100410b8:	430a      	orrs	r2, r1
100410ba:	3306      	adds	r3, #6
100410bc:	009b      	lsls	r3, r3, #2
100410be:	18c3      	adds	r3, r0, r3
100410c0:	3304      	adds	r3, #4
100410c2:	601a      	str	r2, [r3, #0]
}
100410c4:	46c0      	nop			@ (mov r8, r8)
100410c6:	46bd      	mov	sp, r7
100410c8:	b003      	add	sp, #12
100410ca:	bd90      	pop	{r4, r7, pc}
100410cc:	e000e100 	.word	0xe000e100
100410d0:	e000ed00 	.word	0xe000ed00

100410d4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
100410d4:	b580      	push	{r7, lr}
100410d6:	b082      	sub	sp, #8
100410d8:	af00      	add	r7, sp, #0
100410da:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
100410dc:	687b      	ldr	r3, [r7, #4]
100410de:	1e5a      	subs	r2, r3, #1
100410e0:	2380      	movs	r3, #128	@ 0x80
100410e2:	045b      	lsls	r3, r3, #17
100410e4:	429a      	cmp	r2, r3
100410e6:	d301      	bcc.n	100410ec <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
100410e8:	2301      	movs	r3, #1
100410ea:	e010      	b.n	1004110e <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
100410ec:	4b0a      	ldr	r3, [pc, #40]	@ (10041118 <SysTick_Config+0x44>)
100410ee:	687a      	ldr	r2, [r7, #4]
100410f0:	3a01      	subs	r2, #1
100410f2:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
100410f4:	2301      	movs	r3, #1
100410f6:	425b      	negs	r3, r3
100410f8:	2103      	movs	r1, #3
100410fa:	0018      	movs	r0, r3
100410fc:	f7ff ff7c 	bl	10040ff8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
10041100:	4b05      	ldr	r3, [pc, #20]	@ (10041118 <SysTick_Config+0x44>)
10041102:	2200      	movs	r2, #0
10041104:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
10041106:	4b04      	ldr	r3, [pc, #16]	@ (10041118 <SysTick_Config+0x44>)
10041108:	2207      	movs	r2, #7
1004110a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
1004110c:	2300      	movs	r3, #0
}
1004110e:	0018      	movs	r0, r3
10041110:	46bd      	mov	sp, r7
10041112:	b002      	add	sp, #8
10041114:	bd80      	pop	{r7, pc}
10041116:	46c0      	nop			@ (mov r8, r8)
10041118:	e000e010 	.word	0xe000e010

1004111c <HAL_NVIC_SetPriority>:
  *         with stm32wb0x devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
1004111c:	b580      	push	{r7, lr}
1004111e:	b084      	sub	sp, #16
10041120:	af00      	add	r7, sp, #0
10041122:	60b9      	str	r1, [r7, #8]
10041124:	607a      	str	r2, [r7, #4]
10041126:	210f      	movs	r1, #15
10041128:	187b      	adds	r3, r7, r1
1004112a:	1c02      	adds	r2, r0, #0
1004112c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
1004112e:	68ba      	ldr	r2, [r7, #8]
10041130:	187b      	adds	r3, r7, r1
10041132:	781b      	ldrb	r3, [r3, #0]
10041134:	b25b      	sxtb	r3, r3
10041136:	0011      	movs	r1, r2
10041138:	0018      	movs	r0, r3
1004113a:	f7ff ff5d 	bl	10040ff8 <__NVIC_SetPriority>
}
1004113e:	46c0      	nop			@ (mov r8, r8)
10041140:	46bd      	mov	sp, r7
10041142:	b004      	add	sp, #16
10041144:	bd80      	pop	{r7, pc}

10041146 <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
10041146:	b580      	push	{r7, lr}
10041148:	b082      	sub	sp, #8
1004114a:	af00      	add	r7, sp, #0
1004114c:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
1004114e:	687b      	ldr	r3, [r7, #4]
10041150:	0018      	movs	r0, r3
10041152:	f7ff ffbf 	bl	100410d4 <SysTick_Config>
10041156:	0003      	movs	r3, r0
}
10041158:	0018      	movs	r0, r3
1004115a:	46bd      	mov	sp, r7
1004115c:	b002      	add	sp, #8
1004115e:	bd80      	pop	{r7, pc}

10041160 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
10041160:	b580      	push	{r7, lr}
10041162:	b086      	sub	sp, #24
10041164:	af00      	add	r7, sp, #0
10041166:	6078      	str	r0, [r7, #4]
10041168:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
1004116a:	2300      	movs	r3, #0
1004116c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
1004116e:	e194      	b.n	1004149a <HAL_GPIO_Init+0x33a>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
10041170:	683b      	ldr	r3, [r7, #0]
10041172:	681b      	ldr	r3, [r3, #0]
10041174:	2101      	movs	r1, #1
10041176:	697a      	ldr	r2, [r7, #20]
10041178:	4091      	lsls	r1, r2
1004117a:	000a      	movs	r2, r1
1004117c:	4013      	ands	r3, r2
1004117e:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
10041180:	68fb      	ldr	r3, [r7, #12]
10041182:	2b00      	cmp	r3, #0
10041184:	d100      	bne.n	10041188 <HAL_GPIO_Init+0x28>
10041186:	e185      	b.n	10041494 <HAL_GPIO_Init+0x334>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
10041188:	683b      	ldr	r3, [r7, #0]
1004118a:	685b      	ldr	r3, [r3, #4]
1004118c:	2203      	movs	r2, #3
1004118e:	4013      	ands	r3, r2
10041190:	2b01      	cmp	r3, #1
10041192:	d005      	beq.n	100411a0 <HAL_GPIO_Init+0x40>
10041194:	683b      	ldr	r3, [r7, #0]
10041196:	685b      	ldr	r3, [r3, #4]
10041198:	2203      	movs	r2, #3
1004119a:	4013      	ands	r3, r2
1004119c:	2b02      	cmp	r3, #2
1004119e:	d130      	bne.n	10041202 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
100411a0:	687b      	ldr	r3, [r7, #4]
100411a2:	689b      	ldr	r3, [r3, #8]
100411a4:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
100411a6:	697b      	ldr	r3, [r7, #20]
100411a8:	005b      	lsls	r3, r3, #1
100411aa:	2203      	movs	r2, #3
100411ac:	409a      	lsls	r2, r3
100411ae:	0013      	movs	r3, r2
100411b0:	43da      	mvns	r2, r3
100411b2:	693b      	ldr	r3, [r7, #16]
100411b4:	4013      	ands	r3, r2
100411b6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
100411b8:	683b      	ldr	r3, [r7, #0]
100411ba:	68da      	ldr	r2, [r3, #12]
100411bc:	697b      	ldr	r3, [r7, #20]
100411be:	005b      	lsls	r3, r3, #1
100411c0:	409a      	lsls	r2, r3
100411c2:	0013      	movs	r3, r2
100411c4:	693a      	ldr	r2, [r7, #16]
100411c6:	4313      	orrs	r3, r2
100411c8:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
100411ca:	687b      	ldr	r3, [r7, #4]
100411cc:	693a      	ldr	r2, [r7, #16]
100411ce:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
100411d0:	687b      	ldr	r3, [r7, #4]
100411d2:	685b      	ldr	r3, [r3, #4]
100411d4:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
100411d6:	2201      	movs	r2, #1
100411d8:	697b      	ldr	r3, [r7, #20]
100411da:	409a      	lsls	r2, r3
100411dc:	0013      	movs	r3, r2
100411de:	43da      	mvns	r2, r3
100411e0:	693b      	ldr	r3, [r7, #16]
100411e2:	4013      	ands	r3, r2
100411e4:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
100411e6:	683b      	ldr	r3, [r7, #0]
100411e8:	685b      	ldr	r3, [r3, #4]
100411ea:	091b      	lsrs	r3, r3, #4
100411ec:	2201      	movs	r2, #1
100411ee:	401a      	ands	r2, r3
100411f0:	697b      	ldr	r3, [r7, #20]
100411f2:	409a      	lsls	r2, r3
100411f4:	0013      	movs	r3, r2
100411f6:	693a      	ldr	r2, [r7, #16]
100411f8:	4313      	orrs	r3, r2
100411fa:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
100411fc:	687b      	ldr	r3, [r7, #4]
100411fe:	693a      	ldr	r2, [r7, #16]
10041200:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
10041202:	683b      	ldr	r3, [r7, #0]
10041204:	685b      	ldr	r3, [r3, #4]
10041206:	2203      	movs	r2, #3
10041208:	4013      	ands	r3, r2
1004120a:	2b03      	cmp	r3, #3
1004120c:	d017      	beq.n	1004123e <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
1004120e:	687b      	ldr	r3, [r7, #4]
10041210:	68db      	ldr	r3, [r3, #12]
10041212:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
10041214:	697b      	ldr	r3, [r7, #20]
10041216:	005b      	lsls	r3, r3, #1
10041218:	2203      	movs	r2, #3
1004121a:	409a      	lsls	r2, r3
1004121c:	0013      	movs	r3, r2
1004121e:	43da      	mvns	r2, r3
10041220:	693b      	ldr	r3, [r7, #16]
10041222:	4013      	ands	r3, r2
10041224:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
10041226:	683b      	ldr	r3, [r7, #0]
10041228:	689a      	ldr	r2, [r3, #8]
1004122a:	697b      	ldr	r3, [r7, #20]
1004122c:	005b      	lsls	r3, r3, #1
1004122e:	409a      	lsls	r2, r3
10041230:	0013      	movs	r3, r2
10041232:	693a      	ldr	r2, [r7, #16]
10041234:	4313      	orrs	r3, r2
10041236:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
10041238:	687b      	ldr	r3, [r7, #4]
1004123a:	693a      	ldr	r2, [r7, #16]
1004123c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
1004123e:	683b      	ldr	r3, [r7, #0]
10041240:	685b      	ldr	r3, [r3, #4]
10041242:	2203      	movs	r2, #3
10041244:	4013      	ands	r3, r2
10041246:	2b02      	cmp	r3, #2
10041248:	d123      	bne.n	10041292 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
1004124a:	697b      	ldr	r3, [r7, #20]
1004124c:	08da      	lsrs	r2, r3, #3
1004124e:	687b      	ldr	r3, [r7, #4]
10041250:	3208      	adds	r2, #8
10041252:	0092      	lsls	r2, r2, #2
10041254:	58d3      	ldr	r3, [r2, r3]
10041256:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
10041258:	697b      	ldr	r3, [r7, #20]
1004125a:	2207      	movs	r2, #7
1004125c:	4013      	ands	r3, r2
1004125e:	009b      	lsls	r3, r3, #2
10041260:	220f      	movs	r2, #15
10041262:	409a      	lsls	r2, r3
10041264:	0013      	movs	r3, r2
10041266:	43da      	mvns	r2, r3
10041268:	693b      	ldr	r3, [r7, #16]
1004126a:	4013      	ands	r3, r2
1004126c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
1004126e:	683b      	ldr	r3, [r7, #0]
10041270:	691a      	ldr	r2, [r3, #16]
10041272:	697b      	ldr	r3, [r7, #20]
10041274:	2107      	movs	r1, #7
10041276:	400b      	ands	r3, r1
10041278:	009b      	lsls	r3, r3, #2
1004127a:	409a      	lsls	r2, r3
1004127c:	0013      	movs	r3, r2
1004127e:	693a      	ldr	r2, [r7, #16]
10041280:	4313      	orrs	r3, r2
10041282:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
10041284:	697b      	ldr	r3, [r7, #20]
10041286:	08da      	lsrs	r2, r3, #3
10041288:	687b      	ldr	r3, [r7, #4]
1004128a:	3208      	adds	r2, #8
1004128c:	0092      	lsls	r2, r2, #2
1004128e:	6939      	ldr	r1, [r7, #16]
10041290:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
10041292:	687b      	ldr	r3, [r7, #4]
10041294:	681b      	ldr	r3, [r3, #0]
10041296:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
10041298:	697b      	ldr	r3, [r7, #20]
1004129a:	005b      	lsls	r3, r3, #1
1004129c:	2203      	movs	r2, #3
1004129e:	409a      	lsls	r2, r3
100412a0:	0013      	movs	r3, r2
100412a2:	43da      	mvns	r2, r3
100412a4:	693b      	ldr	r3, [r7, #16]
100412a6:	4013      	ands	r3, r2
100412a8:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
100412aa:	683b      	ldr	r3, [r7, #0]
100412ac:	685b      	ldr	r3, [r3, #4]
100412ae:	2203      	movs	r2, #3
100412b0:	401a      	ands	r2, r3
100412b2:	697b      	ldr	r3, [r7, #20]
100412b4:	005b      	lsls	r3, r3, #1
100412b6:	409a      	lsls	r2, r3
100412b8:	0013      	movs	r3, r2
100412ba:	693a      	ldr	r2, [r7, #16]
100412bc:	4313      	orrs	r3, r2
100412be:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
100412c0:	687b      	ldr	r3, [r7, #4]
100412c2:	693a      	ldr	r2, [r7, #16]
100412c4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
100412c6:	683b      	ldr	r3, [r7, #0]
100412c8:	685a      	ldr	r2, [r3, #4]
100412ca:	23c0      	movs	r3, #192	@ 0xc0
100412cc:	029b      	lsls	r3, r3, #10
100412ce:	4013      	ands	r3, r2
100412d0:	d100      	bne.n	100412d4 <HAL_GPIO_Init+0x174>
100412d2:	e0df      	b.n	10041494 <HAL_GPIO_Init+0x334>
      {

        /* Edge/Level line configuration */
        if ((GPIO_Init->Mode & DETECTION_TYPE) != 0x00u)
100412d4:	683b      	ldr	r3, [r7, #0]
100412d6:	685a      	ldr	r2, [r3, #4]
100412d8:	2380      	movs	r3, #128	@ 0x80
100412da:	02db      	lsls	r3, r3, #11
100412dc:	4013      	ands	r3, r2
100412de:	d031      	beq.n	10041344 <HAL_GPIO_Init+0x1e4>
        {
          temp = SYSCFG->IO_DTR;
100412e0:	2380      	movs	r3, #128	@ 0x80
100412e2:	05db      	lsls	r3, r3, #23
100412e4:	68db      	ldr	r3, [r3, #12]
100412e6:	613b      	str	r3, [r7, #16]
          if (GPIOx == GPIOA)
100412e8:	687a      	ldr	r2, [r7, #4]
100412ea:	2390      	movs	r3, #144	@ 0x90
100412ec:	05db      	lsls	r3, r3, #23
100412ee:	429a      	cmp	r2, r3
100412f0:	d111      	bne.n	10041316 <HAL_GPIO_Init+0x1b6>
          {
            temp &= ~(1 << position);
100412f2:	2201      	movs	r2, #1
100412f4:	697b      	ldr	r3, [r7, #20]
100412f6:	409a      	lsls	r2, r3
100412f8:	0013      	movs	r3, r2
100412fa:	43db      	mvns	r3, r3
100412fc:	001a      	movs	r2, r3
100412fe:	693b      	ldr	r3, [r7, #16]
10041300:	4013      	ands	r3, r2
10041302:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041304:	2201      	movs	r2, #1
10041306:	697b      	ldr	r3, [r7, #20]
10041308:	409a      	lsls	r2, r3
1004130a:	0013      	movs	r3, r2
1004130c:	001a      	movs	r2, r3
1004130e:	693b      	ldr	r3, [r7, #16]
10041310:	4313      	orrs	r3, r2
10041312:	613b      	str	r3, [r7, #16]
10041314:	e012      	b.n	1004133c <HAL_GPIO_Init+0x1dc>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041316:	2201      	movs	r2, #1
10041318:	697b      	ldr	r3, [r7, #20]
1004131a:	409a      	lsls	r2, r3
1004131c:	0013      	movs	r3, r2
1004131e:	041b      	lsls	r3, r3, #16
10041320:	43db      	mvns	r3, r3
10041322:	001a      	movs	r2, r3
10041324:	693b      	ldr	r3, [r7, #16]
10041326:	4013      	ands	r3, r2
10041328:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
1004132a:	2201      	movs	r2, #1
1004132c:	697b      	ldr	r3, [r7, #20]
1004132e:	409a      	lsls	r2, r3
10041330:	0013      	movs	r3, r2
10041332:	041b      	lsls	r3, r3, #16
10041334:	001a      	movs	r2, r3
10041336:	693b      	ldr	r3, [r7, #16]
10041338:	4313      	orrs	r3, r2
1004133a:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_DTR = temp;
1004133c:	2380      	movs	r3, #128	@ 0x80
1004133e:	05db      	lsls	r3, r3, #23
10041340:	693a      	ldr	r2, [r7, #16]
10041342:	60da      	str	r2, [r3, #12]
        }

		/* Edge selection configuration */
		if ((GPIO_Init->Mode & EDGE_SELECTION) != 0x00u)
10041344:	683b      	ldr	r3, [r7, #0]
10041346:	685a      	ldr	r2, [r3, #4]
10041348:	2380      	movs	r3, #128	@ 0x80
1004134a:	035b      	lsls	r3, r3, #13
1004134c:	4013      	ands	r3, r2
1004134e:	d031      	beq.n	100413b4 <HAL_GPIO_Init+0x254>
        {
          temp = SYSCFG->IO_IBER;
10041350:	2380      	movs	r3, #128	@ 0x80
10041352:	05db      	lsls	r3, r3, #23
10041354:	691b      	ldr	r3, [r3, #16]
10041356:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041358:	687a      	ldr	r2, [r7, #4]
1004135a:	2390      	movs	r3, #144	@ 0x90
1004135c:	05db      	lsls	r3, r3, #23
1004135e:	429a      	cmp	r2, r3
10041360:	d111      	bne.n	10041386 <HAL_GPIO_Init+0x226>
          {
            temp &= ~(1 << position);
10041362:	2201      	movs	r2, #1
10041364:	697b      	ldr	r3, [r7, #20]
10041366:	409a      	lsls	r2, r3
10041368:	0013      	movs	r3, r2
1004136a:	43db      	mvns	r3, r3
1004136c:	001a      	movs	r2, r3
1004136e:	693b      	ldr	r3, [r7, #16]
10041370:	4013      	ands	r3, r2
10041372:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041374:	2201      	movs	r2, #1
10041376:	697b      	ldr	r3, [r7, #20]
10041378:	409a      	lsls	r2, r3
1004137a:	0013      	movs	r3, r2
1004137c:	001a      	movs	r2, r3
1004137e:	693b      	ldr	r3, [r7, #16]
10041380:	4313      	orrs	r3, r2
10041382:	613b      	str	r3, [r7, #16]
10041384:	e012      	b.n	100413ac <HAL_GPIO_Init+0x24c>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041386:	2201      	movs	r2, #1
10041388:	697b      	ldr	r3, [r7, #20]
1004138a:	409a      	lsls	r2, r3
1004138c:	0013      	movs	r3, r2
1004138e:	041b      	lsls	r3, r3, #16
10041390:	43db      	mvns	r3, r3
10041392:	001a      	movs	r2, r3
10041394:	693b      	ldr	r3, [r7, #16]
10041396:	4013      	ands	r3, r2
10041398:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
1004139a:	2201      	movs	r2, #1
1004139c:	697b      	ldr	r3, [r7, #20]
1004139e:	409a      	lsls	r2, r3
100413a0:	0013      	movs	r3, r2
100413a2:	041b      	lsls	r3, r3, #16
100413a4:	001a      	movs	r2, r3
100413a6:	693b      	ldr	r3, [r7, #16]
100413a8:	4313      	orrs	r3, r2
100413aa:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IBER= temp;
100413ac:	2380      	movs	r3, #128	@ 0x80
100413ae:	05db      	lsls	r3, r3, #23
100413b0:	693a      	ldr	r2, [r7, #16]
100413b2:	611a      	str	r2, [r3, #16]
        }

        /* Trigger mode configuration */
		if ((GPIO_Init->Mode & TRIGGER_MODE) != 0x00u)
100413b4:	683b      	ldr	r3, [r7, #0]
100413b6:	685a      	ldr	r2, [r3, #4]
100413b8:	2380      	movs	r3, #128	@ 0x80
100413ba:	03db      	lsls	r3, r3, #15
100413bc:	4013      	ands	r3, r2
100413be:	d031      	beq.n	10041424 <HAL_GPIO_Init+0x2c4>
        {
          temp = SYSCFG->IO_IEVR;
100413c0:	2380      	movs	r3, #128	@ 0x80
100413c2:	05db      	lsls	r3, r3, #23
100413c4:	695b      	ldr	r3, [r3, #20]
100413c6:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
100413c8:	687a      	ldr	r2, [r7, #4]
100413ca:	2390      	movs	r3, #144	@ 0x90
100413cc:	05db      	lsls	r3, r3, #23
100413ce:	429a      	cmp	r2, r3
100413d0:	d111      	bne.n	100413f6 <HAL_GPIO_Init+0x296>
          {
            temp &= ~(1 << position);
100413d2:	2201      	movs	r2, #1
100413d4:	697b      	ldr	r3, [r7, #20]
100413d6:	409a      	lsls	r2, r3
100413d8:	0013      	movs	r3, r2
100413da:	43db      	mvns	r3, r3
100413dc:	001a      	movs	r2, r3
100413de:	693b      	ldr	r3, [r7, #16]
100413e0:	4013      	ands	r3, r2
100413e2:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
100413e4:	2201      	movs	r2, #1
100413e6:	697b      	ldr	r3, [r7, #20]
100413e8:	409a      	lsls	r2, r3
100413ea:	0013      	movs	r3, r2
100413ec:	001a      	movs	r2, r3
100413ee:	693b      	ldr	r3, [r7, #16]
100413f0:	4313      	orrs	r3, r2
100413f2:	613b      	str	r3, [r7, #16]
100413f4:	e012      	b.n	1004141c <HAL_GPIO_Init+0x2bc>
          }
          else
          {
            temp &= ~((1 << position) << 16);
100413f6:	2201      	movs	r2, #1
100413f8:	697b      	ldr	r3, [r7, #20]
100413fa:	409a      	lsls	r2, r3
100413fc:	0013      	movs	r3, r2
100413fe:	041b      	lsls	r3, r3, #16
10041400:	43db      	mvns	r3, r3
10041402:	001a      	movs	r2, r3
10041404:	693b      	ldr	r3, [r7, #16]
10041406:	4013      	ands	r3, r2
10041408:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
1004140a:	2201      	movs	r2, #1
1004140c:	697b      	ldr	r3, [r7, #20]
1004140e:	409a      	lsls	r2, r3
10041410:	0013      	movs	r3, r2
10041412:	041b      	lsls	r3, r3, #16
10041414:	001a      	movs	r2, r3
10041416:	693b      	ldr	r3, [r7, #16]
10041418:	4313      	orrs	r3, r2
1004141a:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IEVR= temp;
1004141c:	2380      	movs	r3, #128	@ 0x80
1004141e:	05db      	lsls	r3, r3, #23
10041420:	693a      	ldr	r2, [r7, #16]
10041422:	615a      	str	r2, [r3, #20]
        }

        /* Enable the specified EXTI interrupt line */
        if ((GPIO_Init->Mode & EXTI_IT) == EXTI_IT)
10041424:	683b      	ldr	r3, [r7, #0]
10041426:	685a      	ldr	r2, [r3, #4]
10041428:	2380      	movs	r3, #128	@ 0x80
1004142a:	025b      	lsls	r3, r3, #9
1004142c:	4013      	ands	r3, r2
1004142e:	d031      	beq.n	10041494 <HAL_GPIO_Init+0x334>
        {
          temp = SYSCFG->IO_IER;
10041430:	2380      	movs	r3, #128	@ 0x80
10041432:	05db      	lsls	r3, r3, #23
10041434:	699b      	ldr	r3, [r3, #24]
10041436:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041438:	687a      	ldr	r2, [r7, #4]
1004143a:	2390      	movs	r3, #144	@ 0x90
1004143c:	05db      	lsls	r3, r3, #23
1004143e:	429a      	cmp	r2, r3
10041440:	d111      	bne.n	10041466 <HAL_GPIO_Init+0x306>
          {
            temp &= ~(1 << position);
10041442:	2201      	movs	r2, #1
10041444:	697b      	ldr	r3, [r7, #20]
10041446:	409a      	lsls	r2, r3
10041448:	0013      	movs	r3, r2
1004144a:	43db      	mvns	r3, r3
1004144c:	001a      	movs	r2, r3
1004144e:	693b      	ldr	r3, [r7, #16]
10041450:	4013      	ands	r3, r2
10041452:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041454:	2201      	movs	r2, #1
10041456:	697b      	ldr	r3, [r7, #20]
10041458:	409a      	lsls	r2, r3
1004145a:	0013      	movs	r3, r2
1004145c:	001a      	movs	r2, r3
1004145e:	693b      	ldr	r3, [r7, #16]
10041460:	4313      	orrs	r3, r2
10041462:	613b      	str	r3, [r7, #16]
10041464:	e012      	b.n	1004148c <HAL_GPIO_Init+0x32c>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041466:	2201      	movs	r2, #1
10041468:	697b      	ldr	r3, [r7, #20]
1004146a:	409a      	lsls	r2, r3
1004146c:	0013      	movs	r3, r2
1004146e:	041b      	lsls	r3, r3, #16
10041470:	43db      	mvns	r3, r3
10041472:	001a      	movs	r2, r3
10041474:	693b      	ldr	r3, [r7, #16]
10041476:	4013      	ands	r3, r2
10041478:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
1004147a:	2201      	movs	r2, #1
1004147c:	697b      	ldr	r3, [r7, #20]
1004147e:	409a      	lsls	r2, r3
10041480:	0013      	movs	r3, r2
10041482:	041b      	lsls	r3, r3, #16
10041484:	001a      	movs	r2, r3
10041486:	693b      	ldr	r3, [r7, #16]
10041488:	4313      	orrs	r3, r2
1004148a:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IER= temp;
1004148c:	2380      	movs	r3, #128	@ 0x80
1004148e:	05db      	lsls	r3, r3, #23
10041490:	693a      	ldr	r2, [r7, #16]
10041492:	619a      	str	r2, [r3, #24]
        }
      }
    }

    position++;
10041494:	697b      	ldr	r3, [r7, #20]
10041496:	3301      	adds	r3, #1
10041498:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
1004149a:	683b      	ldr	r3, [r7, #0]
1004149c:	681a      	ldr	r2, [r3, #0]
1004149e:	697b      	ldr	r3, [r7, #20]
100414a0:	40da      	lsrs	r2, r3
100414a2:	1e13      	subs	r3, r2, #0
100414a4:	d000      	beq.n	100414a8 <HAL_GPIO_Init+0x348>
100414a6:	e663      	b.n	10041170 <HAL_GPIO_Init+0x10>
  }
}
100414a8:	46c0      	nop			@ (mov r8, r8)
100414aa:	46c0      	nop			@ (mov r8, r8)
100414ac:	46bd      	mov	sp, r7
100414ae:	b006      	add	sp, #24
100414b0:	bd80      	pop	{r7, pc}

100414b2 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
100414b2:	b580      	push	{r7, lr}
100414b4:	b082      	sub	sp, #8
100414b6:	af00      	add	r7, sp, #0
100414b8:	6078      	str	r0, [r7, #4]
100414ba:	0008      	movs	r0, r1
100414bc:	0011      	movs	r1, r2
100414be:	1cbb      	adds	r3, r7, #2
100414c0:	1c02      	adds	r2, r0, #0
100414c2:	801a      	strh	r2, [r3, #0]
100414c4:	1c7b      	adds	r3, r7, #1
100414c6:	1c0a      	adds	r2, r1, #0
100414c8:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
100414ca:	1c7b      	adds	r3, r7, #1
100414cc:	781b      	ldrb	r3, [r3, #0]
100414ce:	2b00      	cmp	r3, #0
100414d0:	d004      	beq.n	100414dc <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
100414d2:	1cbb      	adds	r3, r7, #2
100414d4:	881a      	ldrh	r2, [r3, #0]
100414d6:	687b      	ldr	r3, [r7, #4]
100414d8:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
100414da:	e003      	b.n	100414e4 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
100414dc:	1cbb      	adds	r3, r7, #2
100414de:	881a      	ldrh	r2, [r3, #0]
100414e0:	687b      	ldr	r3, [r7, #4]
100414e2:	629a      	str	r2, [r3, #40]	@ 0x28
}
100414e4:	46c0      	nop			@ (mov r8, r8)
100414e6:	46bd      	mov	sp, r7
100414e8:	b002      	add	sp, #8
100414ea:	bd80      	pop	{r7, pc}

100414ec <HAL_GPIO_TogglePin>:
  * @param GPIOx where x can be (A..B) to select the GPIO peripheral for STM32WB0x family
  * @param GPIO_Pin specifies the pin to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
100414ec:	b580      	push	{r7, lr}
100414ee:	b084      	sub	sp, #16
100414f0:	af00      	add	r7, sp, #0
100414f2:	6078      	str	r0, [r7, #4]
100414f4:	000a      	movs	r2, r1
100414f6:	1cbb      	adds	r3, r7, #2
100414f8:	801a      	strh	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
100414fa:	687b      	ldr	r3, [r7, #4]
100414fc:	695b      	ldr	r3, [r3, #20]
100414fe:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
10041500:	1cbb      	adds	r3, r7, #2
10041502:	881b      	ldrh	r3, [r3, #0]
10041504:	68fa      	ldr	r2, [r7, #12]
10041506:	4013      	ands	r3, r2
10041508:	041a      	lsls	r2, r3, #16
1004150a:	68fb      	ldr	r3, [r7, #12]
1004150c:	43db      	mvns	r3, r3
1004150e:	1cb9      	adds	r1, r7, #2
10041510:	8809      	ldrh	r1, [r1, #0]
10041512:	400b      	ands	r3, r1
10041514:	431a      	orrs	r2, r3
10041516:	687b      	ldr	r3, [r7, #4]
10041518:	619a      	str	r2, [r3, #24]
}
1004151a:	46c0      	nop			@ (mov r8, r8)
1004151c:	46bd      	mov	sp, r7
1004151e:	b004      	add	sp, #16
10041520:	bd80      	pop	{r7, pc}
	...

10041524 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
10041524:	b580      	push	{r7, lr}
10041526:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
10041528:	4b07      	ldr	r3, [pc, #28]	@ (10041548 <LL_RCC_HSE_IsReady+0x24>)
1004152a:	681a      	ldr	r2, [r3, #0]
1004152c:	2380      	movs	r3, #128	@ 0x80
1004152e:	029b      	lsls	r3, r3, #10
10041530:	401a      	ands	r2, r3
10041532:	2380      	movs	r3, #128	@ 0x80
10041534:	029b      	lsls	r3, r3, #10
10041536:	429a      	cmp	r2, r3
10041538:	d101      	bne.n	1004153e <LL_RCC_HSE_IsReady+0x1a>
1004153a:	2301      	movs	r3, #1
1004153c:	e000      	b.n	10041540 <LL_RCC_HSE_IsReady+0x1c>
1004153e:	2300      	movs	r3, #0
}
10041540:	0018      	movs	r0, r3
10041542:	46bd      	mov	sp, r7
10041544:	bd80      	pop	{r7, pc}
10041546:	46c0      	nop			@ (mov r8, r8)
10041548:	48400000 	.word	0x48400000

1004154c <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
1004154c:	b580      	push	{r7, lr}
1004154e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
10041550:	4b07      	ldr	r3, [pc, #28]	@ (10041570 <LL_RCC_HSI_Enable+0x24>)
10041552:	689a      	ldr	r2, [r3, #8]
10041554:	4b06      	ldr	r3, [pc, #24]	@ (10041570 <LL_RCC_HSI_Enable+0x24>)
10041556:	2104      	movs	r1, #4
10041558:	438a      	bics	r2, r1
1004155a:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
1004155c:	4b04      	ldr	r3, [pc, #16]	@ (10041570 <LL_RCC_HSI_Enable+0x24>)
1004155e:	689a      	ldr	r2, [r3, #8]
10041560:	4b03      	ldr	r3, [pc, #12]	@ (10041570 <LL_RCC_HSI_Enable+0x24>)
10041562:	2102      	movs	r1, #2
10041564:	438a      	bics	r2, r1
10041566:	609a      	str	r2, [r3, #8]
}
10041568:	46c0      	nop			@ (mov r8, r8)
1004156a:	46bd      	mov	sp, r7
1004156c:	bd80      	pop	{r7, pc}
1004156e:	46c0      	nop			@ (mov r8, r8)
10041570:	48400000 	.word	0x48400000

10041574 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
10041574:	b580      	push	{r7, lr}
10041576:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
10041578:	4b07      	ldr	r3, [pc, #28]	@ (10041598 <LL_RCC_HSI_IsReady+0x24>)
1004157a:	681a      	ldr	r2, [r3, #0]
1004157c:	2380      	movs	r3, #128	@ 0x80
1004157e:	00db      	lsls	r3, r3, #3
10041580:	401a      	ands	r2, r3
10041582:	2380      	movs	r3, #128	@ 0x80
10041584:	00db      	lsls	r3, r3, #3
10041586:	429a      	cmp	r2, r3
10041588:	d101      	bne.n	1004158e <LL_RCC_HSI_IsReady+0x1a>
1004158a:	2301      	movs	r3, #1
1004158c:	e000      	b.n	10041590 <LL_RCC_HSI_IsReady+0x1c>
1004158e:	2300      	movs	r3, #0
}
10041590:	0018      	movs	r0, r3
10041592:	46bd      	mov	sp, r7
10041594:	bd80      	pop	{r7, pc}
10041596:	46c0      	nop			@ (mov r8, r8)
10041598:	48400000 	.word	0x48400000

1004159c <LL_RCC_DIRECT_HSE_Enable>:
  * @brief  Enable DIRECT_HSE mode
  * @rmtoll CFGR       HSESEL/STOPHSI         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_DIRECT_HSE_Enable(void)
{
1004159c:	b580      	push	{r7, lr}
1004159e:	b082      	sub	sp, #8
100415a0:	af00      	add	r7, sp, #0
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0);
100415a2:	46c0      	nop			@ (mov r8, r8)
100415a4:	4b0f      	ldr	r3, [pc, #60]	@ (100415e4 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100415a6:	681a      	ldr	r2, [r3, #0]
100415a8:	2380      	movs	r3, #128	@ 0x80
100415aa:	029b      	lsls	r3, r3, #10
100415ac:	4013      	ands	r3, r2
100415ae:	d0f9      	beq.n	100415a4 <LL_RCC_DIRECT_HSE_Enable+0x8>
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
100415b0:	4b0c      	ldr	r3, [pc, #48]	@ (100415e4 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100415b2:	689a      	ldr	r2, [r3, #8]
100415b4:	4b0b      	ldr	r3, [pc, #44]	@ (100415e4 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100415b6:	2102      	movs	r1, #2
100415b8:	430a      	orrs	r2, r1
100415ba:	609a      	str	r2, [r3, #8]
  for (volatile int i = 0; i < 6; i++)
100415bc:	2300      	movs	r3, #0
100415be:	607b      	str	r3, [r7, #4]
100415c0:	e003      	b.n	100415ca <LL_RCC_DIRECT_HSE_Enable+0x2e>
  {
    __asm("NOP");
100415c2:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
100415c4:	687b      	ldr	r3, [r7, #4]
100415c6:	3301      	adds	r3, #1
100415c8:	607b      	str	r3, [r7, #4]
100415ca:	687b      	ldr	r3, [r7, #4]
100415cc:	2b05      	cmp	r3, #5
100415ce:	ddf8      	ble.n	100415c2 <LL_RCC_DIRECT_HSE_Enable+0x26>
  }
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
100415d0:	4b04      	ldr	r3, [pc, #16]	@ (100415e4 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100415d2:	689a      	ldr	r2, [r3, #8]
100415d4:	4b03      	ldr	r3, [pc, #12]	@ (100415e4 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100415d6:	2104      	movs	r1, #4
100415d8:	430a      	orrs	r2, r1
100415da:	609a      	str	r2, [r3, #8]
}
100415dc:	46c0      	nop			@ (mov r8, r8)
100415de:	46bd      	mov	sp, r7
100415e0:	b002      	add	sp, #8
100415e2:	bd80      	pop	{r7, pc}
100415e4:	48400000 	.word	0x48400000

100415e8 <LL_RCC_RC64MPLL_Enable>:
  * @brief  Enable RC64MPLL
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Enable(void)
{
100415e8:	b580      	push	{r7, lr}
100415ea:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSIPLLON);
100415ec:	4b04      	ldr	r3, [pc, #16]	@ (10041600 <LL_RCC_RC64MPLL_Enable+0x18>)
100415ee:	681a      	ldr	r2, [r3, #0]
100415f0:	4b03      	ldr	r3, [pc, #12]	@ (10041600 <LL_RCC_RC64MPLL_Enable+0x18>)
100415f2:	2180      	movs	r1, #128	@ 0x80
100415f4:	0189      	lsls	r1, r1, #6
100415f6:	430a      	orrs	r2, r1
100415f8:	601a      	str	r2, [r3, #0]
}
100415fa:	46c0      	nop			@ (mov r8, r8)
100415fc:	46bd      	mov	sp, r7
100415fe:	bd80      	pop	{r7, pc}
10041600:	48400000 	.word	0x48400000

10041604 <LL_RCC_RC64MPLL_Disable>:
  * @note Cannot be disabled if the RC64MPLL clock is used as the system clock
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Disable(void)
{
10041604:	b580      	push	{r7, lr}
10041606:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSIPLLON);
10041608:	4b04      	ldr	r3, [pc, #16]	@ (1004161c <LL_RCC_RC64MPLL_Disable+0x18>)
1004160a:	681a      	ldr	r2, [r3, #0]
1004160c:	4b03      	ldr	r3, [pc, #12]	@ (1004161c <LL_RCC_RC64MPLL_Disable+0x18>)
1004160e:	4904      	ldr	r1, [pc, #16]	@ (10041620 <LL_RCC_RC64MPLL_Disable+0x1c>)
10041610:	400a      	ands	r2, r1
10041612:	601a      	str	r2, [r3, #0]
}
10041614:	46c0      	nop			@ (mov r8, r8)
10041616:	46bd      	mov	sp, r7
10041618:	bd80      	pop	{r7, pc}
1004161a:	46c0      	nop			@ (mov r8, r8)
1004161c:	48400000 	.word	0x48400000
10041620:	ffffdfff 	.word	0xffffdfff

10041624 <LL_RCC_RC64MPLL_IsReady>:
  * @brief  Check if RC64MPLL is Ready
  * @rmtoll CR           HSIPLLRDY        LL_RCC_RC64MPLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_RC64MPLL_IsReady(void)
{
10041624:	b580      	push	{r7, lr}
10041626:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
10041628:	4b07      	ldr	r3, [pc, #28]	@ (10041648 <LL_RCC_RC64MPLL_IsReady+0x24>)
1004162a:	681a      	ldr	r2, [r3, #0]
1004162c:	2380      	movs	r3, #128	@ 0x80
1004162e:	01db      	lsls	r3, r3, #7
10041630:	401a      	ands	r2, r3
10041632:	2380      	movs	r3, #128	@ 0x80
10041634:	01db      	lsls	r3, r3, #7
10041636:	429a      	cmp	r2, r3
10041638:	d101      	bne.n	1004163e <LL_RCC_RC64MPLL_IsReady+0x1a>
1004163a:	2301      	movs	r3, #1
1004163c:	e000      	b.n	10041640 <LL_RCC_RC64MPLL_IsReady+0x1c>
1004163e:	2300      	movs	r3, #0
}
10041640:	0018      	movs	r0, r3
10041642:	46bd      	mov	sp, r7
10041644:	bd80      	pop	{r7, pc}
10041646:	46c0      	nop			@ (mov r8, r8)
10041648:	48400000 	.word	0x48400000

1004164c <LL_RCC_SetRC64MPLLPrescaler>:
  *         @arg @ref LL_RCC_RC64MPLL_DIV_32
  *         @arg @ref LL_RCC_RC64MPLL_DIV_64
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRC64MPLLPrescaler(uint32_t Prescaler)
{
1004164c:	b580      	push	{r7, lr}
1004164e:	b082      	sub	sp, #8
10041650:	af00      	add	r7, sp, #0
10041652:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSYSDIV, Prescaler);
10041654:	4b06      	ldr	r3, [pc, #24]	@ (10041670 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10041656:	689b      	ldr	r3, [r3, #8]
10041658:	22e0      	movs	r2, #224	@ 0xe0
1004165a:	4393      	bics	r3, r2
1004165c:	0019      	movs	r1, r3
1004165e:	4b04      	ldr	r3, [pc, #16]	@ (10041670 <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10041660:	687a      	ldr	r2, [r7, #4]
10041662:	430a      	orrs	r2, r1
10041664:	609a      	str	r2, [r3, #8]
}
10041666:	46c0      	nop			@ (mov r8, r8)
10041668:	46bd      	mov	sp, r7
1004166a:	b002      	add	sp, #8
1004166c:	bd80      	pop	{r7, pc}
1004166e:	46c0      	nop			@ (mov r8, r8)
10041670:	48400000 	.word	0x48400000

10041674 <HAL_RCC_ClockConfig>:
  *         currently used as system clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
10041674:	b580      	push	{r7, lr}
10041676:	b084      	sub	sp, #16
10041678:	af00      	add	r7, sp, #0
1004167a:	6078      	str	r0, [r7, #4]
1004167c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
1004167e:	687b      	ldr	r3, [r7, #4]
10041680:	2b00      	cmp	r3, #0
10041682:	d101      	bne.n	10041688 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
10041684:	2301      	movs	r3, #1
10041686:	e098      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>

  /* Check the parameters */
  assert_param(IS_FLASH_WAIT_STATES(FLatency));

  /* Set FALSH_WAIT_STATES_1 */
  __HAL_FLASH_SET_WAIT_STATES(FLatency);
10041688:	4b4e      	ldr	r3, [pc, #312]	@ (100417c4 <HAL_RCC_ClockConfig+0x150>)
1004168a:	685b      	ldr	r3, [r3, #4]
1004168c:	2230      	movs	r2, #48	@ 0x30
1004168e:	4393      	bics	r3, r2
10041690:	0019      	movs	r1, r3
10041692:	4b4c      	ldr	r3, [pc, #304]	@ (100417c4 <HAL_RCC_ClockConfig+0x150>)
10041694:	683a      	ldr	r2, [r7, #0]
10041696:	430a      	orrs	r2, r1
10041698:	605a      	str	r2, [r3, #4]
  /*------------------------- SYSCLK Configuration ---------------------------*/
  assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
  assert_param(IS_RCC_SYSCLK_DIVIDER(RCC_ClkInitStruct->SYSCLKDivider));

  /* HSI is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
1004169a:	687b      	ldr	r3, [r7, #4]
1004169c:	681b      	ldr	r3, [r3, #0]
1004169e:	2b02      	cmp	r3, #2
100416a0:	d10e      	bne.n	100416c0 <HAL_RCC_ClockConfig+0x4c>
  {
    LL_RCC_HSI_Enable();
100416a2:	f7ff ff53 	bl	1004154c <LL_RCC_HSI_Enable>
    
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
100416a6:	f7ff ff65 	bl	10041574 <LL_RCC_HSI_IsReady>
100416aa:	1e03      	subs	r3, r0, #0
100416ac:	d101      	bne.n	100416b2 <HAL_RCC_ClockConfig+0x3e>
    {
      return HAL_ERROR;
100416ae:	2301      	movs	r3, #1
100416b0:	e083      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    }

    /* Disable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_DISABLE();
100416b2:	f7ff ffa7 	bl	10041604 <LL_RCC_RC64MPLL_Disable>
    
    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
100416b6:	687b      	ldr	r3, [r7, #4]
100416b8:	685b      	ldr	r3, [r3, #4]
100416ba:	0018      	movs	r0, r3
100416bc:	f7ff ffc6 	bl	1004164c <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* RC64MPLL is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_RC64MPLL)
100416c0:	687b      	ldr	r3, [r7, #4]
100416c2:	681b      	ldr	r3, [r3, #0]
100416c4:	2b00      	cmp	r3, #0
100416c6:	d124      	bne.n	10041712 <HAL_RCC_ClockConfig+0x9e>
  {
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
100416c8:	f7ff ff54 	bl	10041574 <LL_RCC_HSI_IsReady>
100416cc:	1e03      	subs	r3, r0, #0
100416ce:	d101      	bne.n	100416d4 <HAL_RCC_ClockConfig+0x60>
    {
      return HAL_ERROR;
100416d0:	2301      	movs	r3, #1
100416d2:	e072      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
100416d4:	f7ff ff26 	bl	10041524 <LL_RCC_HSE_IsReady>
100416d8:	1e03      	subs	r3, r0, #0
100416da:	d101      	bne.n	100416e0 <HAL_RCC_ClockConfig+0x6c>
    {
      return HAL_ERROR;
100416dc:	2301      	movs	r3, #1
100416de:	e06c      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    }

    /* Enable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_ENABLE();
100416e0:	f7ff ff82 	bl	100415e8 <LL_RCC_RC64MPLL_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
100416e4:	f7ff fc50 	bl	10040f88 <HAL_GetTick>
100416e8:	0003      	movs	r3, r0
100416ea:	60fb      	str	r3, [r7, #12]

    /* Wait till RC64MPLL is ready */
    while (LL_RCC_RC64MPLL_IsReady() == 0)
100416ec:	e008      	b.n	10041700 <HAL_RCC_ClockConfig+0x8c>
    {
      if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
100416ee:	f7ff fc4b 	bl	10040f88 <HAL_GetTick>
100416f2:	0002      	movs	r2, r0
100416f4:	68fb      	ldr	r3, [r7, #12]
100416f6:	1ad3      	subs	r3, r2, r3
100416f8:	2b02      	cmp	r3, #2
100416fa:	d901      	bls.n	10041700 <HAL_RCC_ClockConfig+0x8c>
      {
        return HAL_TIMEOUT;
100416fc:	2303      	movs	r3, #3
100416fe:	e05c      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    while (LL_RCC_RC64MPLL_IsReady() == 0)
10041700:	f7ff ff90 	bl	10041624 <LL_RCC_RC64MPLL_IsReady>
10041704:	1e03      	subs	r3, r0, #0
10041706:	d0f2      	beq.n	100416ee <HAL_RCC_ClockConfig+0x7a>
      }
    }

    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10041708:	687b      	ldr	r3, [r7, #4]
1004170a:	685b      	ldr	r3, [r3, #4]
1004170c:	0018      	movs	r0, r3
1004170e:	f7ff ff9d 	bl	1004164c <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* DIRECT_HSE is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_DIRECT_HSE)
10041712:	687b      	ldr	r3, [r7, #4]
10041714:	681b      	ldr	r3, [r3, #0]
10041716:	2b01      	cmp	r3, #1
10041718:	d117      	bne.n	1004174a <HAL_RCC_ClockConfig+0xd6>
  {
    /* Enable the DIRECT_HSE configuration */
    LL_RCC_DIRECT_HSE_Enable();
1004171a:	f7ff ff3f 	bl	1004159c <LL_RCC_DIRECT_HSE_Enable>

    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() != 0U)
1004171e:	f7ff ff29 	bl	10041574 <LL_RCC_HSI_IsReady>
10041722:	1e03      	subs	r3, r0, #0
10041724:	d001      	beq.n	1004172a <HAL_RCC_ClockConfig+0xb6>
    {
      return HAL_ERROR;
10041726:	2301      	movs	r3, #1
10041728:	e047      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
1004172a:	f7ff fefb 	bl	10041524 <LL_RCC_HSE_IsReady>
1004172e:	1e03      	subs	r3, r0, #0
10041730:	d101      	bne.n	10041736 <HAL_RCC_ClockConfig+0xc2>
    {
      return HAL_ERROR;
10041732:	2301      	movs	r3, #1
10041734:	e041      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    }

    /* Configure the DIRECT_HSE multiplication factor */
    __HAL_RCC_DIRECT_HSE_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10041736:	4b24      	ldr	r3, [pc, #144]	@ (100417c8 <HAL_RCC_ClockConfig+0x154>)
10041738:	689b      	ldr	r3, [r3, #8]
1004173a:	22e0      	movs	r2, #224	@ 0xe0
1004173c:	4393      	bics	r3, r2
1004173e:	0019      	movs	r1, r3
10041740:	687b      	ldr	r3, [r7, #4]
10041742:	685a      	ldr	r2, [r3, #4]
10041744:	4b20      	ldr	r3, [pc, #128]	@ (100417c8 <HAL_RCC_ClockConfig+0x154>)
10041746:	430a      	orrs	r2, r1
10041748:	609a      	str	r2, [r3, #8]
  /*----------------------- FLASH Latency Configuration ------------------------*/
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the FLASH clock */

  /* Setup flash wait states because according the system clock frequency */
  if (FLatency != __HAL_FLASH_GET_WAIT_STATES())
1004174a:	4b1e      	ldr	r3, [pc, #120]	@ (100417c4 <HAL_RCC_ClockConfig+0x150>)
1004174c:	685b      	ldr	r3, [r3, #4]
1004174e:	2230      	movs	r2, #48	@ 0x30
10041750:	4013      	ands	r3, r2
10041752:	683a      	ldr	r2, [r7, #0]
10041754:	429a      	cmp	r2, r3
10041756:	d01d      	beq.n	10041794 <HAL_RCC_ClockConfig+0x120>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_CONFIG register */
    __HAL_FLASH_SET_WAIT_STATES(FLatency);
10041758:	4b1a      	ldr	r3, [pc, #104]	@ (100417c4 <HAL_RCC_ClockConfig+0x150>)
1004175a:	685b      	ldr	r3, [r3, #4]
1004175c:	2230      	movs	r2, #48	@ 0x30
1004175e:	4393      	bics	r3, r2
10041760:	0019      	movs	r1, r3
10041762:	4b18      	ldr	r3, [pc, #96]	@ (100417c4 <HAL_RCC_ClockConfig+0x150>)
10041764:	683a      	ldr	r2, [r7, #0]
10041766:	430a      	orrs	r2, r1
10041768:	605a      	str	r2, [r3, #4]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
1004176a:	f7ff fc0d 	bl	10040f88 <HAL_GetTick>
1004176e:	0003      	movs	r3, r0
10041770:	60fb      	str	r3, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_CONFIG register */
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
10041772:	e008      	b.n	10041786 <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
10041774:	f7ff fc08 	bl	10040f88 <HAL_GetTick>
10041778:	0002      	movs	r2, r0
1004177a:	68fb      	ldr	r3, [r7, #12]
1004177c:	1ad3      	subs	r3, r2, r3
1004177e:	2b02      	cmp	r3, #2
10041780:	d901      	bls.n	10041786 <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
10041782:	2303      	movs	r3, #3
10041784:	e019      	b.n	100417ba <HAL_RCC_ClockConfig+0x146>
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
10041786:	4b0f      	ldr	r3, [pc, #60]	@ (100417c4 <HAL_RCC_ClockConfig+0x150>)
10041788:	685b      	ldr	r3, [r3, #4]
1004178a:	2230      	movs	r2, #48	@ 0x30
1004178c:	4013      	ands	r3, r2
1004178e:	683a      	ldr	r2, [r7, #0]
10041790:	429a      	cmp	r2, r3
10041792:	d1ef      	bne.n	10041774 <HAL_RCC_ClockConfig+0x100>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  for (volatile int i = 0; i < 6; i++)
10041794:	2300      	movs	r3, #0
10041796:	60bb      	str	r3, [r7, #8]
10041798:	e003      	b.n	100417a2 <HAL_RCC_ClockConfig+0x12e>
  {
    __asm("NOP");
1004179a:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
1004179c:	68bb      	ldr	r3, [r7, #8]
1004179e:	3301      	adds	r3, #1
100417a0:	60bb      	str	r3, [r7, #8]
100417a2:	68bb      	ldr	r3, [r7, #8]
100417a4:	2b05      	cmp	r3, #5
100417a6:	ddf8      	ble.n	1004179a <HAL_RCC_ClockConfig+0x126>
  }
  SystemCoreClockUpdate();
100417a8:	f7ff fa40 	bl	10040c2c <SystemCoreClockUpdate>

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
100417ac:	f7ff fbf6 	bl	10040f9c <HAL_GetTickPrio>
100417b0:	0003      	movs	r3, r0
100417b2:	0018      	movs	r0, r3
100417b4:	f7ff fb8e 	bl	10040ed4 <HAL_InitTick>
100417b8:	0003      	movs	r3, r0
}
100417ba:	0018      	movs	r0, r3
100417bc:	46bd      	mov	sp, r7
100417be:	b004      	add	sp, #16
100417c0:	bd80      	pop	{r7, pc}
100417c2:	46c0      	nop			@ (mov r8, r8)
100417c4:	40001000 	.word	0x40001000
100417c8:	48400000 	.word	0x48400000

100417cc <HAL_RCC_GetSysClockFreq>:
  *         content of the SystemCoreClock CMSIS variable
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
100417cc:	b580      	push	{r7, lr}
100417ce:	af00      	add	r7, sp, #0
  return SystemCoreClock;
100417d0:	4b02      	ldr	r3, [pc, #8]	@ (100417dc <HAL_RCC_GetSysClockFreq+0x10>)
100417d2:	681b      	ldr	r3, [r3, #0]
}
100417d4:	0018      	movs	r0, r3
100417d6:	46bd      	mov	sp, r7
100417d8:	bd80      	pop	{r7, pc}
100417da:	46c0      	nop			@ (mov r8, r8)
100417dc:	20000158 	.word	0x20000158

100417e0 <LL_RCC_HSE_IsReady>:
{
100417e0:	b580      	push	{r7, lr}
100417e2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
100417e4:	4b07      	ldr	r3, [pc, #28]	@ (10041804 <LL_RCC_HSE_IsReady+0x24>)
100417e6:	681a      	ldr	r2, [r3, #0]
100417e8:	2380      	movs	r3, #128	@ 0x80
100417ea:	029b      	lsls	r3, r3, #10
100417ec:	401a      	ands	r2, r3
100417ee:	2380      	movs	r3, #128	@ 0x80
100417f0:	029b      	lsls	r3, r3, #10
100417f2:	429a      	cmp	r2, r3
100417f4:	d101      	bne.n	100417fa <LL_RCC_HSE_IsReady+0x1a>
100417f6:	2301      	movs	r3, #1
100417f8:	e000      	b.n	100417fc <LL_RCC_HSE_IsReady+0x1c>
100417fa:	2300      	movs	r3, #0
}
100417fc:	0018      	movs	r0, r3
100417fe:	46bd      	mov	sp, r7
10041800:	bd80      	pop	{r7, pc}
10041802:	46c0      	nop			@ (mov r8, r8)
10041804:	48400000 	.word	0x48400000

10041808 <LL_RCC_DIRECT_HSE_IsEnabled>:
{
10041808:	b580      	push	{r7, lr}
1004180a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HSESEL_STATUS) == (RCC_CFGR_HSESEL_STATUS)) ? 1UL : 0UL);
1004180c:	4b05      	ldr	r3, [pc, #20]	@ (10041824 <LL_RCC_DIRECT_HSE_IsEnabled+0x1c>)
1004180e:	689b      	ldr	r3, [r3, #8]
10041810:	2208      	movs	r2, #8
10041812:	4013      	ands	r3, r2
10041814:	2b08      	cmp	r3, #8
10041816:	d101      	bne.n	1004181c <LL_RCC_DIRECT_HSE_IsEnabled+0x14>
10041818:	2301      	movs	r3, #1
1004181a:	e000      	b.n	1004181e <LL_RCC_DIRECT_HSE_IsEnabled+0x16>
1004181c:	2300      	movs	r3, #0
}
1004181e:	0018      	movs	r0, r3
10041820:	46bd      	mov	sp, r7
10041822:	bd80      	pop	{r7, pc}
10041824:	48400000 	.word	0x48400000

10041828 <LL_RCC_LSCO_SetSource>:
{
10041828:	b580      	push	{r7, lr}
1004182a:	b082      	sub	sp, #8
1004182c:	af00      	add	r7, sp, #0
1004182e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
10041830:	4b06      	ldr	r3, [pc, #24]	@ (1004184c <LL_RCC_LSCO_SetSource+0x24>)
10041832:	689b      	ldr	r3, [r3, #8]
10041834:	4a06      	ldr	r2, [pc, #24]	@ (10041850 <LL_RCC_LSCO_SetSource+0x28>)
10041836:	4013      	ands	r3, r2
10041838:	0019      	movs	r1, r3
1004183a:	4b04      	ldr	r3, [pc, #16]	@ (1004184c <LL_RCC_LSCO_SetSource+0x24>)
1004183c:	687a      	ldr	r2, [r7, #4]
1004183e:	430a      	orrs	r2, r1
10041840:	609a      	str	r2, [r3, #8]
}
10041842:	46c0      	nop			@ (mov r8, r8)
10041844:	46bd      	mov	sp, r7
10041846:	b002      	add	sp, #8
10041848:	bd80      	pop	{r7, pc}
1004184a:	46c0      	nop			@ (mov r8, r8)
1004184c:	48400000 	.word	0x48400000
10041850:	fffe7fff 	.word	0xfffe7fff

10041854 <LL_RCC_LSCO_GetSource>:
{
10041854:	b580      	push	{r7, lr}
10041856:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_CLKSLOWSEL));
10041858:	4b03      	ldr	r3, [pc, #12]	@ (10041868 <LL_RCC_LSCO_GetSource+0x14>)
1004185a:	689a      	ldr	r2, [r3, #8]
1004185c:	23c0      	movs	r3, #192	@ 0xc0
1004185e:	025b      	lsls	r3, r3, #9
10041860:	4013      	ands	r3, r2
}
10041862:	0018      	movs	r0, r3
10041864:	46bd      	mov	sp, r7
10041866:	bd80      	pop	{r7, pc}
10041868:	48400000 	.word	0x48400000

1004186c <LL_RCC_SetRFClock>:
{
1004186c:	b580      	push	{r7, lr}
1004186e:	b082      	sub	sp, #8
10041870:	af00      	add	r7, sp, #0
10041872:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->APB2ENR, RCC_APB2ENR_CLKBLEDIV, Source);
10041874:	4b06      	ldr	r3, [pc, #24]	@ (10041890 <LL_RCC_SetRFClock+0x24>)
10041876:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
10041878:	2204      	movs	r2, #4
1004187a:	4393      	bics	r3, r2
1004187c:	0019      	movs	r1, r3
1004187e:	4b04      	ldr	r3, [pc, #16]	@ (10041890 <LL_RCC_SetRFClock+0x24>)
10041880:	687a      	ldr	r2, [r7, #4]
10041882:	430a      	orrs	r2, r1
10041884:	661a      	str	r2, [r3, #96]	@ 0x60
}
10041886:	46c0      	nop			@ (mov r8, r8)
10041888:	46bd      	mov	sp, r7
1004188a:	b002      	add	sp, #8
1004188c:	bd80      	pop	{r7, pc}
1004188e:	46c0      	nop			@ (mov r8, r8)
10041890:	48400000 	.word	0x48400000

10041894 <LL_RCC_GetRFClock>:
{
10041894:	b580      	push	{r7, lr}
10041896:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->APB2ENR, RCC_APB2ENR_CLKBLEDIV));
10041898:	4b03      	ldr	r3, [pc, #12]	@ (100418a8 <LL_RCC_GetRFClock+0x14>)
1004189a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
1004189c:	2204      	movs	r2, #4
1004189e:	4013      	ands	r3, r2
}
100418a0:	0018      	movs	r0, r3
100418a2:	46bd      	mov	sp, r7
100418a4:	bd80      	pop	{r7, pc}
100418a6:	46c0      	nop			@ (mov r8, r8)
100418a8:	48400000 	.word	0x48400000

100418ac <LL_RCC_SetSMPSPrescaler>:
{
100418ac:	b580      	push	{r7, lr}
100418ae:	b082      	sub	sp, #8
100418b0:	af00      	add	r7, sp, #0
100418b2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SMPSDIV, Prescaler);
100418b4:	4b06      	ldr	r3, [pc, #24]	@ (100418d0 <LL_RCC_SetSMPSPrescaler+0x24>)
100418b6:	689b      	ldr	r3, [r3, #8]
100418b8:	4a06      	ldr	r2, [pc, #24]	@ (100418d4 <LL_RCC_SetSMPSPrescaler+0x28>)
100418ba:	4013      	ands	r3, r2
100418bc:	0019      	movs	r1, r3
100418be:	4b04      	ldr	r3, [pc, #16]	@ (100418d0 <LL_RCC_SetSMPSPrescaler+0x24>)
100418c0:	687a      	ldr	r2, [r7, #4]
100418c2:	430a      	orrs	r2, r1
100418c4:	609a      	str	r2, [r3, #8]
}
100418c6:	46c0      	nop			@ (mov r8, r8)
100418c8:	46bd      	mov	sp, r7
100418ca:	b002      	add	sp, #8
100418cc:	bd80      	pop	{r7, pc}
100418ce:	46c0      	nop			@ (mov r8, r8)
100418d0:	48400000 	.word	0x48400000
100418d4:	ffffefff 	.word	0xffffefff

100418d8 <LL_RCC_GetSMPSPrescaler>:
{
100418d8:	b580      	push	{r7, lr}
100418da:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SMPSDIV));
100418dc:	4b03      	ldr	r3, [pc, #12]	@ (100418ec <LL_RCC_GetSMPSPrescaler+0x14>)
100418de:	689a      	ldr	r2, [r3, #8]
100418e0:	2380      	movs	r3, #128	@ 0x80
100418e2:	015b      	lsls	r3, r3, #5
100418e4:	4013      	ands	r3, r2
}
100418e6:	0018      	movs	r0, r3
100418e8:	46bd      	mov	sp, r7
100418ea:	bd80      	pop	{r7, pc}
100418ec:	48400000 	.word	0x48400000

100418f0 <LL_RCC_SetLPUARTClockSource>:
{
100418f0:	b580      	push	{r7, lr}
100418f2:	b082      	sub	sp, #8
100418f4:	af00      	add	r7, sp, #0
100418f6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_LPUCLKSEL, Source);
100418f8:	4b06      	ldr	r3, [pc, #24]	@ (10041914 <LL_RCC_SetLPUARTClockSource+0x24>)
100418fa:	689b      	ldr	r3, [r3, #8]
100418fc:	4a06      	ldr	r2, [pc, #24]	@ (10041918 <LL_RCC_SetLPUARTClockSource+0x28>)
100418fe:	4013      	ands	r3, r2
10041900:	0019      	movs	r1, r3
10041902:	4b04      	ldr	r3, [pc, #16]	@ (10041914 <LL_RCC_SetLPUARTClockSource+0x24>)
10041904:	687a      	ldr	r2, [r7, #4]
10041906:	430a      	orrs	r2, r1
10041908:	609a      	str	r2, [r3, #8]
}
1004190a:	46c0      	nop			@ (mov r8, r8)
1004190c:	46bd      	mov	sp, r7
1004190e:	b002      	add	sp, #8
10041910:	bd80      	pop	{r7, pc}
10041912:	46c0      	nop			@ (mov r8, r8)
10041914:	48400000 	.word	0x48400000
10041918:	ffffdfff 	.word	0xffffdfff

1004191c <LL_RCC_GetLPUARTClockSource>:
{
1004191c:	b580      	push	{r7, lr}
1004191e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_LPUCLKSEL));
10041920:	4b03      	ldr	r3, [pc, #12]	@ (10041930 <LL_RCC_GetLPUARTClockSource+0x14>)
10041922:	689a      	ldr	r2, [r3, #8]
10041924:	2380      	movs	r3, #128	@ 0x80
10041926:	019b      	lsls	r3, r3, #6
10041928:	4013      	ands	r3, r2
}
1004192a:	0018      	movs	r0, r3
1004192c:	46bd      	mov	sp, r7
1004192e:	bd80      	pop	{r7, pc}
10041930:	48400000 	.word	0x48400000

10041934 <LL_RCC_SetSPI3I2SClockSource>:
{
10041934:	b580      	push	{r7, lr}
10041936:	b082      	sub	sp, #8
10041938:	af00      	add	r7, sp, #0
1004193a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL, Source);
1004193c:	4b06      	ldr	r3, [pc, #24]	@ (10041958 <LL_RCC_SetSPI3I2SClockSource+0x24>)
1004193e:	689b      	ldr	r3, [r3, #8]
10041940:	4a06      	ldr	r2, [pc, #24]	@ (1004195c <LL_RCC_SetSPI3I2SClockSource+0x28>)
10041942:	4013      	ands	r3, r2
10041944:	0019      	movs	r1, r3
10041946:	4b04      	ldr	r3, [pc, #16]	@ (10041958 <LL_RCC_SetSPI3I2SClockSource+0x24>)
10041948:	687a      	ldr	r2, [r7, #4]
1004194a:	430a      	orrs	r2, r1
1004194c:	609a      	str	r2, [r3, #8]
}
1004194e:	46c0      	nop			@ (mov r8, r8)
10041950:	46bd      	mov	sp, r7
10041952:	b002      	add	sp, #8
10041954:	bd80      	pop	{r7, pc}
10041956:	46c0      	nop			@ (mov r8, r8)
10041958:	48400000 	.word	0x48400000
1004195c:	ff3fffff 	.word	0xff3fffff

10041960 <LL_RCC_GetSPI3I2SClockSource>:
{
10041960:	b580      	push	{r7, lr}
10041962:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL));
10041964:	4b03      	ldr	r3, [pc, #12]	@ (10041974 <LL_RCC_GetSPI3I2SClockSource+0x14>)
10041966:	689a      	ldr	r2, [r3, #8]
10041968:	23c0      	movs	r3, #192	@ 0xc0
1004196a:	041b      	lsls	r3, r3, #16
1004196c:	4013      	ands	r3, r2
}
1004196e:	0018      	movs	r0, r3
10041970:	46bd      	mov	sp, r7
10041972:	bd80      	pop	{r7, pc}
10041974:	48400000 	.word	0x48400000

10041978 <LL_RCC_RC64MPLL_IsReady>:
{
10041978:	b580      	push	{r7, lr}
1004197a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
1004197c:	4b07      	ldr	r3, [pc, #28]	@ (1004199c <LL_RCC_RC64MPLL_IsReady+0x24>)
1004197e:	681a      	ldr	r2, [r3, #0]
10041980:	2380      	movs	r3, #128	@ 0x80
10041982:	01db      	lsls	r3, r3, #7
10041984:	401a      	ands	r2, r3
10041986:	2380      	movs	r3, #128	@ 0x80
10041988:	01db      	lsls	r3, r3, #7
1004198a:	429a      	cmp	r2, r3
1004198c:	d101      	bne.n	10041992 <LL_RCC_RC64MPLL_IsReady+0x1a>
1004198e:	2301      	movs	r3, #1
10041990:	e000      	b.n	10041994 <LL_RCC_RC64MPLL_IsReady+0x1c>
10041992:	2300      	movs	r3, #0
}
10041994:	0018      	movs	r0, r3
10041996:	46bd      	mov	sp, r7
10041998:	bd80      	pop	{r7, pc}
1004199a:	46c0      	nop			@ (mov r8, r8)
1004199c:	48400000 	.word	0x48400000

100419a0 <HAL_RCCEx_PeriphCLKConfig>:
  *  @note   (*) Peripherals are not available on all devices
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
100419a0:	b580      	push	{r7, lr}
100419a2:	b082      	sub	sp, #8
100419a4:	af00      	add	r7, sp, #0
100419a6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RF_BLE clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RF) == RCC_PERIPHCLK_RF))
100419a8:	687b      	ldr	r3, [r7, #4]
100419aa:	681b      	ldr	r3, [r3, #0]
100419ac:	2201      	movs	r2, #1
100419ae:	4013      	ands	r3, r2
100419b0:	d004      	beq.n	100419bc <HAL_RCCEx_PeriphCLKConfig+0x1c>
  {
    assert_param(IS_RCC_RF_BLE_CLOCK_SOURCE(PeriphClkInit->RFClockSelection));
    __HAL_RCC_RF_CLK_SET_CONFIG(PeriphClkInit->RFClockSelection);
100419b2:	687b      	ldr	r3, [r7, #4]
100419b4:	691b      	ldr	r3, [r3, #16]
100419b6:	0018      	movs	r0, r3
100419b8:	f7ff ff58 	bl	1004186c <LL_RCC_SetRFClock>
  }

  /*-------------------------- SMPS clock configuration -------------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS))
100419bc:	687b      	ldr	r3, [r7, #4]
100419be:	681b      	ldr	r3, [r3, #0]
100419c0:	2202      	movs	r2, #2
100419c2:	4013      	ands	r3, r2
100419c4:	d004      	beq.n	100419d0 <HAL_RCCEx_PeriphCLKConfig+0x30>
  {
    assert_param(IS_RCC_SMPS_CLOCK_PRESC(PeriphClkInit->SmpsDivSelection));
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
100419c6:	687b      	ldr	r3, [r7, #4]
100419c8:	695b      	ldr	r3, [r3, #20]
100419ca:	0018      	movs	r0, r3
100419cc:	f7ff ff6e 	bl	100418ac <LL_RCC_SetSMPSPrescaler>
    __HAL_RCC_SPI2I2S_CLK_CONFIG(PeriphClkInit->SPI2I2SClockSelection);
  }
#endif
#if defined(SPI3)
  /*-------------------------- SPI3_I2S clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3_I2S) == RCC_PERIPHCLK_SPI3_I2S))
100419d0:	687b      	ldr	r3, [r7, #4]
100419d2:	681b      	ldr	r3, [r3, #0]
100419d4:	2208      	movs	r2, #8
100419d6:	4013      	ands	r3, r2
100419d8:	d004      	beq.n	100419e4 <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    assert_param(IS_RCC_SPI3I2S_CLOCK_SOURCE(PeriphClkInit->SPI3I2SClockSelection));
    __HAL_RCC_SPI3I2S_CLK_CONFIG(PeriphClkInit->SPI3I2SClockSelection);
100419da:	687b      	ldr	r3, [r7, #4]
100419dc:	685b      	ldr	r3, [r3, #4]
100419de:	0018      	movs	r0, r3
100419e0:	f7ff ffa8 	bl	10041934 <LL_RCC_SetSPI3I2SClockSource>
  }
#endif

#if defined(RCC_CFGR_LPUCLKSEL)
  /*-------------------------- LPUART1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1))
100419e4:	687b      	ldr	r3, [r7, #4]
100419e6:	681b      	ldr	r3, [r3, #0]
100419e8:	2210      	movs	r2, #16
100419ea:	4013      	ands	r3, r2
100419ec:	d004      	beq.n	100419f8 <HAL_RCCEx_PeriphCLKConfig+0x58>
  {
    assert_param(IS_RCC_LPUART1_CLOCK_SOURCE(PeriphClkInit->LPUART1ClockSelection));
    __HAL_RCC_LPUART1_CLK_CONFIG(PeriphClkInit->LPUART1ClockSelection);
100419ee:	687b      	ldr	r3, [r7, #4]
100419f0:	68db      	ldr	r3, [r3, #12]
100419f2:	0018      	movs	r0, r3
100419f4:	f7ff ff7c 	bl	100418f0 <LL_RCC_SetLPUARTClockSource>
  }
#endif /* RCC_CFGR_LPUCLKSEL */

  /*-------------------------- RTC WDG BLEWKUP clock source configuration ---------------------*/
  if ((((PeriphClkInit->RTCWDGBLEWKUPClockSelection) & RCC_PERIPHCLK_RTC_WDG_BLEWKUP) == RCC_PERIPHCLK_RTC_WDG_BLEWKUP))
100419f8:	687b      	ldr	r3, [r7, #4]
100419fa:	689b      	ldr	r3, [r3, #8]
100419fc:	2220      	movs	r2, #32
100419fe:	4013      	ands	r3, r2
10041a00:	d004      	beq.n	10041a0c <HAL_RCCEx_PeriphCLKConfig+0x6c>
  {
    assert_param(IS_RCC_RTC_WDG_BLEWKUP_CLOCK_SOURCE(PeriphClkInit->RTCWDGBLEWKUPClockSelection));
    __HAL_RCC_RTC_WDG_BLEWKUP_CLK_CONFIG(PeriphClkInit->RTCWDGBLEWKUPClockSelection);
10041a02:	687b      	ldr	r3, [r7, #4]
10041a04:	689b      	ldr	r3, [r3, #8]
10041a06:	0018      	movs	r0, r3
10041a08:	f7ff ff0e 	bl	10041828 <LL_RCC_LSCO_SetSource>
  }

  return HAL_OK;
10041a0c:	2300      	movs	r3, #0
}
10041a0e:	0018      	movs	r0, r3
10041a10:	46bd      	mov	sp, r7
10041a12:	b002      	add	sp, #8
10041a14:	bd80      	pop	{r7, pc}
	...

10041a18 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_RTC_WDG_BLEWKUP   RTC, WDG and BLEWKUP peripheral clock
  * @retval Frequency in Hz
  * @note   (*) Peripherals are not available on all devices
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
10041a18:	b580      	push	{r7, lr}
10041a1a:	b084      	sub	sp, #16
10041a1c:	af00      	add	r7, sp, #0
10041a1e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  /* No if clausule is covered */
  frequency = 0;
10041a20:	2300      	movs	r3, #0
10041a22:	60fb      	str	r3, [r7, #12]

  switch (PeriphClk)
10041a24:	687b      	ldr	r3, [r7, #4]
10041a26:	2b20      	cmp	r3, #32
10041a28:	d900      	bls.n	10041a2c <HAL_RCCEx_GetPeriphCLKFreq+0x14>
10041a2a:	e07b      	b.n	10041b24 <HAL_RCCEx_GetPeriphCLKFreq+0x10c>
10041a2c:	687b      	ldr	r3, [r7, #4]
10041a2e:	009a      	lsls	r2, r3, #2
10041a30:	4b40      	ldr	r3, [pc, #256]	@ (10041b34 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>)
10041a32:	18d3      	adds	r3, r2, r3
10041a34:	681b      	ldr	r3, [r3, #0]
10041a36:	469f      	mov	pc, r3
  {
    case RCC_PERIPHCLK_RF :
      switch (__HAL_RCC_RF_CLK_GET_CONFIG())
10041a38:	f7ff ff2c 	bl	10041894 <LL_RCC_GetRFClock>
10041a3c:	1e03      	subs	r3, r0, #0
10041a3e:	d002      	beq.n	10041a46 <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
10041a40:	2b04      	cmp	r3, #4
10041a42:	d003      	beq.n	10041a4c <HAL_RCCEx_GetPeriphCLKFreq+0x34>
        case RCC_RF_CLK_16M:
          frequency = HSE_VALUE / 2;
          break;
      }

      break;
10041a44:	e071      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>
          frequency = HSE_VALUE;
10041a46:	4b3c      	ldr	r3, [pc, #240]	@ (10041b38 <HAL_RCCEx_GetPeriphCLKFreq+0x120>)
10041a48:	60fb      	str	r3, [r7, #12]
          break;
10041a4a:	e002      	b.n	10041a52 <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          frequency = HSE_VALUE / 2;
10041a4c:	4b3b      	ldr	r3, [pc, #236]	@ (10041b3c <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10041a4e:	60fb      	str	r3, [r7, #12]
          break;
10041a50:	46c0      	nop			@ (mov r8, r8)
      break;
10041a52:	e06a      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>

    case RCC_PERIPHCLK_SMPS :
      switch (__HAL_RCC_GET_SMPS_DIV())
10041a54:	f7ff ff40 	bl	100418d8 <LL_RCC_GetSMPSPrescaler>
10041a58:	1e03      	subs	r3, r0, #0
10041a5a:	d004      	beq.n	10041a66 <HAL_RCCEx_GetPeriphCLKFreq+0x4e>
10041a5c:	2280      	movs	r2, #128	@ 0x80
10041a5e:	0152      	lsls	r2, r2, #5
10041a60:	4293      	cmp	r3, r2
10041a62:	d003      	beq.n	10041a6c <HAL_RCCEx_GetPeriphCLKFreq+0x54>
          break;
        case RCC_SMPSCLK_DIV4:
          frequency = HSE_VALUE / 8;
          break;
      }
      break;
10041a64:	e061      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>
          frequency = HSE_VALUE / 4;
10041a66:	4b36      	ldr	r3, [pc, #216]	@ (10041b40 <HAL_RCCEx_GetPeriphCLKFreq+0x128>)
10041a68:	60fb      	str	r3, [r7, #12]
          break;
10041a6a:	e002      	b.n	10041a72 <HAL_RCCEx_GetPeriphCLKFreq+0x5a>
          frequency = HSE_VALUE / 8;
10041a6c:	4b35      	ldr	r3, [pc, #212]	@ (10041b44 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>)
10041a6e:	60fb      	str	r3, [r7, #12]
          break;
10041a70:	46c0      	nop			@ (mov r8, r8)
      break;
10041a72:	e05a      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>
      }
      break;
#endif

    case RCC_PERIPHCLK_SPI3_I2S :
      if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_DIRECT_HSE)
10041a74:	f7ff fec8 	bl	10041808 <LL_RCC_DIRECT_HSE_IsEnabled>
10041a78:	1e03      	subs	r3, r0, #0
10041a7a:	d005      	beq.n	10041a88 <HAL_RCCEx_GetPeriphCLKFreq+0x70>
      {
        if (__HAL_RCC_GET_HSE_READYFLAG() == 0)
10041a7c:	f7ff feb0 	bl	100417e0 <LL_RCC_HSE_IsReady>
10041a80:	1e03      	subs	r3, r0, #0
10041a82:	d107      	bne.n	10041a94 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
        {
          return 0;
10041a84:	2300      	movs	r3, #0
10041a86:	e051      	b.n	10041b2c <HAL_RCCEx_GetPeriphCLKFreq+0x114>
        }
      }
      else
      {
        if (__HAL_RCC_RC64MPLL_READYFLAG() == 0)
10041a88:	f7ff ff76 	bl	10041978 <LL_RCC_RC64MPLL_IsReady>
10041a8c:	1e03      	subs	r3, r0, #0
10041a8e:	d101      	bne.n	10041a94 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
        {
          return 0;
10041a90:	2300      	movs	r3, #0
10041a92:	e04b      	b.n	10041b2c <HAL_RCCEx_GetPeriphCLKFreq+0x114>
        }
      }
      spiFreqValue = __HAL_RCC_GET_SPI3I2S_CLK_CONFIG();
10041a94:	f7ff ff64 	bl	10041960 <LL_RCC_GetSPI3I2SClockSource>
10041a98:	0003      	movs	r3, r0
10041a9a:	60bb      	str	r3, [r7, #8]
      if (spiFreqValue == RCC_SPI3I2S_CLKSOURCE_16M)
10041a9c:	68bb      	ldr	r3, [r7, #8]
10041a9e:	2b00      	cmp	r3, #0
10041aa0:	d101      	bne.n	10041aa6 <HAL_RCCEx_GetPeriphCLKFreq+0x8e>
      {
        frequency = HSE_VALUE / 2;
10041aa2:	4b26      	ldr	r3, [pc, #152]	@ (10041b3c <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10041aa4:	60fb      	str	r3, [r7, #12]
      }

      if (spiFreqValue == RCC_SPI3I2S_CLKSOURCE_32M)
10041aa6:	68ba      	ldr	r2, [r7, #8]
10041aa8:	2380      	movs	r3, #128	@ 0x80
10041aaa:	03db      	lsls	r3, r3, #15
10041aac:	429a      	cmp	r2, r3
10041aae:	d101      	bne.n	10041ab4 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
      {
        frequency = HSE_VALUE;
10041ab0:	4b21      	ldr	r3, [pc, #132]	@ (10041b38 <HAL_RCCEx_GetPeriphCLKFreq+0x120>)
10041ab2:	60fb      	str	r3, [r7, #12]
      }
#if defined(RCC_SPI3I2S_CLKSOURCE_64M)
      if (spiFreqValue == RCC_SPI3I2S_CLKSOURCE_64M)
10041ab4:	68ba      	ldr	r2, [r7, #8]
10041ab6:	2380      	movs	r3, #128	@ 0x80
10041ab8:	041b      	lsls	r3, r3, #16
10041aba:	429a      	cmp	r2, r3
10041abc:	d134      	bne.n	10041b28 <HAL_RCCEx_GetPeriphCLKFreq+0x110>
      {
        frequency = HSE_VALUE * 2;
10041abe:	4b22      	ldr	r3, [pc, #136]	@ (10041b48 <HAL_RCCEx_GetPeriphCLKFreq+0x130>)
10041ac0:	60fb      	str	r3, [r7, #12]
      }
#endif
      break;
10041ac2:	e031      	b.n	10041b28 <HAL_RCCEx_GetPeriphCLKFreq+0x110>

#if defined(RCC_CFGR_LPUCLKSEL)
    case RCC_PERIPHCLK_LPUART1 :
      switch (__HAL_RCC_GET_LPUART1_CLK_CONFIG())
10041ac4:	f7ff ff2a 	bl	1004191c <LL_RCC_GetLPUARTClockSource>
10041ac8:	0002      	movs	r2, r0
10041aca:	2380      	movs	r3, #128	@ 0x80
10041acc:	019b      	lsls	r3, r3, #6
10041ace:	429a      	cmp	r2, r3
10041ad0:	d103      	bne.n	10041ada <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
      {
        case RCC_LPUART1_CLKSOURCE_LSE:
          frequency = LSE_VALUE;
10041ad2:	2380      	movs	r3, #128	@ 0x80
10041ad4:	021b      	lsls	r3, r3, #8
10041ad6:	60fb      	str	r3, [r7, #12]
          break;
10041ad8:	e002      	b.n	10041ae0 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
        case RCC_LPUART1_CLKSOURCE_16M:
        default:
          frequency = HSE_VALUE / 2;
10041ada:	4b18      	ldr	r3, [pc, #96]	@ (10041b3c <HAL_RCCEx_GetPeriphCLKFreq+0x124>)
10041adc:	60fb      	str	r3, [r7, #12]
          break;
10041ade:	46c0      	nop			@ (mov r8, r8)
      }
      break;
10041ae0:	e023      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>
#endif /* RCC_CFGR_LPUCLKSEL */

    case RCC_PERIPHCLK_RTC_WDG_BLEWKUP :
      switch (LL_RCC_LSCO_GetSource())
10041ae2:	f7ff feb7 	bl	10041854 <LL_RCC_LSCO_GetSource>
10041ae6:	0003      	movs	r3, r0
10041ae8:	22c0      	movs	r2, #192	@ 0xc0
10041aea:	0252      	lsls	r2, r2, #9
10041aec:	4293      	cmp	r3, r2
10041aee:	d014      	beq.n	10041b1a <HAL_RCCEx_GetPeriphCLKFreq+0x102>
10041af0:	22c0      	movs	r2, #192	@ 0xc0
10041af2:	0252      	lsls	r2, r2, #9
10041af4:	4293      	cmp	r3, r2
10041af6:	d813      	bhi.n	10041b20 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
10041af8:	2280      	movs	r2, #128	@ 0x80
10041afa:	0212      	lsls	r2, r2, #8
10041afc:	4293      	cmp	r3, r2
10041afe:	d004      	beq.n	10041b0a <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
10041b00:	2280      	movs	r2, #128	@ 0x80
10041b02:	0252      	lsls	r2, r2, #9
10041b04:	4293      	cmp	r3, r2
10041b06:	d004      	beq.n	10041b12 <HAL_RCCEx_GetPeriphCLKFreq+0xfa>
          break;
        case LL_RCC_LSCO_CLKSOURCE_HSI64M_DIV2048:
          frequency = HSE_VALUE >> 10;
          break;
        default :
          break;
10041b08:	e00a      	b.n	10041b20 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
          frequency = LSE_VALUE;
10041b0a:	2380      	movs	r3, #128	@ 0x80
10041b0c:	021b      	lsls	r3, r3, #8
10041b0e:	60fb      	str	r3, [r7, #12]
          break;
10041b10:	e007      	b.n	10041b22 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
          frequency = LSI_VALUE;
10041b12:	23fa      	movs	r3, #250	@ 0xfa
10041b14:	01db      	lsls	r3, r3, #7
10041b16:	60fb      	str	r3, [r7, #12]
          break;
10041b18:	e003      	b.n	10041b22 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
          frequency = HSE_VALUE >> 10;
10041b1a:	4b0c      	ldr	r3, [pc, #48]	@ (10041b4c <HAL_RCCEx_GetPeriphCLKFreq+0x134>)
10041b1c:	60fb      	str	r3, [r7, #12]
          break;
10041b1e:	e000      	b.n	10041b22 <HAL_RCCEx_GetPeriphCLKFreq+0x10a>
          break;
10041b20:	46c0      	nop			@ (mov r8, r8)
      }
      break;
10041b22:	e002      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>
    default :
      break;
10041b24:	46c0      	nop			@ (mov r8, r8)
10041b26:	e000      	b.n	10041b2a <HAL_RCCEx_GetPeriphCLKFreq+0x112>
      break;
10041b28:	46c0      	nop			@ (mov r8, r8)
  }

  return (frequency);
10041b2a:	68fb      	ldr	r3, [r7, #12]
}
10041b2c:	0018      	movs	r0, r3
10041b2e:	46bd      	mov	sp, r7
10041b30:	b004      	add	sp, #16
10041b32:	bd80      	pop	{r7, pc}
10041b34:	1004250c 	.word	0x1004250c
10041b38:	01e84800 	.word	0x01e84800
10041b3c:	00f42400 	.word	0x00f42400
10041b40:	007a1200 	.word	0x007a1200
10041b44:	003d0900 	.word	0x003d0900
10041b48:	03d09000 	.word	0x03d09000
10041b4c:	00007a12 	.word	0x00007a12

10041b50 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
10041b50:	b580      	push	{r7, lr}
10041b52:	b082      	sub	sp, #8
10041b54:	af00      	add	r7, sp, #0
10041b56:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
10041b58:	687b      	ldr	r3, [r7, #4]
10041b5a:	2b00      	cmp	r3, #0
10041b5c:	d101      	bne.n	10041b62 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
10041b5e:	2301      	movs	r3, #1
10041b60:	e046      	b.n	10041bf0 <HAL_UART_Init+0xa0>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
10041b62:	687b      	ldr	r3, [r7, #4]
10041b64:	2288      	movs	r2, #136	@ 0x88
10041b66:	589b      	ldr	r3, [r3, r2]
10041b68:	2b00      	cmp	r3, #0
10041b6a:	d107      	bne.n	10041b7c <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
10041b6c:	687b      	ldr	r3, [r7, #4]
10041b6e:	2284      	movs	r2, #132	@ 0x84
10041b70:	2100      	movs	r1, #0
10041b72:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
10041b74:	687b      	ldr	r3, [r7, #4]
10041b76:	0018      	movs	r0, r3
10041b78:	f7fe fe80 	bl	1004087c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
10041b7c:	687b      	ldr	r3, [r7, #4]
10041b7e:	2288      	movs	r2, #136	@ 0x88
10041b80:	2124      	movs	r1, #36	@ 0x24
10041b82:	5099      	str	r1, [r3, r2]

  __HAL_UART_DISABLE(huart);
10041b84:	687b      	ldr	r3, [r7, #4]
10041b86:	681b      	ldr	r3, [r3, #0]
10041b88:	681a      	ldr	r2, [r3, #0]
10041b8a:	687b      	ldr	r3, [r7, #4]
10041b8c:	681b      	ldr	r3, [r3, #0]
10041b8e:	2101      	movs	r1, #1
10041b90:	438a      	bics	r2, r1
10041b92:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
10041b94:	687b      	ldr	r3, [r7, #4]
10041b96:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041b98:	2b00      	cmp	r3, #0
10041b9a:	d003      	beq.n	10041ba4 <HAL_UART_Init+0x54>
  {
    UART_AdvFeatureConfig(huart);
10041b9c:	687b      	ldr	r3, [r7, #4]
10041b9e:	0018      	movs	r0, r3
10041ba0:	f000 f994 	bl	10041ecc <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
10041ba4:	687b      	ldr	r3, [r7, #4]
10041ba6:	0018      	movs	r0, r3
10041ba8:	f000 f828 	bl	10041bfc <UART_SetConfig>
10041bac:	0003      	movs	r3, r0
10041bae:	2b01      	cmp	r3, #1
10041bb0:	d101      	bne.n	10041bb6 <HAL_UART_Init+0x66>
  {
    return HAL_ERROR;
10041bb2:	2301      	movs	r3, #1
10041bb4:	e01c      	b.n	10041bf0 <HAL_UART_Init+0xa0>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
10041bb6:	687b      	ldr	r3, [r7, #4]
10041bb8:	681b      	ldr	r3, [r3, #0]
10041bba:	685a      	ldr	r2, [r3, #4]
10041bbc:	687b      	ldr	r3, [r7, #4]
10041bbe:	681b      	ldr	r3, [r3, #0]
10041bc0:	490d      	ldr	r1, [pc, #52]	@ (10041bf8 <HAL_UART_Init+0xa8>)
10041bc2:	400a      	ands	r2, r1
10041bc4:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
10041bc6:	687b      	ldr	r3, [r7, #4]
10041bc8:	681b      	ldr	r3, [r3, #0]
10041bca:	689a      	ldr	r2, [r3, #8]
10041bcc:	687b      	ldr	r3, [r7, #4]
10041bce:	681b      	ldr	r3, [r3, #0]
10041bd0:	212a      	movs	r1, #42	@ 0x2a
10041bd2:	438a      	bics	r2, r1
10041bd4:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
10041bd6:	687b      	ldr	r3, [r7, #4]
10041bd8:	681b      	ldr	r3, [r3, #0]
10041bda:	681a      	ldr	r2, [r3, #0]
10041bdc:	687b      	ldr	r3, [r7, #4]
10041bde:	681b      	ldr	r3, [r3, #0]
10041be0:	2101      	movs	r1, #1
10041be2:	430a      	orrs	r2, r1
10041be4:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
10041be6:	687b      	ldr	r3, [r7, #4]
10041be8:	0018      	movs	r0, r3
10041bea:	f000 fa23 	bl	10042034 <UART_CheckIdleState>
10041bee:	0003      	movs	r3, r0
}
10041bf0:	0018      	movs	r0, r3
10041bf2:	46bd      	mov	sp, r7
10041bf4:	b002      	add	sp, #8
10041bf6:	bd80      	pop	{r7, pc}
10041bf8:	ffffb7ff 	.word	0xffffb7ff

10041bfc <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
10041bfc:	b5b0      	push	{r4, r5, r7, lr}
10041bfe:	b090      	sub	sp, #64	@ 0x40
10041c00:	af00      	add	r7, sp, #0
10041c02:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
10041c04:	231b      	movs	r3, #27
10041c06:	2220      	movs	r2, #32
10041c08:	189b      	adds	r3, r3, r2
10041c0a:	19db      	adds	r3, r3, r7
10041c0c:	2200      	movs	r2, #0
10041c0e:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
10041c10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c12:	689a      	ldr	r2, [r3, #8]
10041c14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c16:	691b      	ldr	r3, [r3, #16]
10041c18:	431a      	orrs	r2, r3
10041c1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c1c:	695b      	ldr	r3, [r3, #20]
10041c1e:	431a      	orrs	r2, r3
10041c20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c22:	69db      	ldr	r3, [r3, #28]
10041c24:	4313      	orrs	r3, r2
10041c26:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
10041c28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c2a:	681b      	ldr	r3, [r3, #0]
10041c2c:	681b      	ldr	r3, [r3, #0]
10041c2e:	4aa1      	ldr	r2, [pc, #644]	@ (10041eb4 <UART_SetConfig+0x2b8>)
10041c30:	4013      	ands	r3, r2
10041c32:	0019      	movs	r1, r3
10041c34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c36:	681a      	ldr	r2, [r3, #0]
10041c38:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10041c3a:	430b      	orrs	r3, r1
10041c3c:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
10041c3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c40:	681b      	ldr	r3, [r3, #0]
10041c42:	685b      	ldr	r3, [r3, #4]
10041c44:	4a9c      	ldr	r2, [pc, #624]	@ (10041eb8 <UART_SetConfig+0x2bc>)
10041c46:	4013      	ands	r3, r2
10041c48:	0018      	movs	r0, r3
10041c4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c4c:	68d9      	ldr	r1, [r3, #12]
10041c4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c50:	681a      	ldr	r2, [r3, #0]
10041c52:	0003      	movs	r3, r0
10041c54:	430b      	orrs	r3, r1
10041c56:	6053      	str	r3, [r2, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
10041c58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c5a:	699b      	ldr	r3, [r3, #24]
10041c5c:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
10041c5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c60:	681b      	ldr	r3, [r3, #0]
10041c62:	4a96      	ldr	r2, [pc, #600]	@ (10041ebc <UART_SetConfig+0x2c0>)
10041c64:	4293      	cmp	r3, r2
10041c66:	d004      	beq.n	10041c72 <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
10041c68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c6a:	6a1b      	ldr	r3, [r3, #32]
10041c6c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
10041c6e:	4313      	orrs	r3, r2
10041c70:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
10041c72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c74:	681b      	ldr	r3, [r3, #0]
10041c76:	689b      	ldr	r3, [r3, #8]
10041c78:	4a91      	ldr	r2, [pc, #580]	@ (10041ec0 <UART_SetConfig+0x2c4>)
10041c7a:	4013      	ands	r3, r2
10041c7c:	0019      	movs	r1, r3
10041c7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c80:	681a      	ldr	r2, [r3, #0]
10041c82:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
10041c84:	430b      	orrs	r3, r1
10041c86:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
10041c88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c8a:	681b      	ldr	r3, [r3, #0]
10041c8c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
10041c8e:	220f      	movs	r2, #15
10041c90:	4393      	bics	r3, r2
10041c92:	0018      	movs	r0, r3
10041c94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c96:	6a59      	ldr	r1, [r3, #36]	@ 0x24
10041c98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041c9a:	681a      	ldr	r2, [r3, #0]
10041c9c:	0003      	movs	r3, r0
10041c9e:	430b      	orrs	r3, r1
10041ca0:	62d3      	str	r3, [r2, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
10041ca2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041ca4:	681b      	ldr	r3, [r3, #0]
10041ca6:	4a85      	ldr	r2, [pc, #532]	@ (10041ebc <UART_SetConfig+0x2c0>)
10041ca8:	4293      	cmp	r3, r2
10041caa:	d16d      	bne.n	10041d88 <UART_SetConfig+0x18c>
  {
    /* Retrieve frequency clock */
#if defined(RCC_CFGR_LPUCLKSEL)
    pclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_LPUART1);
10041cac:	2010      	movs	r0, #16
10041cae:	f7ff feb3 	bl	10041a18 <HAL_RCCEx_GetPeriphCLKFreq>
10041cb2:	0003      	movs	r3, r0
10041cb4:	637b      	str	r3, [r7, #52]	@ 0x34
#else
    pclk = UART_PERIPHCLK;
#endif /* RCC_CFGR_LPUCLKSEL */

    /* If proper clock source reported */
    if (pclk != 0U)
10041cb6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10041cb8:	2b00      	cmp	r3, #0
10041cba:	d100      	bne.n	10041cbe <UART_SetConfig+0xc2>
10041cbc:	e0e3      	b.n	10041e86 <UART_SetConfig+0x28a>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
10041cbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041cc0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10041cc2:	4b80      	ldr	r3, [pc, #512]	@ (10041ec4 <UART_SetConfig+0x2c8>)
10041cc4:	0052      	lsls	r2, r2, #1
10041cc6:	5ad3      	ldrh	r3, [r2, r3]
10041cc8:	0019      	movs	r1, r3
10041cca:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10041ccc:	f7fe f9f8 	bl	100400c0 <__udivsi3>
10041cd0:	0003      	movs	r3, r0
10041cd2:	62bb      	str	r3, [r7, #40]	@ 0x28

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10041cd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041cd6:	685a      	ldr	r2, [r3, #4]
10041cd8:	0013      	movs	r3, r2
10041cda:	005b      	lsls	r3, r3, #1
10041cdc:	189b      	adds	r3, r3, r2
10041cde:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10041ce0:	429a      	cmp	r2, r3
10041ce2:	d305      	bcc.n	10041cf0 <UART_SetConfig+0xf4>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
10041ce4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041ce6:	685b      	ldr	r3, [r3, #4]
10041ce8:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
10041cea:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10041cec:	429a      	cmp	r2, r3
10041cee:	d906      	bls.n	10041cfe <UART_SetConfig+0x102>
      {
        ret = HAL_ERROR;
10041cf0:	231b      	movs	r3, #27
10041cf2:	2220      	movs	r2, #32
10041cf4:	189b      	adds	r3, r3, r2
10041cf6:	19db      	adds	r3, r3, r7
10041cf8:	2201      	movs	r2, #1
10041cfa:	701a      	strb	r2, [r3, #0]
10041cfc:	e0c3      	b.n	10041e86 <UART_SetConfig+0x28a>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10041cfe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10041d00:	61bb      	str	r3, [r7, #24]
10041d02:	2300      	movs	r3, #0
10041d04:	61fb      	str	r3, [r7, #28]
10041d06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041d08:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10041d0a:	4b6e      	ldr	r3, [pc, #440]	@ (10041ec4 <UART_SetConfig+0x2c8>)
10041d0c:	0052      	lsls	r2, r2, #1
10041d0e:	5ad3      	ldrh	r3, [r2, r3]
10041d10:	613b      	str	r3, [r7, #16]
10041d12:	2300      	movs	r3, #0
10041d14:	617b      	str	r3, [r7, #20]
10041d16:	693a      	ldr	r2, [r7, #16]
10041d18:	697b      	ldr	r3, [r7, #20]
10041d1a:	69b8      	ldr	r0, [r7, #24]
10041d1c:	69f9      	ldr	r1, [r7, #28]
10041d1e:	f7fe fb45 	bl	100403ac <__aeabi_uldivmod>
10041d22:	0002      	movs	r2, r0
10041d24:	000b      	movs	r3, r1
10041d26:	0e11      	lsrs	r1, r2, #24
10041d28:	021d      	lsls	r5, r3, #8
10041d2a:	430d      	orrs	r5, r1
10041d2c:	0214      	lsls	r4, r2, #8
10041d2e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041d30:	685b      	ldr	r3, [r3, #4]
10041d32:	085b      	lsrs	r3, r3, #1
10041d34:	60bb      	str	r3, [r7, #8]
10041d36:	2300      	movs	r3, #0
10041d38:	60fb      	str	r3, [r7, #12]
10041d3a:	68b8      	ldr	r0, [r7, #8]
10041d3c:	68f9      	ldr	r1, [r7, #12]
10041d3e:	1900      	adds	r0, r0, r4
10041d40:	4169      	adcs	r1, r5
10041d42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041d44:	685b      	ldr	r3, [r3, #4]
10041d46:	603b      	str	r3, [r7, #0]
10041d48:	2300      	movs	r3, #0
10041d4a:	607b      	str	r3, [r7, #4]
10041d4c:	683a      	ldr	r2, [r7, #0]
10041d4e:	687b      	ldr	r3, [r7, #4]
10041d50:	f7fe fb2c 	bl	100403ac <__aeabi_uldivmod>
10041d54:	0002      	movs	r2, r0
10041d56:	000b      	movs	r3, r1
10041d58:	0013      	movs	r3, r2
10041d5a:	633b      	str	r3, [r7, #48]	@ 0x30
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
10041d5c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041d5e:	23c0      	movs	r3, #192	@ 0xc0
10041d60:	009b      	lsls	r3, r3, #2
10041d62:	429a      	cmp	r2, r3
10041d64:	d309      	bcc.n	10041d7a <UART_SetConfig+0x17e>
10041d66:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041d68:	2380      	movs	r3, #128	@ 0x80
10041d6a:	035b      	lsls	r3, r3, #13
10041d6c:	429a      	cmp	r2, r3
10041d6e:	d204      	bcs.n	10041d7a <UART_SetConfig+0x17e>
        {
          huart->Instance->BRR = usartdiv;
10041d70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041d72:	681b      	ldr	r3, [r3, #0]
10041d74:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041d76:	60da      	str	r2, [r3, #12]
10041d78:	e085      	b.n	10041e86 <UART_SetConfig+0x28a>
        }
        else
        {
          ret = HAL_ERROR;
10041d7a:	231b      	movs	r3, #27
10041d7c:	2220      	movs	r2, #32
10041d7e:	189b      	adds	r3, r3, r2
10041d80:	19db      	adds	r3, r3, r7
10041d82:	2201      	movs	r2, #1
10041d84:	701a      	strb	r2, [r3, #0]
10041d86:	e07e      	b.n	10041e86 <UART_SetConfig+0x28a>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
10041d88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041d8a:	69da      	ldr	r2, [r3, #28]
10041d8c:	2380      	movs	r3, #128	@ 0x80
10041d8e:	021b      	lsls	r3, r3, #8
10041d90:	429a      	cmp	r2, r3
10041d92:	d148      	bne.n	10041e26 <UART_SetConfig+0x22a>
  {
    pclk = UART_PERIPHCLK;
10041d94:	4b4c      	ldr	r3, [pc, #304]	@ (10041ec8 <UART_SetConfig+0x2cc>)
10041d96:	637b      	str	r3, [r7, #52]	@ 0x34

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
10041d98:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10041d9a:	2b00      	cmp	r3, #0
10041d9c:	d100      	bne.n	10041da0 <UART_SetConfig+0x1a4>
10041d9e:	e072      	b.n	10041e86 <UART_SetConfig+0x28a>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10041da0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041da2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10041da4:	4b47      	ldr	r3, [pc, #284]	@ (10041ec4 <UART_SetConfig+0x2c8>)
10041da6:	0052      	lsls	r2, r2, #1
10041da8:	5ad3      	ldrh	r3, [r2, r3]
10041daa:	0019      	movs	r1, r3
10041dac:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10041dae:	f7fe f987 	bl	100400c0 <__udivsi3>
10041db2:	0003      	movs	r3, r0
10041db4:	005a      	lsls	r2, r3, #1
10041db6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041db8:	685b      	ldr	r3, [r3, #4]
10041dba:	085b      	lsrs	r3, r3, #1
10041dbc:	18d2      	adds	r2, r2, r3
10041dbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041dc0:	685b      	ldr	r3, [r3, #4]
10041dc2:	0019      	movs	r1, r3
10041dc4:	0010      	movs	r0, r2
10041dc6:	f7fe f97b 	bl	100400c0 <__udivsi3>
10041dca:	0003      	movs	r3, r0
10041dcc:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
10041dce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041dd0:	2b0f      	cmp	r3, #15
10041dd2:	d921      	bls.n	10041e18 <UART_SetConfig+0x21c>
10041dd4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041dd6:	2380      	movs	r3, #128	@ 0x80
10041dd8:	025b      	lsls	r3, r3, #9
10041dda:	429a      	cmp	r2, r3
10041ddc:	d21c      	bcs.n	10041e18 <UART_SetConfig+0x21c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
10041dde:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041de0:	b29a      	uxth	r2, r3
10041de2:	200e      	movs	r0, #14
10041de4:	2420      	movs	r4, #32
10041de6:	1903      	adds	r3, r0, r4
10041de8:	19db      	adds	r3, r3, r7
10041dea:	210f      	movs	r1, #15
10041dec:	438a      	bics	r2, r1
10041dee:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
10041df0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041df2:	085b      	lsrs	r3, r3, #1
10041df4:	b29b      	uxth	r3, r3
10041df6:	2207      	movs	r2, #7
10041df8:	4013      	ands	r3, r2
10041dfa:	b299      	uxth	r1, r3
10041dfc:	1903      	adds	r3, r0, r4
10041dfe:	19db      	adds	r3, r3, r7
10041e00:	1902      	adds	r2, r0, r4
10041e02:	19d2      	adds	r2, r2, r7
10041e04:	8812      	ldrh	r2, [r2, #0]
10041e06:	430a      	orrs	r2, r1
10041e08:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
10041e0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e0c:	681b      	ldr	r3, [r3, #0]
10041e0e:	1902      	adds	r2, r0, r4
10041e10:	19d2      	adds	r2, r2, r7
10041e12:	8812      	ldrh	r2, [r2, #0]
10041e14:	60da      	str	r2, [r3, #12]
10041e16:	e036      	b.n	10041e86 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
10041e18:	231b      	movs	r3, #27
10041e1a:	2220      	movs	r2, #32
10041e1c:	189b      	adds	r3, r3, r2
10041e1e:	19db      	adds	r3, r3, r7
10041e20:	2201      	movs	r2, #1
10041e22:	701a      	strb	r2, [r3, #0]
10041e24:	e02f      	b.n	10041e86 <UART_SetConfig+0x28a>
      }
    }
  }
  else
  {
    pclk = UART_PERIPHCLK;
10041e26:	4b28      	ldr	r3, [pc, #160]	@ (10041ec8 <UART_SetConfig+0x2cc>)
10041e28:	637b      	str	r3, [r7, #52]	@ 0x34

    if (pclk != 0U)
10041e2a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10041e2c:	2b00      	cmp	r3, #0
10041e2e:	d02a      	beq.n	10041e86 <UART_SetConfig+0x28a>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
10041e30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e32:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10041e34:	4b23      	ldr	r3, [pc, #140]	@ (10041ec4 <UART_SetConfig+0x2c8>)
10041e36:	0052      	lsls	r2, r2, #1
10041e38:	5ad3      	ldrh	r3, [r2, r3]
10041e3a:	0019      	movs	r1, r3
10041e3c:	6b78      	ldr	r0, [r7, #52]	@ 0x34
10041e3e:	f7fe f93f 	bl	100400c0 <__udivsi3>
10041e42:	0003      	movs	r3, r0
10041e44:	001a      	movs	r2, r3
10041e46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e48:	685b      	ldr	r3, [r3, #4]
10041e4a:	085b      	lsrs	r3, r3, #1
10041e4c:	18d2      	adds	r2, r2, r3
10041e4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e50:	685b      	ldr	r3, [r3, #4]
10041e52:	0019      	movs	r1, r3
10041e54:	0010      	movs	r0, r2
10041e56:	f7fe f933 	bl	100400c0 <__udivsi3>
10041e5a:	0003      	movs	r3, r0
10041e5c:	633b      	str	r3, [r7, #48]	@ 0x30
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
10041e5e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041e60:	2b0f      	cmp	r3, #15
10041e62:	d90a      	bls.n	10041e7a <UART_SetConfig+0x27e>
10041e64:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041e66:	2380      	movs	r3, #128	@ 0x80
10041e68:	025b      	lsls	r3, r3, #9
10041e6a:	429a      	cmp	r2, r3
10041e6c:	d205      	bcs.n	10041e7a <UART_SetConfig+0x27e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
10041e6e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041e70:	b29a      	uxth	r2, r3
10041e72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e74:	681b      	ldr	r3, [r3, #0]
10041e76:	60da      	str	r2, [r3, #12]
10041e78:	e005      	b.n	10041e86 <UART_SetConfig+0x28a>
      }
      else
      {
        ret = HAL_ERROR;
10041e7a:	231b      	movs	r3, #27
10041e7c:	2220      	movs	r2, #32
10041e7e:	189b      	adds	r3, r3, r2
10041e80:	19db      	adds	r3, r3, r7
10041e82:	2201      	movs	r2, #1
10041e84:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
10041e86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e88:	226a      	movs	r2, #106	@ 0x6a
10041e8a:	2101      	movs	r1, #1
10041e8c:	5299      	strh	r1, [r3, r2]
  huart->NbRxDataToProcess = 1;
10041e8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e90:	2268      	movs	r2, #104	@ 0x68
10041e92:	2101      	movs	r1, #1
10041e94:	5299      	strh	r1, [r3, r2]

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
10041e96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e98:	2200      	movs	r2, #0
10041e9a:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
10041e9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10041e9e:	2200      	movs	r2, #0
10041ea0:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
10041ea2:	231b      	movs	r3, #27
10041ea4:	2220      	movs	r2, #32
10041ea6:	189b      	adds	r3, r3, r2
10041ea8:	19db      	adds	r3, r3, r7
10041eaa:	781b      	ldrb	r3, [r3, #0]
}
10041eac:	0018      	movs	r0, r3
10041eae:	46bd      	mov	sp, r7
10041eb0:	b010      	add	sp, #64	@ 0x40
10041eb2:	bdb0      	pop	{r4, r5, r7, pc}
10041eb4:	cfff69f3 	.word	0xcfff69f3
10041eb8:	ffffcfff 	.word	0xffffcfff
10041ebc:	41005000 	.word	0x41005000
10041ec0:	11fff4ff 	.word	0x11fff4ff
10041ec4:	10042590 	.word	0x10042590
10041ec8:	00f42400 	.word	0x00f42400

10041ecc <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
10041ecc:	b580      	push	{r7, lr}
10041ece:	b082      	sub	sp, #8
10041ed0:	af00      	add	r7, sp, #0
10041ed2:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
10041ed4:	687b      	ldr	r3, [r7, #4]
10041ed6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041ed8:	2208      	movs	r2, #8
10041eda:	4013      	ands	r3, r2
10041edc:	d00b      	beq.n	10041ef6 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
10041ede:	687b      	ldr	r3, [r7, #4]
10041ee0:	681b      	ldr	r3, [r3, #0]
10041ee2:	685b      	ldr	r3, [r3, #4]
10041ee4:	4a4a      	ldr	r2, [pc, #296]	@ (10042010 <UART_AdvFeatureConfig+0x144>)
10041ee6:	4013      	ands	r3, r2
10041ee8:	0019      	movs	r1, r3
10041eea:	687b      	ldr	r3, [r7, #4]
10041eec:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
10041eee:	687b      	ldr	r3, [r7, #4]
10041ef0:	681b      	ldr	r3, [r3, #0]
10041ef2:	430a      	orrs	r2, r1
10041ef4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
10041ef6:	687b      	ldr	r3, [r7, #4]
10041ef8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041efa:	2201      	movs	r2, #1
10041efc:	4013      	ands	r3, r2
10041efe:	d00b      	beq.n	10041f18 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
10041f00:	687b      	ldr	r3, [r7, #4]
10041f02:	681b      	ldr	r3, [r3, #0]
10041f04:	685b      	ldr	r3, [r3, #4]
10041f06:	4a43      	ldr	r2, [pc, #268]	@ (10042014 <UART_AdvFeatureConfig+0x148>)
10041f08:	4013      	ands	r3, r2
10041f0a:	0019      	movs	r1, r3
10041f0c:	687b      	ldr	r3, [r7, #4]
10041f0e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10041f10:	687b      	ldr	r3, [r7, #4]
10041f12:	681b      	ldr	r3, [r3, #0]
10041f14:	430a      	orrs	r2, r1
10041f16:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
10041f18:	687b      	ldr	r3, [r7, #4]
10041f1a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041f1c:	2202      	movs	r2, #2
10041f1e:	4013      	ands	r3, r2
10041f20:	d00b      	beq.n	10041f3a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
10041f22:	687b      	ldr	r3, [r7, #4]
10041f24:	681b      	ldr	r3, [r3, #0]
10041f26:	685b      	ldr	r3, [r3, #4]
10041f28:	4a3b      	ldr	r2, [pc, #236]	@ (10042018 <UART_AdvFeatureConfig+0x14c>)
10041f2a:	4013      	ands	r3, r2
10041f2c:	0019      	movs	r1, r3
10041f2e:	687b      	ldr	r3, [r7, #4]
10041f30:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
10041f32:	687b      	ldr	r3, [r7, #4]
10041f34:	681b      	ldr	r3, [r3, #0]
10041f36:	430a      	orrs	r2, r1
10041f38:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
10041f3a:	687b      	ldr	r3, [r7, #4]
10041f3c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041f3e:	2204      	movs	r2, #4
10041f40:	4013      	ands	r3, r2
10041f42:	d00b      	beq.n	10041f5c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
10041f44:	687b      	ldr	r3, [r7, #4]
10041f46:	681b      	ldr	r3, [r3, #0]
10041f48:	685b      	ldr	r3, [r3, #4]
10041f4a:	4a34      	ldr	r2, [pc, #208]	@ (1004201c <UART_AdvFeatureConfig+0x150>)
10041f4c:	4013      	ands	r3, r2
10041f4e:	0019      	movs	r1, r3
10041f50:	687b      	ldr	r3, [r7, #4]
10041f52:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
10041f54:	687b      	ldr	r3, [r7, #4]
10041f56:	681b      	ldr	r3, [r3, #0]
10041f58:	430a      	orrs	r2, r1
10041f5a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
10041f5c:	687b      	ldr	r3, [r7, #4]
10041f5e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041f60:	2210      	movs	r2, #16
10041f62:	4013      	ands	r3, r2
10041f64:	d00b      	beq.n	10041f7e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
10041f66:	687b      	ldr	r3, [r7, #4]
10041f68:	681b      	ldr	r3, [r3, #0]
10041f6a:	689b      	ldr	r3, [r3, #8]
10041f6c:	4a2c      	ldr	r2, [pc, #176]	@ (10042020 <UART_AdvFeatureConfig+0x154>)
10041f6e:	4013      	ands	r3, r2
10041f70:	0019      	movs	r1, r3
10041f72:	687b      	ldr	r3, [r7, #4]
10041f74:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
10041f76:	687b      	ldr	r3, [r7, #4]
10041f78:	681b      	ldr	r3, [r3, #0]
10041f7a:	430a      	orrs	r2, r1
10041f7c:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
10041f7e:	687b      	ldr	r3, [r7, #4]
10041f80:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041f82:	2220      	movs	r2, #32
10041f84:	4013      	ands	r3, r2
10041f86:	d00b      	beq.n	10041fa0 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
10041f88:	687b      	ldr	r3, [r7, #4]
10041f8a:	681b      	ldr	r3, [r3, #0]
10041f8c:	689b      	ldr	r3, [r3, #8]
10041f8e:	4a25      	ldr	r2, [pc, #148]	@ (10042024 <UART_AdvFeatureConfig+0x158>)
10041f90:	4013      	ands	r3, r2
10041f92:	0019      	movs	r1, r3
10041f94:	687b      	ldr	r3, [r7, #4]
10041f96:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
10041f98:	687b      	ldr	r3, [r7, #4]
10041f9a:	681b      	ldr	r3, [r3, #0]
10041f9c:	430a      	orrs	r2, r1
10041f9e:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
10041fa0:	687b      	ldr	r3, [r7, #4]
10041fa2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041fa4:	2240      	movs	r2, #64	@ 0x40
10041fa6:	4013      	ands	r3, r2
10041fa8:	d01d      	beq.n	10041fe6 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
10041faa:	687b      	ldr	r3, [r7, #4]
10041fac:	681b      	ldr	r3, [r3, #0]
10041fae:	685b      	ldr	r3, [r3, #4]
10041fb0:	4a1d      	ldr	r2, [pc, #116]	@ (10042028 <UART_AdvFeatureConfig+0x15c>)
10041fb2:	4013      	ands	r3, r2
10041fb4:	0019      	movs	r1, r3
10041fb6:	687b      	ldr	r3, [r7, #4]
10041fb8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10041fba:	687b      	ldr	r3, [r7, #4]
10041fbc:	681b      	ldr	r3, [r3, #0]
10041fbe:	430a      	orrs	r2, r1
10041fc0:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
10041fc2:	687b      	ldr	r3, [r7, #4]
10041fc4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10041fc6:	2380      	movs	r3, #128	@ 0x80
10041fc8:	035b      	lsls	r3, r3, #13
10041fca:	429a      	cmp	r2, r3
10041fcc:	d10b      	bne.n	10041fe6 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
10041fce:	687b      	ldr	r3, [r7, #4]
10041fd0:	681b      	ldr	r3, [r3, #0]
10041fd2:	685b      	ldr	r3, [r3, #4]
10041fd4:	4a15      	ldr	r2, [pc, #84]	@ (1004202c <UART_AdvFeatureConfig+0x160>)
10041fd6:	4013      	ands	r3, r2
10041fd8:	0019      	movs	r1, r3
10041fda:	687b      	ldr	r3, [r7, #4]
10041fdc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
10041fde:	687b      	ldr	r3, [r7, #4]
10041fe0:	681b      	ldr	r3, [r3, #0]
10041fe2:	430a      	orrs	r2, r1
10041fe4:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
10041fe6:	687b      	ldr	r3, [r7, #4]
10041fe8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
10041fea:	2280      	movs	r2, #128	@ 0x80
10041fec:	4013      	ands	r3, r2
10041fee:	d00b      	beq.n	10042008 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
10041ff0:	687b      	ldr	r3, [r7, #4]
10041ff2:	681b      	ldr	r3, [r3, #0]
10041ff4:	685b      	ldr	r3, [r3, #4]
10041ff6:	4a0e      	ldr	r2, [pc, #56]	@ (10042030 <UART_AdvFeatureConfig+0x164>)
10041ff8:	4013      	ands	r3, r2
10041ffa:	0019      	movs	r1, r3
10041ffc:	687b      	ldr	r3, [r7, #4]
10041ffe:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
10042000:	687b      	ldr	r3, [r7, #4]
10042002:	681b      	ldr	r3, [r3, #0]
10042004:	430a      	orrs	r2, r1
10042006:	605a      	str	r2, [r3, #4]
  }
}
10042008:	46c0      	nop			@ (mov r8, r8)
1004200a:	46bd      	mov	sp, r7
1004200c:	b002      	add	sp, #8
1004200e:	bd80      	pop	{r7, pc}
10042010:	ffff7fff 	.word	0xffff7fff
10042014:	fffdffff 	.word	0xfffdffff
10042018:	fffeffff 	.word	0xfffeffff
1004201c:	fffbffff 	.word	0xfffbffff
10042020:	ffffefff 	.word	0xffffefff
10042024:	ffffdfff 	.word	0xffffdfff
10042028:	ffefffff 	.word	0xffefffff
1004202c:	ff9fffff 	.word	0xff9fffff
10042030:	fff7ffff 	.word	0xfff7ffff

10042034 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
10042034:	b580      	push	{r7, lr}
10042036:	b092      	sub	sp, #72	@ 0x48
10042038:	af02      	add	r7, sp, #8
1004203a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
1004203c:	687b      	ldr	r3, [r7, #4]
1004203e:	2290      	movs	r2, #144	@ 0x90
10042040:	2100      	movs	r1, #0
10042042:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
10042044:	f7fe ffa0 	bl	10040f88 <HAL_GetTick>
10042048:	0003      	movs	r3, r0
1004204a:	63fb      	str	r3, [r7, #60]	@ 0x3c

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
1004204c:	687b      	ldr	r3, [r7, #4]
1004204e:	681b      	ldr	r3, [r3, #0]
10042050:	681b      	ldr	r3, [r3, #0]
10042052:	2208      	movs	r2, #8
10042054:	4013      	ands	r3, r2
10042056:	2b08      	cmp	r3, #8
10042058:	d12d      	bne.n	100420b6 <UART_CheckIdleState+0x82>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
1004205a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
1004205c:	2280      	movs	r2, #128	@ 0x80
1004205e:	0391      	lsls	r1, r2, #14
10042060:	6878      	ldr	r0, [r7, #4]
10042062:	4a47      	ldr	r2, [pc, #284]	@ (10042180 <UART_CheckIdleState+0x14c>)
10042064:	9200      	str	r2, [sp, #0]
10042066:	2200      	movs	r2, #0
10042068:	f000 f88e 	bl	10042188 <UART_WaitOnFlagUntilTimeout>
1004206c:	1e03      	subs	r3, r0, #0
1004206e:	d022      	beq.n	100420b6 <UART_CheckIdleState+0x82>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10042070:	f3ef 8310 	mrs	r3, PRIMASK
10042074:	627b      	str	r3, [r7, #36]	@ 0x24
  return(result);
10042076:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
10042078:	63bb      	str	r3, [r7, #56]	@ 0x38
1004207a:	2301      	movs	r3, #1
1004207c:	62bb      	str	r3, [r7, #40]	@ 0x28
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004207e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
10042080:	f383 8810 	msr	PRIMASK, r3
}
10042084:	46c0      	nop			@ (mov r8, r8)
10042086:	687b      	ldr	r3, [r7, #4]
10042088:	681b      	ldr	r3, [r3, #0]
1004208a:	681a      	ldr	r2, [r3, #0]
1004208c:	687b      	ldr	r3, [r7, #4]
1004208e:	681b      	ldr	r3, [r3, #0]
10042090:	2180      	movs	r1, #128	@ 0x80
10042092:	438a      	bics	r2, r1
10042094:	601a      	str	r2, [r3, #0]
10042096:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
10042098:	62fb      	str	r3, [r7, #44]	@ 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004209a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
1004209c:	f383 8810 	msr	PRIMASK, r3
}
100420a0:	46c0      	nop			@ (mov r8, r8)

      huart->gState = HAL_UART_STATE_READY;
100420a2:	687b      	ldr	r3, [r7, #4]
100420a4:	2288      	movs	r2, #136	@ 0x88
100420a6:	2120      	movs	r1, #32
100420a8:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
100420aa:	687b      	ldr	r3, [r7, #4]
100420ac:	2284      	movs	r2, #132	@ 0x84
100420ae:	2100      	movs	r1, #0
100420b0:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
100420b2:	2303      	movs	r3, #3
100420b4:	e060      	b.n	10042178 <UART_CheckIdleState+0x144>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
100420b6:	687b      	ldr	r3, [r7, #4]
100420b8:	681b      	ldr	r3, [r3, #0]
100420ba:	681b      	ldr	r3, [r3, #0]
100420bc:	2204      	movs	r2, #4
100420be:	4013      	ands	r3, r2
100420c0:	2b04      	cmp	r3, #4
100420c2:	d146      	bne.n	10042152 <UART_CheckIdleState+0x11e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
100420c4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
100420c6:	2280      	movs	r2, #128	@ 0x80
100420c8:	03d1      	lsls	r1, r2, #15
100420ca:	6878      	ldr	r0, [r7, #4]
100420cc:	4a2c      	ldr	r2, [pc, #176]	@ (10042180 <UART_CheckIdleState+0x14c>)
100420ce:	9200      	str	r2, [sp, #0]
100420d0:	2200      	movs	r2, #0
100420d2:	f000 f859 	bl	10042188 <UART_WaitOnFlagUntilTimeout>
100420d6:	1e03      	subs	r3, r0, #0
100420d8:	d03b      	beq.n	10042152 <UART_CheckIdleState+0x11e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100420da:	f3ef 8310 	mrs	r3, PRIMASK
100420de:	60fb      	str	r3, [r7, #12]
  return(result);
100420e0:	68fb      	ldr	r3, [r7, #12]
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
100420e2:	637b      	str	r3, [r7, #52]	@ 0x34
100420e4:	2301      	movs	r3, #1
100420e6:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100420e8:	693b      	ldr	r3, [r7, #16]
100420ea:	f383 8810 	msr	PRIMASK, r3
}
100420ee:	46c0      	nop			@ (mov r8, r8)
100420f0:	687b      	ldr	r3, [r7, #4]
100420f2:	681b      	ldr	r3, [r3, #0]
100420f4:	681a      	ldr	r2, [r3, #0]
100420f6:	687b      	ldr	r3, [r7, #4]
100420f8:	681b      	ldr	r3, [r3, #0]
100420fa:	4922      	ldr	r1, [pc, #136]	@ (10042184 <UART_CheckIdleState+0x150>)
100420fc:	400a      	ands	r2, r1
100420fe:	601a      	str	r2, [r3, #0]
10042100:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10042102:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042104:	697b      	ldr	r3, [r7, #20]
10042106:	f383 8810 	msr	PRIMASK, r3
}
1004210a:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
1004210c:	f3ef 8310 	mrs	r3, PRIMASK
10042110:	61bb      	str	r3, [r7, #24]
  return(result);
10042112:	69bb      	ldr	r3, [r7, #24]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
10042114:	633b      	str	r3, [r7, #48]	@ 0x30
10042116:	2301      	movs	r3, #1
10042118:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004211a:	69fb      	ldr	r3, [r7, #28]
1004211c:	f383 8810 	msr	PRIMASK, r3
}
10042120:	46c0      	nop			@ (mov r8, r8)
10042122:	687b      	ldr	r3, [r7, #4]
10042124:	681b      	ldr	r3, [r3, #0]
10042126:	689a      	ldr	r2, [r3, #8]
10042128:	687b      	ldr	r3, [r7, #4]
1004212a:	681b      	ldr	r3, [r3, #0]
1004212c:	2101      	movs	r1, #1
1004212e:	438a      	bics	r2, r1
10042130:	609a      	str	r2, [r3, #8]
10042132:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10042134:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042136:	6a3b      	ldr	r3, [r7, #32]
10042138:	f383 8810 	msr	PRIMASK, r3
}
1004213c:	46c0      	nop			@ (mov r8, r8)

      huart->RxState = HAL_UART_STATE_READY;
1004213e:	687b      	ldr	r3, [r7, #4]
10042140:	228c      	movs	r2, #140	@ 0x8c
10042142:	2120      	movs	r1, #32
10042144:	5099      	str	r1, [r3, r2]

      __HAL_UNLOCK(huart);
10042146:	687b      	ldr	r3, [r7, #4]
10042148:	2284      	movs	r2, #132	@ 0x84
1004214a:	2100      	movs	r1, #0
1004214c:	5499      	strb	r1, [r3, r2]

      /* Timeout occurred */
      return HAL_TIMEOUT;
1004214e:	2303      	movs	r3, #3
10042150:	e012      	b.n	10042178 <UART_CheckIdleState+0x144>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
10042152:	687b      	ldr	r3, [r7, #4]
10042154:	2288      	movs	r2, #136	@ 0x88
10042156:	2120      	movs	r1, #32
10042158:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_READY;
1004215a:	687b      	ldr	r3, [r7, #4]
1004215c:	228c      	movs	r2, #140	@ 0x8c
1004215e:	2120      	movs	r1, #32
10042160:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
10042162:	687b      	ldr	r3, [r7, #4]
10042164:	2200      	movs	r2, #0
10042166:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
10042168:	687b      	ldr	r3, [r7, #4]
1004216a:	2200      	movs	r2, #0
1004216c:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
1004216e:	687b      	ldr	r3, [r7, #4]
10042170:	2284      	movs	r2, #132	@ 0x84
10042172:	2100      	movs	r1, #0
10042174:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
10042176:	2300      	movs	r3, #0
}
10042178:	0018      	movs	r0, r3
1004217a:	46bd      	mov	sp, r7
1004217c:	b010      	add	sp, #64	@ 0x40
1004217e:	bd80      	pop	{r7, pc}
10042180:	01ffffff 	.word	0x01ffffff
10042184:	fffffedf 	.word	0xfffffedf

10042188 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
10042188:	b580      	push	{r7, lr}
1004218a:	b084      	sub	sp, #16
1004218c:	af00      	add	r7, sp, #0
1004218e:	60f8      	str	r0, [r7, #12]
10042190:	60b9      	str	r1, [r7, #8]
10042192:	603b      	str	r3, [r7, #0]
10042194:	1dfb      	adds	r3, r7, #7
10042196:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
10042198:	e051      	b.n	1004223e <UART_WaitOnFlagUntilTimeout+0xb6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
1004219a:	69bb      	ldr	r3, [r7, #24]
1004219c:	3301      	adds	r3, #1
1004219e:	d04e      	beq.n	1004223e <UART_WaitOnFlagUntilTimeout+0xb6>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
100421a0:	f7fe fef2 	bl	10040f88 <HAL_GetTick>
100421a4:	0002      	movs	r2, r0
100421a6:	683b      	ldr	r3, [r7, #0]
100421a8:	1ad3      	subs	r3, r2, r3
100421aa:	69ba      	ldr	r2, [r7, #24]
100421ac:	429a      	cmp	r2, r3
100421ae:	d302      	bcc.n	100421b6 <UART_WaitOnFlagUntilTimeout+0x2e>
100421b0:	69bb      	ldr	r3, [r7, #24]
100421b2:	2b00      	cmp	r3, #0
100421b4:	d101      	bne.n	100421ba <UART_WaitOnFlagUntilTimeout+0x32>
      {

        return HAL_TIMEOUT;
100421b6:	2303      	movs	r3, #3
100421b8:	e051      	b.n	1004225e <UART_WaitOnFlagUntilTimeout+0xd6>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
100421ba:	68fb      	ldr	r3, [r7, #12]
100421bc:	681b      	ldr	r3, [r3, #0]
100421be:	681b      	ldr	r3, [r3, #0]
100421c0:	2204      	movs	r2, #4
100421c2:	4013      	ands	r3, r2
100421c4:	d03b      	beq.n	1004223e <UART_WaitOnFlagUntilTimeout+0xb6>
100421c6:	68bb      	ldr	r3, [r7, #8]
100421c8:	2b80      	cmp	r3, #128	@ 0x80
100421ca:	d038      	beq.n	1004223e <UART_WaitOnFlagUntilTimeout+0xb6>
100421cc:	68bb      	ldr	r3, [r7, #8]
100421ce:	2b40      	cmp	r3, #64	@ 0x40
100421d0:	d035      	beq.n	1004223e <UART_WaitOnFlagUntilTimeout+0xb6>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
100421d2:	68fb      	ldr	r3, [r7, #12]
100421d4:	681b      	ldr	r3, [r3, #0]
100421d6:	69db      	ldr	r3, [r3, #28]
100421d8:	2208      	movs	r2, #8
100421da:	4013      	ands	r3, r2
100421dc:	2b08      	cmp	r3, #8
100421de:	d111      	bne.n	10042204 <UART_WaitOnFlagUntilTimeout+0x7c>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
100421e0:	68fb      	ldr	r3, [r7, #12]
100421e2:	681b      	ldr	r3, [r3, #0]
100421e4:	2208      	movs	r2, #8
100421e6:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
100421e8:	68fb      	ldr	r3, [r7, #12]
100421ea:	0018      	movs	r0, r3
100421ec:	f000 f83c 	bl	10042268 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
100421f0:	68fb      	ldr	r3, [r7, #12]
100421f2:	2290      	movs	r2, #144	@ 0x90
100421f4:	2108      	movs	r1, #8
100421f6:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
100421f8:	68fb      	ldr	r3, [r7, #12]
100421fa:	2284      	movs	r2, #132	@ 0x84
100421fc:	2100      	movs	r1, #0
100421fe:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
10042200:	2301      	movs	r3, #1
10042202:	e02c      	b.n	1004225e <UART_WaitOnFlagUntilTimeout+0xd6>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
10042204:	68fb      	ldr	r3, [r7, #12]
10042206:	681b      	ldr	r3, [r3, #0]
10042208:	69da      	ldr	r2, [r3, #28]
1004220a:	2380      	movs	r3, #128	@ 0x80
1004220c:	011b      	lsls	r3, r3, #4
1004220e:	401a      	ands	r2, r3
10042210:	2380      	movs	r3, #128	@ 0x80
10042212:	011b      	lsls	r3, r3, #4
10042214:	429a      	cmp	r2, r3
10042216:	d112      	bne.n	1004223e <UART_WaitOnFlagUntilTimeout+0xb6>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
10042218:	68fb      	ldr	r3, [r7, #12]
1004221a:	681b      	ldr	r3, [r3, #0]
1004221c:	2280      	movs	r2, #128	@ 0x80
1004221e:	0112      	lsls	r2, r2, #4
10042220:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
10042222:	68fb      	ldr	r3, [r7, #12]
10042224:	0018      	movs	r0, r3
10042226:	f000 f81f 	bl	10042268 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
1004222a:	68fb      	ldr	r3, [r7, #12]
1004222c:	2290      	movs	r2, #144	@ 0x90
1004222e:	2120      	movs	r1, #32
10042230:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
10042232:	68fb      	ldr	r3, [r7, #12]
10042234:	2284      	movs	r2, #132	@ 0x84
10042236:	2100      	movs	r1, #0
10042238:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
1004223a:	2303      	movs	r3, #3
1004223c:	e00f      	b.n	1004225e <UART_WaitOnFlagUntilTimeout+0xd6>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
1004223e:	68fb      	ldr	r3, [r7, #12]
10042240:	681b      	ldr	r3, [r3, #0]
10042242:	69db      	ldr	r3, [r3, #28]
10042244:	68ba      	ldr	r2, [r7, #8]
10042246:	4013      	ands	r3, r2
10042248:	68ba      	ldr	r2, [r7, #8]
1004224a:	1ad3      	subs	r3, r2, r3
1004224c:	425a      	negs	r2, r3
1004224e:	4153      	adcs	r3, r2
10042250:	b2db      	uxtb	r3, r3
10042252:	001a      	movs	r2, r3
10042254:	1dfb      	adds	r3, r7, #7
10042256:	781b      	ldrb	r3, [r3, #0]
10042258:	429a      	cmp	r2, r3
1004225a:	d09e      	beq.n	1004219a <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
1004225c:	2300      	movs	r3, #0
}
1004225e:	0018      	movs	r0, r3
10042260:	46bd      	mov	sp, r7
10042262:	b004      	add	sp, #16
10042264:	bd80      	pop	{r7, pc}
	...

10042268 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
10042268:	b580      	push	{r7, lr}
1004226a:	b08e      	sub	sp, #56	@ 0x38
1004226c:	af00      	add	r7, sp, #0
1004226e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10042270:	f3ef 8310 	mrs	r3, PRIMASK
10042274:	617b      	str	r3, [r7, #20]
  return(result);
10042276:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
10042278:	637b      	str	r3, [r7, #52]	@ 0x34
1004227a:	2301      	movs	r3, #1
1004227c:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004227e:	69bb      	ldr	r3, [r7, #24]
10042280:	f383 8810 	msr	PRIMASK, r3
}
10042284:	46c0      	nop			@ (mov r8, r8)
10042286:	687b      	ldr	r3, [r7, #4]
10042288:	681b      	ldr	r3, [r3, #0]
1004228a:	681a      	ldr	r2, [r3, #0]
1004228c:	687b      	ldr	r3, [r7, #4]
1004228e:	681b      	ldr	r3, [r3, #0]
10042290:	4926      	ldr	r1, [pc, #152]	@ (1004232c <UART_EndRxTransfer+0xc4>)
10042292:	400a      	ands	r2, r1
10042294:	601a      	str	r2, [r3, #0]
10042296:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
10042298:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
1004229a:	69fb      	ldr	r3, [r7, #28]
1004229c:	f383 8810 	msr	PRIMASK, r3
}
100422a0:	46c0      	nop			@ (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100422a2:	f3ef 8310 	mrs	r3, PRIMASK
100422a6:	623b      	str	r3, [r7, #32]
  return(result);
100422a8:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
100422aa:	633b      	str	r3, [r7, #48]	@ 0x30
100422ac:	2301      	movs	r3, #1
100422ae:	627b      	str	r3, [r7, #36]	@ 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100422b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
100422b2:	f383 8810 	msr	PRIMASK, r3
}
100422b6:	46c0      	nop			@ (mov r8, r8)
100422b8:	687b      	ldr	r3, [r7, #4]
100422ba:	681b      	ldr	r3, [r3, #0]
100422bc:	689a      	ldr	r2, [r3, #8]
100422be:	687b      	ldr	r3, [r7, #4]
100422c0:	681b      	ldr	r3, [r3, #0]
100422c2:	491b      	ldr	r1, [pc, #108]	@ (10042330 <UART_EndRxTransfer+0xc8>)
100422c4:	400a      	ands	r2, r1
100422c6:	609a      	str	r2, [r3, #8]
100422c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
100422ca:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100422cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
100422ce:	f383 8810 	msr	PRIMASK, r3
}
100422d2:	46c0      	nop			@ (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
100422d4:	687b      	ldr	r3, [r7, #4]
100422d6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
100422d8:	2b01      	cmp	r3, #1
100422da:	d118      	bne.n	1004230e <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
100422dc:	f3ef 8310 	mrs	r3, PRIMASK
100422e0:	60bb      	str	r3, [r7, #8]
  return(result);
100422e2:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
100422e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
100422e6:	2301      	movs	r3, #1
100422e8:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
100422ea:	68fb      	ldr	r3, [r7, #12]
100422ec:	f383 8810 	msr	PRIMASK, r3
}
100422f0:	46c0      	nop			@ (mov r8, r8)
100422f2:	687b      	ldr	r3, [r7, #4]
100422f4:	681b      	ldr	r3, [r3, #0]
100422f6:	681a      	ldr	r2, [r3, #0]
100422f8:	687b      	ldr	r3, [r7, #4]
100422fa:	681b      	ldr	r3, [r3, #0]
100422fc:	2110      	movs	r1, #16
100422fe:	438a      	bics	r2, r1
10042300:	601a      	str	r2, [r3, #0]
10042302:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
10042304:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10042306:	693b      	ldr	r3, [r7, #16]
10042308:	f383 8810 	msr	PRIMASK, r3
}
1004230c:	46c0      	nop			@ (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
1004230e:	687b      	ldr	r3, [r7, #4]
10042310:	228c      	movs	r2, #140	@ 0x8c
10042312:	2120      	movs	r1, #32
10042314:	5099      	str	r1, [r3, r2]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
10042316:	687b      	ldr	r3, [r7, #4]
10042318:	2200      	movs	r2, #0
1004231a:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
1004231c:	687b      	ldr	r3, [r7, #4]
1004231e:	2200      	movs	r2, #0
10042320:	675a      	str	r2, [r3, #116]	@ 0x74
}
10042322:	46c0      	nop			@ (mov r8, r8)
10042324:	46bd      	mov	sp, r7
10042326:	b00e      	add	sp, #56	@ 0x38
10042328:	bd80      	pop	{r7, pc}
1004232a:	46c0      	nop			@ (mov r8, r8)
1004232c:	fffffedf 	.word	0xfffffedf
10042330:	effffffe 	.word	0xeffffffe

10042334 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
10042334:	b580      	push	{r7, lr}
10042336:	b084      	sub	sp, #16
10042338:	af00      	add	r7, sp, #0
1004233a:	6078      	str	r0, [r7, #4]
1004233c:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
1004233e:	687b      	ldr	r3, [r7, #4]
10042340:	2284      	movs	r2, #132	@ 0x84
10042342:	5c9b      	ldrb	r3, [r3, r2]
10042344:	2b01      	cmp	r3, #1
10042346:	d101      	bne.n	1004234c <HAL_UARTEx_SetTxFifoThreshold+0x18>
10042348:	2302      	movs	r3, #2
1004234a:	e02e      	b.n	100423aa <HAL_UARTEx_SetTxFifoThreshold+0x76>
1004234c:	687b      	ldr	r3, [r7, #4]
1004234e:	2284      	movs	r2, #132	@ 0x84
10042350:	2101      	movs	r1, #1
10042352:	5499      	strb	r1, [r3, r2]

  huart->gState = HAL_UART_STATE_BUSY;
10042354:	687b      	ldr	r3, [r7, #4]
10042356:	2288      	movs	r2, #136	@ 0x88
10042358:	2124      	movs	r1, #36	@ 0x24
1004235a:	5099      	str	r1, [r3, r2]

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
1004235c:	687b      	ldr	r3, [r7, #4]
1004235e:	681b      	ldr	r3, [r3, #0]
10042360:	681b      	ldr	r3, [r3, #0]
10042362:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
10042364:	687b      	ldr	r3, [r7, #4]
10042366:	681b      	ldr	r3, [r3, #0]
10042368:	681a      	ldr	r2, [r3, #0]
1004236a:	687b      	ldr	r3, [r7, #4]
1004236c:	681b      	ldr	r3, [r3, #0]
1004236e:	2101      	movs	r1, #1
10042370:	438a      	bics	r2, r1
10042372:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
10042374:	687b      	ldr	r3, [r7, #4]
10042376:	681b      	ldr	r3, [r3, #0]
10042378:	689b      	ldr	r3, [r3, #8]
1004237a:	00db      	lsls	r3, r3, #3
1004237c:	08d9      	lsrs	r1, r3, #3
1004237e:	687b      	ldr	r3, [r7, #4]
10042380:	681b      	ldr	r3, [r3, #0]
10042382:	683a      	ldr	r2, [r7, #0]
10042384:	430a      	orrs	r2, r1
10042386:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
10042388:	687b      	ldr	r3, [r7, #4]
1004238a:	0018      	movs	r0, r3
1004238c:	f000 f854 	bl	10042438 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
10042390:	687b      	ldr	r3, [r7, #4]
10042392:	681b      	ldr	r3, [r3, #0]
10042394:	68fa      	ldr	r2, [r7, #12]
10042396:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
10042398:	687b      	ldr	r3, [r7, #4]
1004239a:	2288      	movs	r2, #136	@ 0x88
1004239c:	2120      	movs	r1, #32
1004239e:	5099      	str	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
100423a0:	687b      	ldr	r3, [r7, #4]
100423a2:	2284      	movs	r2, #132	@ 0x84
100423a4:	2100      	movs	r1, #0
100423a6:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
100423a8:	2300      	movs	r3, #0
}
100423aa:	0018      	movs	r0, r3
100423ac:	46bd      	mov	sp, r7
100423ae:	b004      	add	sp, #16
100423b0:	bd80      	pop	{r7, pc}
	...

100423b4 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
100423b4:	b580      	push	{r7, lr}
100423b6:	b084      	sub	sp, #16
100423b8:	af00      	add	r7, sp, #0
100423ba:	6078      	str	r0, [r7, #4]
100423bc:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
100423be:	687b      	ldr	r3, [r7, #4]
100423c0:	2284      	movs	r2, #132	@ 0x84
100423c2:	5c9b      	ldrb	r3, [r3, r2]
100423c4:	2b01      	cmp	r3, #1
100423c6:	d101      	bne.n	100423cc <HAL_UARTEx_SetRxFifoThreshold+0x18>
100423c8:	2302      	movs	r3, #2
100423ca:	e02f      	b.n	1004242c <HAL_UARTEx_SetRxFifoThreshold+0x78>
100423cc:	687b      	ldr	r3, [r7, #4]
100423ce:	2284      	movs	r2, #132	@ 0x84
100423d0:	2101      	movs	r1, #1
100423d2:	5499      	strb	r1, [r3, r2]

  huart->gState = HAL_UART_STATE_BUSY;
100423d4:	687b      	ldr	r3, [r7, #4]
100423d6:	2288      	movs	r2, #136	@ 0x88
100423d8:	2124      	movs	r1, #36	@ 0x24
100423da:	5099      	str	r1, [r3, r2]

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
100423dc:	687b      	ldr	r3, [r7, #4]
100423de:	681b      	ldr	r3, [r3, #0]
100423e0:	681b      	ldr	r3, [r3, #0]
100423e2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
100423e4:	687b      	ldr	r3, [r7, #4]
100423e6:	681b      	ldr	r3, [r3, #0]
100423e8:	681a      	ldr	r2, [r3, #0]
100423ea:	687b      	ldr	r3, [r7, #4]
100423ec:	681b      	ldr	r3, [r3, #0]
100423ee:	2101      	movs	r1, #1
100423f0:	438a      	bics	r2, r1
100423f2:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
100423f4:	687b      	ldr	r3, [r7, #4]
100423f6:	681b      	ldr	r3, [r3, #0]
100423f8:	689b      	ldr	r3, [r3, #8]
100423fa:	4a0e      	ldr	r2, [pc, #56]	@ (10042434 <HAL_UARTEx_SetRxFifoThreshold+0x80>)
100423fc:	4013      	ands	r3, r2
100423fe:	0019      	movs	r1, r3
10042400:	687b      	ldr	r3, [r7, #4]
10042402:	681b      	ldr	r3, [r3, #0]
10042404:	683a      	ldr	r2, [r7, #0]
10042406:	430a      	orrs	r2, r1
10042408:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
1004240a:	687b      	ldr	r3, [r7, #4]
1004240c:	0018      	movs	r0, r3
1004240e:	f000 f813 	bl	10042438 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
10042412:	687b      	ldr	r3, [r7, #4]
10042414:	681b      	ldr	r3, [r3, #0]
10042416:	68fa      	ldr	r2, [r7, #12]
10042418:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
1004241a:	687b      	ldr	r3, [r7, #4]
1004241c:	2288      	movs	r2, #136	@ 0x88
1004241e:	2120      	movs	r1, #32
10042420:	5099      	str	r1, [r3, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
10042422:	687b      	ldr	r3, [r7, #4]
10042424:	2284      	movs	r2, #132	@ 0x84
10042426:	2100      	movs	r1, #0
10042428:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
1004242a:	2300      	movs	r3, #0
}
1004242c:	0018      	movs	r0, r3
1004242e:	46bd      	mov	sp, r7
10042430:	b004      	add	sp, #16
10042432:	bd80      	pop	{r7, pc}
10042434:	f1ffffff 	.word	0xf1ffffff

10042438 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
10042438:	b5f0      	push	{r4, r5, r6, r7, lr}
1004243a:	b085      	sub	sp, #20
1004243c:	af00      	add	r7, sp, #0
1004243e:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
10042440:	687b      	ldr	r3, [r7, #4]
10042442:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
10042444:	2b00      	cmp	r3, #0
10042446:	d108      	bne.n	1004245a <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
10042448:	687b      	ldr	r3, [r7, #4]
1004244a:	226a      	movs	r2, #106	@ 0x6a
1004244c:	2101      	movs	r1, #1
1004244e:	5299      	strh	r1, [r3, r2]
    huart->NbRxDataToProcess = 1U;
10042450:	687b      	ldr	r3, [r7, #4]
10042452:	2268      	movs	r2, #104	@ 0x68
10042454:	2101      	movs	r1, #1
10042456:	5299      	strh	r1, [r3, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
10042458:	e043      	b.n	100424e2 <UARTEx_SetNbDataToProcess+0xaa>
    rx_fifo_depth = RX_FIFO_DEPTH;
1004245a:	260f      	movs	r6, #15
1004245c:	19bb      	adds	r3, r7, r6
1004245e:	2208      	movs	r2, #8
10042460:	701a      	strb	r2, [r3, #0]
    tx_fifo_depth = TX_FIFO_DEPTH;
10042462:	200e      	movs	r0, #14
10042464:	183b      	adds	r3, r7, r0
10042466:	2208      	movs	r2, #8
10042468:	701a      	strb	r2, [r3, #0]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
1004246a:	687b      	ldr	r3, [r7, #4]
1004246c:	681b      	ldr	r3, [r3, #0]
1004246e:	689b      	ldr	r3, [r3, #8]
10042470:	0e5b      	lsrs	r3, r3, #25
10042472:	b2da      	uxtb	r2, r3
10042474:	240d      	movs	r4, #13
10042476:	193b      	adds	r3, r7, r4
10042478:	2107      	movs	r1, #7
1004247a:	400a      	ands	r2, r1
1004247c:	701a      	strb	r2, [r3, #0]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
1004247e:	687b      	ldr	r3, [r7, #4]
10042480:	681b      	ldr	r3, [r3, #0]
10042482:	689b      	ldr	r3, [r3, #8]
10042484:	0f5b      	lsrs	r3, r3, #29
10042486:	b2da      	uxtb	r2, r3
10042488:	250c      	movs	r5, #12
1004248a:	197b      	adds	r3, r7, r5
1004248c:	2107      	movs	r1, #7
1004248e:	400a      	ands	r2, r1
10042490:	701a      	strb	r2, [r3, #0]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
10042492:	183b      	adds	r3, r7, r0
10042494:	781b      	ldrb	r3, [r3, #0]
10042496:	197a      	adds	r2, r7, r5
10042498:	7812      	ldrb	r2, [r2, #0]
1004249a:	4914      	ldr	r1, [pc, #80]	@ (100424ec <UARTEx_SetNbDataToProcess+0xb4>)
1004249c:	5c8a      	ldrb	r2, [r1, r2]
1004249e:	435a      	muls	r2, r3
100424a0:	0010      	movs	r0, r2
                               (uint16_t)denominator[tx_fifo_threshold];
100424a2:	197b      	adds	r3, r7, r5
100424a4:	781b      	ldrb	r3, [r3, #0]
100424a6:	4a12      	ldr	r2, [pc, #72]	@ (100424f0 <UARTEx_SetNbDataToProcess+0xb8>)
100424a8:	5cd3      	ldrb	r3, [r2, r3]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
100424aa:	0019      	movs	r1, r3
100424ac:	f7fd fe92 	bl	100401d4 <__divsi3>
100424b0:	0003      	movs	r3, r0
100424b2:	b299      	uxth	r1, r3
100424b4:	687b      	ldr	r3, [r7, #4]
100424b6:	226a      	movs	r2, #106	@ 0x6a
100424b8:	5299      	strh	r1, [r3, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
100424ba:	19bb      	adds	r3, r7, r6
100424bc:	781b      	ldrb	r3, [r3, #0]
100424be:	193a      	adds	r2, r7, r4
100424c0:	7812      	ldrb	r2, [r2, #0]
100424c2:	490a      	ldr	r1, [pc, #40]	@ (100424ec <UARTEx_SetNbDataToProcess+0xb4>)
100424c4:	5c8a      	ldrb	r2, [r1, r2]
100424c6:	435a      	muls	r2, r3
100424c8:	0010      	movs	r0, r2
                               (uint16_t)denominator[rx_fifo_threshold];
100424ca:	193b      	adds	r3, r7, r4
100424cc:	781b      	ldrb	r3, [r3, #0]
100424ce:	4a08      	ldr	r2, [pc, #32]	@ (100424f0 <UARTEx_SetNbDataToProcess+0xb8>)
100424d0:	5cd3      	ldrb	r3, [r2, r3]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
100424d2:	0019      	movs	r1, r3
100424d4:	f7fd fe7e 	bl	100401d4 <__divsi3>
100424d8:	0003      	movs	r3, r0
100424da:	b299      	uxth	r1, r3
100424dc:	687b      	ldr	r3, [r7, #4]
100424de:	2268      	movs	r2, #104	@ 0x68
100424e0:	5299      	strh	r1, [r3, r2]
}
100424e2:	46c0      	nop			@ (mov r8, r8)
100424e4:	46bd      	mov	sp, r7
100424e6:	b005      	add	sp, #20
100424e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
100424ea:	46c0      	nop			@ (mov r8, r8)
100424ec:	100425a8 	.word	0x100425a8
100424f0:	100425b0 	.word	0x100425b0

100424f4 <memset>:
100424f4:	0003      	movs	r3, r0
100424f6:	1882      	adds	r2, r0, r2
100424f8:	4293      	cmp	r3, r2
100424fa:	d100      	bne.n	100424fe <memset+0xa>
100424fc:	4770      	bx	lr
100424fe:	7019      	strb	r1, [r3, #0]
10042500:	3301      	adds	r3, #1
10042502:	e7f9      	b.n	100424f8 <memset+0x4>

Disassembly of section .init:

10042504 <_init>:
10042504:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10042506:	46c0      	nop			@ (mov r8, r8)

Disassembly of section .fini:

10042508 <_fini>:
10042508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1004250a:	46c0      	nop			@ (mov r8, r8)
